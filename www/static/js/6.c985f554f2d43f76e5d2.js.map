{"version":3,"sources":["webpack:///static/js/6.c985f554f2d43f76e5d2.js","webpack:///insights.vue?b4a7","webpack:///./src/modules/professional/company/components/invoices/insights.vue?2f81","webpack:///./src/modules/professional/company/components/invoices/insights.vue?4d11","webpack:///./src/modules/professional/company/components/invoices/insights.vue?3a9a","webpack:///./src/modules/professional/company/components/invoices/insights.vue","webpack:///./~/moment-range/dist/moment-range.js?35b0*****","webpack:///./~/chartjs-color/index.js?3916","webpack:///./~/chart.js/src/chart.js?462d","webpack:///./~/chart.js/src/charts/Chart.Bar.js?be80","webpack:///./~/chart.js/src/charts/Chart.Bubble.js?d5af","webpack:///./~/chart.js/src/charts/Chart.Doughnut.js?2f08","webpack:///./~/chart.js/src/charts/Chart.Line.js?c913","webpack:///./~/chart.js/src/charts/Chart.PolarArea.js?26d1","webpack:///./~/chart.js/src/charts/Chart.Radar.js?f441","webpack:///./~/chart.js/src/charts/Chart.Scatter.js?9698","webpack:///./~/chart.js/src/controllers/controller.bar.js?109d","webpack:///./~/chart.js/src/controllers/controller.bubble.js?c1c2","webpack:///./~/chart.js/src/controllers/controller.doughnut.js?e144","webpack:///./~/chart.js/src/controllers/controller.line.js?8ad2","webpack:///./~/chart.js/src/controllers/controller.polarArea.js?7240","webpack:///./~/chart.js/src/controllers/controller.radar.js?1fd7","webpack:///./~/chart.js/src/core/core.animation.js?6da6","webpack:///./~/chart.js/src/core/core.canvasHelpers.js?032e","webpack:///./~/chart.js/src/core/core.controller.js?8f11","webpack:///./~/chart.js/src/core/core.datasetController.js?3cfb","webpack:///./~/chart.js/src/core/core.element.js?921b","webpack:///./~/chart.js/src/core/core.helpers.js?b72e","webpack:///./~/chart.js/src/core/core.interaction.js?1df1","webpack:///./~/chart.js/src/core/core.js?5de4","webpack:///./~/chart.js/src/core/core.layoutService.js?5132","webpack:///./~/chart.js/src/core/core.plugin.js?815c","webpack:///./~/chart.js/src/core/core.scale.js?e592","webpack:///./~/chart.js/src/core/core.scaleService.js?478e","webpack:///./~/chart.js/src/core/core.ticks.js?dd76","webpack:///./~/chart.js/src/core/core.tooltip.js?484f","webpack:///./~/chart.js/src/elements/element.arc.js?5348","webpack:///./~/chart.js/src/elements/element.line.js?0739","webpack:///./~/chart.js/src/elements/element.point.js?5d09","webpack:///./~/chart.js/src/elements/element.rectangle.js?20fb","webpack:///./~/chart.js/src/platforms/platform.dom.js?2c89","webpack:///./~/chart.js/src/platforms/platform.js?7878","webpack:///./~/chart.js/src/plugins/plugin.filler.js?860e","webpack:///./~/chart.js/src/plugins/plugin.legend.js?0c30","webpack:///./~/chart.js/src/plugins/plugin.title.js?c75c","webpack:///./~/chart.js/src/scales/scale.category.js?ac38","webpack:///./~/chart.js/src/scales/scale.linear.js?85a5","webpack:///./~/chart.js/src/scales/scale.linearbase.js?7994","webpack:///./~/chart.js/src/scales/scale.logarithmic.js?00a7","webpack:///./~/chart.js/src/scales/scale.radialLinear.js?fc0a","webpack:///./~/chart.js/src/scales/scale.time.js?d7ea","webpack:///./~/chartjs-color-string/color-string.js?2e4c","webpack:///./~/color-convert/conversions.js?6fff","webpack:///./~/color-convert/index.js?6b44","webpack:///./~/color-name/index.js?5993","webpack:///./src/models/ChartOptions.js?ae95"],"names":["webpackJsonp","1080","module","__webpack_exports__","__webpack_require__","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_1__components_main_header_vue__","__WEBPACK_IMPORTED_MODULE_1__components_main_header_vue___default","n","__WEBPACK_IMPORTED_MODULE_2__components_card_placeholder_vue__","__WEBPACK_IMPORTED_MODULE_2__components_card_placeholder_vue___default","__WEBPACK_IMPORTED_MODULE_3_chart_js__","__WEBPACK_IMPORTED_MODULE_3_chart_js___default","__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__","__WEBPACK_IMPORTED_MODULE_5_moment__","__WEBPACK_IMPORTED_MODULE_5_moment___default","__WEBPACK_IMPORTED_MODULE_6_moment_range__","moment","i","a","name","components","mainHeader","cardPlaceholder","data","current_month","currentValueReceived","statusCount","confirmed","pending","canceled","expired","invoices","categories","interactions","professionalsCardsOpened","chartByStatus","chartByWeek","chartByCategory","placeholder","insights","by_status","by_week","by_category","mounted","this","getInvoices","methods","isExpired","date","diff","resetData","statusCountpending","statusCountcanceled","statusCountexpired","dataByCategory","that","categoriesNames","_","flatten","map","category","sort","categoriesSlug","slug","labels","uniq","forEach","label","indexCategories","currentColor","colorByCategory","datasets","backgroundColor","push","hex","borderColor","rgba","values","Array","length","labelIndex","invoice","subscription","plan","countStatus","is_expired","expire_at","is_confirmed","is_canceled","dataByWeek","indexDataSet","currentDate","Math","ceil","dataByStatus","handleChartType","type","destroy","setTimeout","$refs","company_id","$route","params","search","init","startOf","format","end","endOf","$http","post","then","response","window","cordova","catch","error","console","log","handlePrevMonth","subtract","handleNextMonth","add","1204","exports","version","sources","names","mappings","file","sourcesContent","sourceRoot","1302","content","locals","1486","render","_vm","_h","$createElement","_c","_self","staticClass","attrs","title","cursor","action","hasback","_v","on","click","$event","_s","_f","_e","_l","directives","rawName","expression","ref","staticRenderFns","422","Component","865","root","factory","__WEBPACK_EXTERNAL_MODULE_1__","modules","moduleId","installedModules","l","call","m","c","d","getter","o","configurable","enumerable","get","__esModule","object","property","prototype","hasOwnProperty","p","s","Symbol","assign","normalizeOpts","isCallable","contains","dscr","e","w","options","desc","arguments","writable","gs","set","undefined","obj","foo","bar","trzy","keys","max","dest","src","key","create","process","result","TypeError","String","str","indexOf","searchString","validTypes","symbol","iterator","toPrimitive","toStringTag","x","constructor","NativeSymbol","SymbolPolyfill","HiddenSymbol","isNativeSafe","validateSymbol","defineProperties","objPrototype","globalSymbols","ignore","generateName","created","ie11BugWorkaround","postfix","description","__description__","__name__","for","keyFor","hasInstance","isConcatSpreadable","match","replace","species","split","unscopables","toString","valueOf","isSymbol","_interopRequireDefault","default","_defineProperty","_classCallCheck","instance","Constructor","extendMoment","range","start","INTERVALS","DateRange","fn","within","toDate","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_i","next","done","err","isArray","_typeof","_createClass","target","props","descriptor","protoProps","staticProps","_moment","_moment2","_es6Symbol","_es6Symbol2","year","quarter","month","week","day","hour","minute","second","_start","_start$split","_start$split2","other","sameStartEnd","isSame","sameEndStart","overlaps","min","interval","exclusive","step","abs","iteration","current","clone","unit","floor","Infinity","center","oStart","oEnd","startInRange","endInRange","rounded","isEqual","adjacent","intersect","894","convert","string","Color","valid","rgb","hsl","hsv","hwb","cmyk","alpha","vals","getRgba","setValues","getHsla","getHwb","r","red","lightness","v","whiteness","cyan","isValid","setSpace","rgbArray","hslArray","hsvArray","hwbArray","concat","cmykArray","rgbaArray","hslaArray","val","setChannel","green","blue","hue","saturation","saturationv","blackness","magenta","yellow","black","hexString","rgbString","rgbaString","percentString","hslString","hslaString","hwbString","keyword","rgbNumber","luminosity","lum","chan","pow","contrast","color2","lum1","lum2","level","contrastRatio","dark","light","negate","lighten","ratio","darken","saturate","desaturate","whiten","blacken","greyscale","clearer","opaquer","rotate","degrees","mix","mixinColor","weight","color1","w1","w2","toJSON","source","prop","slice","spaces","maxes","getValues","space","charAt","chans","capped","round","sname","args","index","svalues","907","Chart","plugins","register","908","Bar","context","config","909","Bubble","910","Doughnut","911","Line","912","PolarArea","913","Radar","914","defaultConfig","hover","mode","scales","xAxes","position","id","yAxes","tooltips","callbacks","tooltipItem","xLabel","yLabel","defaults","scatter","controllers","line","Scatter","915","helpers","categoryPercentage","barPercentage","gridLines","offsetGridLines","DatasetController","extend","dataElementType","elements","Rectangle","initialize","meta","me","apply","getMeta","stack","getDataset","update","reset","ilen","_ruler","getRuler","updateElement","rectangle","chart","dataset","custom","rectangleOptions","_xScale","getScaleForId","xAxisID","_yScale","yAxisID","_datasetIndex","_index","_model","datasetLabel","borderSkipped","getValueAtIndexOrDefault","borderWidth","updateElementGeometry","pivot","model","vscale","getValueScale","base","getBasePixel","horizontal","isHorizontal","ruler","vpixels","calculateBarValuePixels","ipixels","calculateBarIndexPixels","head","y","height","size","width","getValueScaleId","getIndexScaleId","getIndexScale","getStackCount","last","scale","stacked","stacks","getDatasetMeta","isDatasetVisible","getStackIndex","datasetIndex","stackCount","fullSize","tickSize","ticks","categorySize","fullBarSize","barSize","getValueOrDefault","barThickness","maxBarThickness","categorySpacing","barSpacing","imeta","ivalue","Number","controller","getPixelForValue","isCombo","stackIndex","draw","canvas","clipArea","ctx","chartArea","isNaN","unclipArea","setHoverStyle","hoverBackgroundColor","getHoverColor","hoverBorderColor","hoverBorderWidth","removeHoverStyle","rectangleElementOptions","horizontalBar","tooltipItems","916","bubble","dataPoint","Point","points","each","point","xScale","yScale","pointElementOptions","dsIndex","getPixelForDecimal","NaN","radius","getRadius","hitRadius","skip","hoverRadius","dataVal","917","doughnut","animation","animateRotate","animateScale","aspectRatio","legendCallback","text","join","legend","generateLabels","ds","arc","arcOpts","fillStyle","strokeStyle","lineWidth","hidden","onClick","legendItem","cutoutPercentage","rotation","PI","circumference","dataLabel","pie","Arc","linkScales","noop","getRingIndex","ringIndex","j","opts","availableWidth","right","left","availableHeight","bottom","top","minSize","offset","startAngle","endAngle","cos","sin","contains0","contains90","contains180","contains270","cutout","getMaxBorderWidth","outerRadius","innerRadius","radiusLength","getVisibleDatasetCount","offsetX","offsetY","total","calculateTotal","animationOpts","centerX","centerY","calculateCircumference","valueAtIndexOrDefault","element","hoverWidth","_chart","918","lineEnabled","showLine","showLines","spanGaps","datasetElementType","lineElementOptions","tension","lineTension","_scale","_children","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill","steppedLine","stepped","cubicInterpolationMode","updateBezierControlPoints","getPointBackgroundColor","pointBackgroundColor","getPointBorderColor","pointBorderColor","getPointBorderWidth","pointBorderWidth","pointOptions","includeOffset","pointRadius","pointHitRadius","calculatePointY","pointStyle","dsMeta","sumPos","sumNeg","stackedRightValue","getRightValue","rightValue","capControlPoint","pt","controlPoints","area","filter","splineCurveMonotone","splineCurve","previousItem","nextItem","controlPointPreviousX","previous","controlPointPreviousY","controlPointNextX","controlPointNextY","capBezierPoints","canvasHelpers","pointHoverRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","919","polarArea","angleLines","display","circular","pointLabels","beginAtZero","count","countVisibleElements","xCenter","yCenter","visibleCount","datasetStartAngle","distance","getDistanceFromCenterForValue","resetRadius","920","radar","_loop","pointPosition","getPointPositionForValue","921","global","duration","easing","onProgress","onComplete","Animation","Element","currentStep","numSteps","onAnimationProgress","onAnimationComplete","animationService","frameDuration","animations","dropFrames","request","addAnimation","lazy","animating","requestAnimationFrame","cancelAnimation","findIndex","splice","requestAnimFrame","startDigest","startTime","Date","now","framesToDrop","advance","endTime","callback","922","drawPoint","edgeLength","xOffset","yOffset","drawImage","beginPath","closePath","sqrt","moveTo","lineTo","SQRT2","fillRect","strokeRect","leftX","topY","sideSize","drawRoundedRectangle","stroke","save","rect","clip","restore","flip","bezierCurveTo","923","initConfig","configMerge","updateConfig","newOptions","scaleOptions","tooltip","_options","positionIsHorizontal","platform","types","instances","construct","item","acquireContext","uid","_bufferedRender","notify","retinaScale","bindEvents","responsive","resize","ensureScalesHaveIDs","buildScales","initToolTip","clear","stop","silent","maintainAspectRatio","newWidth","getMaximumWidth","newHeight","getMaximumHeight","style","newSize","onResize","responsiveAnimationDuration","scalesOptions","xAxisOptions","yAxisOptions","items","dtype","dposition","isDefault","scaleType","scaleClass","scaleService","getScaleConstructor","addScalesToLayout","buildOrUpdateControllers","newControllers","updateIndex","ControllerClass","Error","resetElements","animationDuration","_data","buildOrUpdateElements","updateLayout","updateDatasets","_bufferedRequest","layoutService","updateDataset","animationOptions","animationObject","easingFunction","easingEffects","stepDecimal","easingValue","transition","boxes","box","drawDatasets","drawDataset","getElementAtEvent","Interaction","modes","single","getElementsAtEvent","getElementsAtXAxis","getElementsAtEventForMode","method","getDatasetAtEvent","_meta","generateLegend","unbindEvents","releaseContext","toBase64Image","toDataURL","Tooltip","_chartInstance","listeners","_listeners","listener","eventHandler","events","addEventListener","removeEventListener","updateHoverStyle","enabled","changed","handleEvent","bufferedRequest","hoverOptions","lastActive","active","onHover","native","arrayEquals","Controller","924","listenArrayEvents","array","_chartjs","arrayEvents","toUpperCase","res","unlistenArrayEvents","stub","addElements","scaleID","createMetaDataset","createMetaData","metaData","addElementAndReset","resyncElements","elementOpts","valueOrDefault","numMeta","numData","insertElements","onDataPush","onDataPop","pop","onDataShift","shift","onDataSplice","onDataUnshift","inherits","925","color","interpolate","view","ease","actual","origin","c0","c1","isFinite","configuration","_view","tooltipPosition","hasValue","isNumber","926","parseMaxStyle","styleValue","node","parentProperty","valueInPixels","parseInt","parentNode","isConstrainedValue","getConstraintDimension","domNode","maxStyle","percentageProperty","document","defaultView","constrainedNode","getComputedStyle","constrainedContainer","hasCNode","hasCContainer","infinity","POSITIVE_INFINITY","loopable","self","reverse","len","objClone","setFn","_base","extension","baseHasProperty","baseVal","scaleMerge","getScaleDefaults","valueObj","axisType","axisDefaults","defaultValue","where","collection","filterCallback","filtered","scope","findNextWhere","arrayToSearch","startIndex","currentItem","findPreviousWhere","extensions","ChartElement","Surrogate","__super__","parseFloat","almostEquals","epsilon","almostWhole","reduce","NEGATIVE_INFINITY","sign","log10","LN10","toRadians","toDegrees","radians","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distanceBetweenPoints","pt1","pt2","aliasPixel","pixelWidth","firstPoint","middlePoint","afterPoint","t","d01","d12","s01","s12","fa","fb","EPSILON","pointBefore","pointCurrent","pointAfter","pointsWithTangents","deltaK","mK","pointsLen","slopeDeltaX","alphaK","betaK","tauK","squaredMagnitude","deltaX","loop","niceNum","exponent","fraction","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","asin","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","getRelativePosition","evt","mouseX","mouseY","originalEvent","currentTarget","srcElement","boundingRect","getBoundingClientRect","touches","clientX","clientY","paddingLeft","getStyle","paddingTop","paddingRight","paddingBottom","currentDevicePixelRatio","addEvent","eventType","attachEvent","removeEvent","handler","detachEvent","getConstraintWidth","getConstraintHeight","container","clientWidth","cw","h","clientHeight","ch","el","currentStyle","getPropertyValue","pixelRatio","devicePixelRatio","clearRect","fontString","pixelSize","fontStyle","fontFamily","longestText","font","arrayOfThings","cache","gc","garbageCollect","longest","thing","measureText","nestedThing","gcLen","textWidth","numberOfLabelLines","numberOfLines","quadraticCurveTo","CanvasGradient","defaultColor","a0","a1","v0","v1","thisArg","colorValue","CanvasPattern","callCallback","927","parseVisibleItems","jlen","getIntersectItems","inRange","getNearestItems","distanceMetric","minDistance","nearestItems","getCenterPoint","indexMode","x-axis","nearest","b","sizeA","getArea","sizeB","ret","intersectsItem","inXRange","inYRange","928","defaultFontColor","defaultFontFamily","defaultFontSize","defaultFontStyle","929","filterByPosition","sortByWeight","_tmpIndex_","addBox","fullWidth","removeBox","layoutItem","configure","getMinimumBoxSize","chartWidth","maxChartAreaWidth","horizontalBoxHeight","maxChartAreaHeight","verticalBoxWidth","chartAreaHeight","minBoxSizes","fitBox","minBoxSize","minBox","scaleMargin","totalLeftBoxesWidth","maxHorizontalLeftPadding","totalRightBoxesWidth","maxHorizontalRightPadding","chartHeight","finalFitVerticalBox","totalTopBoxesHeight","totalBottomBoxesHeight","placeBox","leftPadding","rightPadding","layoutOptions","layout","padding","topPadding","bottomPadding","leftBoxes","rightBoxes","topBoxes","bottomBoxes","chartAreaBoxes","chartAreaWidth","maxVerticalTopPadding","maxVerticalBottomPadding","horizontalBox","getPadding","boxPadding","verticalBox","leftPaddingAddition","topPaddingAddition","newMaxChartAreaHeight","newMaxChartAreaWidth","930","_plugins","_cacheId","plugin","unregister","idx","getAll","hook","descriptors","pluginService","PluginBase","931","computeTextSize","tick","parseFontOptions","globalDefaults","fontSize","family","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","scaleLabel","labelString","minRotation","maxRotation","mirror","autoSkip","autoSkipPadding","labelOffset","Ticks","formatters","Scale","beforeUpdate","maxWidth","maxHeight","margins","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","tickOpts","userCallback","tickFont","labelRotation","cosRotation","originalLabelWidth","labelWidth","tickWidth","getPixelForTick","angleRadians","scaleLabelOpts","gridLineOpts","scaleLabelFontSize","isFullWidth","largestTextWidth","tallestLabelHeightInLines","lineSpace","longestLabelWidth","sinRotation","labelHeight","firstTick","firstLabelWidth","lastTick","lastLabelWidth","handleMargins","rawValue","getLabelForIndex","getValueForPixel","innerWidth","pixel","finalVal","innerHeight","decimal","valueOffset","getBaseValue","skipRatio","maxTicks","optionTicks","isRotated","useAutoskipper","maxTicksLimit","tickFontColor","fontColor","tl","scaleLabelFontColor","scaleLabelFont","labelRotationRadians","longestRotatedLabel","itemsToDraw","xTickStart","xTickEnd","yTickStart","yTickEnd","isLastTick","lineColor","zeroLineIndex","tx1","ty1","tx2","ty2","x1","y1","x2","y2","labelX","labelY","textAlign","textBaseline","xLineValue","labelXOffset","isLeft","tickPadding","yLineValue","glWidth","glColor","glBorderDash","glBorderDashOffset","itemToDraw","setLineDash","lineDashOffset","translate","fillText","scaleLabelX","scaleLabelY","932","constructors","registerScaleType","scaleConstructor","updateScaleDefaults","additions","933","generators","generationOptions","dataRange","spacing","stepSize","niceRange","niceMin","niceMax","numSpaces","logarithmic","exp","significand","tickVal","endExp","endSignificand","minNotZero","tickValue","delta","logDelta","tickString","numDecimal","toFixed","remain","toExponential","934","mergeOpacity","colorString","opacity","pushOrConcat","toPush","createTooltipItem","getBaseModel","tooltipOpts","xPadding","yPadding","xAlign","yAlign","bodyFontColor","_bodyFontFamily","bodyFontFamily","_bodyFontStyle","bodyFontStyle","_bodyAlign","bodyAlign","bodyFontSize","bodySpacing","titleFontColor","_titleFontFamily","titleFontFamily","_titleFontStyle","titleFontStyle","titleFontSize","_titleAlign","titleAlign","titleSpacing","titleMarginBottom","footerFontColor","_footerFontFamily","footerFontFamily","_footerFontStyle","footerFontStyle","footerFontSize","_footerAlign","footerAlign","footerSpacing","footerMarginTop","caretSize","cornerRadius","legendColorBackground","multiKeyBackground","displayColors","getTooltipSize","body","combinedBodyLength","bodyItem","before","lines","after","beforeBody","afterBody","titleLineCount","footerLineCount","footer","widthPadding","maxLineWidth","determineAlignment","lf","rf","olf","orf","yf","midX","midY","getBackgroundPoint","vm","alignment","caretPadding","paddingAndSize","radiusAndPadding","beforeTitle","labelCount","afterTitle","beforeLabel","labelColor","activeElement","afterLabel","beforeFooter","afterFooter","getTitle","getBeforeBody","getBody","bodyItems","getAfterBody","getFooter","existingModel","_active","backgroundPoint","tooltipSize","caretX","caretY","labelColors","positioners","_eventPosition","itemSort","dataPoints","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","tmp","drawTitle","drawBody","textColor","xLinePadding","fillLineOfText","drawColorBoxes","drawFooter","drawBackground","hasTooltipContent","_lastActive","average","pos","eventPosition","nearestElement","tp","935","globalOpts","inLabelRange","chartX","chartY","pointRelativePosition","betweenAngles","withinRadius","halfAngle","halfRadius","centreAngle","rangeFromCentre","sA","eA","lineJoin","936","currentVM","globalOptionLineElements","lastDrawnIndex","lineCap","937","xRange","yRange","938","isVertical","getBarBounds","halfWidth","halfHeight","cornerAt","corners","startCorner","signX","signY","halfStroke","borderLeft","borderRight","borderTop","borderBottom","borders","corner","bounds","939","readUsedSize","matches","initCanvas","renderHeight","getAttribute","renderWidth","initial","displayWidth","displayHeight","createEvent","nativeEvent","fromNativeEvent","event","eventTypeMap","createResizer","iframe","createElement","className","cssText","tabIndex","contentWindow","addResizeListener","ticking","resizer","insertBefore","firstChild","removeResizeListener","removeChild","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","getElementById","getContext","removeAttribute","setAttribute","proxies","proxy","940","implementation","941","decodeFill","computeBoundary","scaleBottom","scaleTop","scaleZero","getBasePosition","resolveTarget","propagate","visited","visible","createMapper","mappers","isDrawable","drawArea","curve0","curve1","len0","len1","doFill","mapper","p0","p1","d0","d1","span","filler","boundary","afterDatasetsUpdate","$filler","beforeDatasetDraw","942","getBoxWidth","labelOpts","usePointStyle","boxWidth","createNewLegendAndAttach","legendOpts","Legend","ci","lineDash","legendHitBoxes","doughnutMode","beforeBuildLabels","buildLabels","afterBuildLabels","legendItems","globalDefault","itemOrDefault","labelFont","hitboxes","lineWidths","totalHeight","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","lineDefault","legendWidth","drawLegendBox","isLineWidthZero","offSet","lh","hitBox","beforeInit","afterEvent","943","createNewTitleBlockAndAttach","titleOpts","Title","titleBlock","titleX","titleY","titleFont","944","DatasetScale","getLabels","xLabels","yLabels","minIndex","maxIndex","valueCategory","offsetAmt","valueWidth","widthOffset","valueHeight","heightOffset","horz","valueDimension","945","LinearScale","LinearScaleBase","IDMatches","hasStacks","valuesPerStack","positiveValues","negativeValues","relativePoints","valuesForType","minVal","maxVal","handleTickRangeOptions","getTickLimit","tickFontSize","handleDirectionalChanges","innerDimension","ticksAsNumbers","946","minSign","maxSign","suggestedMin","suggestedMax","numericGeneratorOptions","fixedStepSize","947","LogarithmicScale","tickValues","newVal","948","getValueCount","getPointLabelFontOptions","pointLabelOptions","measureLabelSize","determineLimits","fitWithPointLabels","textSize","plFont","largestPossibleRadius","furthestLimits","furthestAngles","_pointLabelSizes","valueCount","getPointPosition","getIndexAngle","hLimits","vLimits","setReductions","drawingArea","setCenterPoint","getTextAlignForAngle","adjustPointPositionForLabelHeight","drawPointLabels","angleLineOpts","pointLabelOpts","outerDistance","outerPosition","pointLabelPosition","pointLabelFontColor","drawRadiusLine","numberOrZero","param","animate","showLabelBackdrop","backdropColor","backdropPaddingY","backdropPaddingX","LinearRadialScale","radiusReductionLeft","radiusReductionRight","radiusReductionTop","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","scalingFactor","distanceFromCenter","thisAngle","tickFontStyle","tickFontFamily","tickLabelFont","yCenterOffset","yHeight","949","parseTime","axis","timeOpts","time","parser","getMonth","warn","determineUnit","minUnit","units","numUnits","unitDetails","steps","maxStep","determineStepSize","unitDefinition","unitSizeInMilliSeconds","sizeInUnits","multiplier","generateTicks","cur","realMax","millisecond","displayFormat","isoWeekday","displayFormats","TimeScale","timestamp","dataMin","MAX_SAFE_INTEGER","dataMax","MIN_SAFE_INTEGER","chartData","parsedData","labelMoment","timestamps","dataIndex","dataMoment","_parsedData","minTimestamp","maxTimestamp","minMoment","getLabelCapacity","tooltipFormat","tickFormatFunction","formattedTick","ticksAsTimestamps","getPixelForOffset","epochWidth","getLabelWidth","tickLabelWidth","exampleTime","exampleLabel","950","colorNames","getRgb","getHsl","hsla","getAlpha","hexDouble","percentaString","reverseNames","num","951","rgb2hsl","g","rgb2hsv","rgb2hwb","rgb2cmyk","k","rgb2keyword","reverseKeywords","JSON","stringify","rgb2xyz","rgb2lab","xyz","z","rgb2lch","lab2lch","hsl2rgb","t1","t2","t3","hsl2hsv","sv","hsl2hwb","hsl2cmyk","hsl2keyword","hsv2rgb","hi","f","q","hsv2hsl","sl","hsv2hwb","hsv2cmyk","hsv2keyword","hwb2rgb","wh","bl","hwb2hsl","hwb2hsv","hwb2cmyk","hwb2keyword","cmyk2rgb","cmyk2hsl","cmyk2hsv","cmyk2hwb","cmyk2keyword","xyz2rgb","xyz2lab","xyz2lch","lab2xyz","lab","hr","lab2rgb","lch2lab","lch","lch2xyz","lch2rgb","keyword2rgb","cssKeywords","keyword2hsl","keyword2hsv","keyword2hwb","keyword2cmyk","keyword2lab","keyword2xyz","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellowgreen","952","conversions","Converter","func","arg","pair","exec","from","to","convs","routeSpace","fspace","953","964","defaultBar","cleanInsightsByWeek","cleanInsightsByCategory","cleanInsightsByStatus"],"mappings":"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","file":"static/js/6.c985f554f2d43f76e5d2.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ 1080:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuex__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_main_header_vue__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_main_header_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__components_main_header_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_card_placeholder_vue__ = __webpack_require__(361);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_card_placeholder_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__components_card_placeholder_vue__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_chart_js__ = __webpack_require__(907);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_chart_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_chart_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__ = __webpack_require__(964);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_moment__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment_range__ = __webpack_require__(865);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_moment_range___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_moment_range__);\n\n\n\n\n\n\n\n\n\n\n\nvar moment = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_moment_range__[\"extendMoment\"])(__WEBPACK_IMPORTED_MODULE_5_moment___default.a);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    name: 'company-calendar-insight',\n    components: {\n        mainHeader: __WEBPACK_IMPORTED_MODULE_1__components_main_header_vue___default.a,\n        cardPlaceholder: __WEBPACK_IMPORTED_MODULE_2__components_card_placeholder_vue___default.a\n    },\n    data: function data() {\n        return {\n            current_month: moment(),\n            currentValueReceived: 0,\n            statusCount: {\n                confirmed: 0, pending: 0, canceled: 0, expired: 0\n            },\n            invoices: [],\n            categories: [],\n            interactions: {\n                professionalsCardsOpened: [],\n                chartByStatus: true,\n                chartByWeek: true,\n                chartByCategory: true\n            },\n            placeholder: {\n                invoices: true\n            },\n            insights: {\n                by_status: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"a\" /* cleanInsightsByStatus */])(),\n                by_week: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"b\" /* cleanInsightsByWeek */])(),\n                by_category: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"c\" /* cleanInsightsByCategory */])()\n            }\n        };\n    },\n    mounted: function mounted() {\n        this.getInvoices();\n    },\n\n\n    methods: {\n        isExpired: function isExpired(date) {\n            return moment(date, 'DD/MM/YYYY').diff(moment(), 'days');\n        },\n        resetData: function resetData() {\n\n            this.interactions.chartByStatus = true;\n            this.interactions.chartByWeek = true;\n            this.interactions.chartByCategory = true;\n\n            this.currentValueReceived = 0;\n            this.statusCount.confirmed = 0;\n            this.statusCountpending = 0;\n            this.statusCountcanceled = 0;\n            this.statusCountexpired = 0;\n\n            this.insights.by_week = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"b\" /* cleanInsightsByWeek */])();\n            this.insights.by_status = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"a\" /* cleanInsightsByStatus */])();\n            this.insights.by_category = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"c\" /* cleanInsightsByCategory */])();\n        },\n        dataByCategory: function dataByCategory() {\n            var that = this;\n\n            var categoriesNames = _.flatten(that.categories.map(function (category) {\n                return category.name;\n            })).sort();\n            var categoriesSlug = _.flatten(that.categories.map(function (category) {\n                return category.slug;\n            })).sort();\n\n            that.insights.by_category.labels = _.uniq(categoriesNames);\n\n            categoriesSlug = _.uniq(categoriesSlug);\n\n            that.insights.by_category.labels.forEach(function (label, indexCategories) {\n                var currentColor = categoriesSlug[indexCategories].colorByCategory();\n                that.insights.by_category.datasets[0].backgroundColor.push(currentColor.hex);\n                that.insights.by_category.datasets[0].borderColor.push(currentColor.rgba);\n            });\n\n            var values = new Array(that.insights.by_category.labels.length);\n            for (var i = 0; i < values.length; i++) {\n                values[i] = 0;\n            }\n\n            that.insights.by_category.labels.forEach(function (label, labelIndex) {\n                that.invoices.forEach(function (invoice) {\n                    if (label === invoice.subscription.plan.category.name) {\n                        values[labelIndex] += invoice.value;\n                    }\n                });\n            });\n            that.insights.by_category.datasets[0].data = values;\n        },\n        countStatus: function countStatus() {\n            var that = this;\n            that.statusCount = { confirmed: 0, pending: 0, canceled: 0, expired: 0 };\n            that.invoices.map(function (invoice) {\n                var is_expired = that.isExpired(invoice.expire_at);\n\n                if (invoice.is_confirmed) {\n                    that.statusCount.confirmed += invoice.value;\n                }\n\n                if (invoice.is_canceled) {\n                    that.statusCount.canceled += invoice.value;\n                }\n\n                if (!invoice.is_confirmed && !invoice.is_canceled && is_expired > -1) {\n                    that.statusCount.pending += invoice.value;\n                }\n\n                if (!invoice.is_confirmed && !invoice.is_canceled && is_expired < -1) {\n                    that.statusCount.expired += invoice.value;\n                }\n            });\n        },\n        dataByWeek: function dataByWeek() {\n            var that = this;\n\n            that.insights.by_week.labels.forEach(function (label, indexDataSet) {\n                that.invoices.forEach(function (invoice) {\n\n                    var currentDate = 'Semana: ' + Math.ceil(moment(invoice.expire_at, 'DD/MM/YYYY').date() / 7);\n                    var is_expired = that.isExpired(invoice.expire_at);\n\n                    if (currentDate === that.insights.by_week.labels[indexDataSet]) {\n                        if (invoice.is_confirmed) {\n                            that.insights.by_week.datasets[0].data[indexDataSet] += invoice.value;\n                        }\n\n                        if (!invoice.is_confirmed && !invoice.is_canceled && is_expired > -1) {\n                            that.insights.by_week.datasets[1].data[indexDataSet] += invoice.value;\n                        }\n\n                        if (invoice.is_canceled) {\n                            that.insights.by_week.datasets[2].data[indexDataSet] += invoice.value;\n                        }\n\n                        if (!invoice.is_confirmed && !invoice.is_canceled && is_expired < -1) {\n                            that.insights.by_week.datasets[3].data[indexDataSet] += invoice.value;\n                        }\n                    }\n                });\n            });\n        },\n        dataByStatus: function dataByStatus() {\n            var that = this;\n\n            that.countStatus();\n            that.insights.by_status.datasets[0].data = _.values(that.statusCount);\n        },\n        handleChartType: function handleChartType(type) {\n            var that = this;\n\n            if (type === 'by_category') {\n\n                if (that.chartByCategory) that.chartByCategory.destroy();\n\n                that.interactions.chartByCategory = !that.interactions.chartByCategory;\n\n                if (that.interactions.chartByCategory) {\n                    setTimeout(function () {\n                        that.chartByCategory = new __WEBPACK_IMPORTED_MODULE_3_chart_js___default.a(that.$refs.chartByCategory, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"d\" /* pie */])(that.insights.by_category));\n                    }, 200);\n                }\n            }\n\n            if (type === 'by_week') {\n\n                if (that.chartByWeek) that.chartByWeek.destroy();\n\n                that.interactions.chartByWeek = !that.interactions.chartByWeek;\n\n                if (that.interactions.chartByWeek) {\n                    setTimeout(function () {\n                        that.chartByWeek = new __WEBPACK_IMPORTED_MODULE_3_chart_js___default.a(that.$refs.chartByWeek, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"e\" /* defaultBar */])(that.insights.by_week));\n                    }, 200);\n                }\n            }\n\n            if (type === 'by_status') {\n\n                if (that.chartByStatus) that.chartByStatus.destroy();\n\n                that.interactions.chartByStatus = !that.interactions.chartByStatus;\n\n                if (that.interactions.chartByStatus) {\n                    setTimeout(function () {\n                        that.chartByStatus = new __WEBPACK_IMPORTED_MODULE_3_chart_js___default.a(that.$refs.chartByStatus, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__models_ChartOptions__[\"f\" /* horizontalBar */])(that.insights.by_status));\n                    }, 200);\n                }\n            }\n        },\n        getInvoices: function getInvoices() {\n            var that = this;\n\n            var data = {\n                company_id: that.$route.params.company_id,\n                search: '',\n                init: moment(that.current_month).startOf('month').format('YYYY-MM-DD'),\n                end: moment(that.current_month).endOf('month').format('YYYY-MM-DD')\n            };\n\n            that.categories = [];\n            that.invoices = [];\n            that.resetData();\n\n            that.$http.post('professional/company/invoice/list', data).then(function (response) {\n                that.invoices = response.data.invoices;\n                that.invoices.map(function (invoice) {\n                    that.categories.push(invoice.subscription.plan.category);\n                    if (invoice.is_confirmed) {\n                        that.currentValueReceived += invoice.value;\n                    }\n                });\n                that.dataByCategory();\n                that.dataByWeek();\n                that.dataByStatus();\n\n                if (!window.cordova) {\n                    that.handleChartType('by_status');\n                    that.handleChartType('by_week');\n                    that.handleChartType('by_category');\n                }\n            }).catch(function (error) {\n                console.log(error);\n                that.placeholder = false;\n            });\n        },\n        handlePrevMonth: function handlePrevMonth() {\n            this.current_month.subtract(1, 'month');\n            this.getInvoices();\n        },\n        handleNextMonth: function handleNextMonth() {\n            this.current_month.add(1, 'month');\n            this.getInvoices();\n        }\n    }\n});\n\n/***/ }),\n\n/***/ 1204:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(859)();\n// imports\n\n\n// module\nexports.push([module.i, \".row.insight-row[data-v-831fff60]{margin:0 -5px}.row.insight-row .insight-col[data-v-831fff60]{padding:0 5px}.canvas-default[data-v-831fff60]{max-width:100%;min-height:0}\", \"\", {\"version\":3,\"sources\":[\"/Users/igortrindade/Code/goup-front/src/modules/professional/company/components/invoices/insights.vue\"],\"names\":[],\"mappings\":\"AACA,kCAAoC,aAAe,CAClD,AACD,+CAAiD,aAAe,CAC/D,AAGD,iCACI,eAAgB,AAChB,YAAgB,CACnB\",\"file\":\"insights.vue\",\"sourcesContent\":[\"\\n.row.insight-row[data-v-831fff60] { margin: 0 -5px;\\n}\\n.row.insight-row .insight-col[data-v-831fff60] { padding: 0 5px;\\n}\\n\\n/* canvas */\\n.canvas-default[data-v-831fff60] {\\n    max-width: 100%;\\n    min-height: 0px;\\n}\\n\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 1302:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(1204);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(860)(\"6f8c0541\", content, true);\n\n/***/ }),\n\n/***/ 1486:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"first-container\"\n  }, [_c('main-header', {\n    attrs: {\n      \"type\": 'center',\n      \"title\": 'Insights',\n      \"cursor\": false,\n      \"action\": function() {\n        return false\n      },\n      \"hasback\": true\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"container\"\n  }, [_c('h2', {\n    staticClass: \"f-300 text-center m-b-30\"\n  }, [_vm._v(\"Faturas\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"text-center row m-t-30 insight-row\"\n  }, [_c('div', {\n    staticClass: \"col-md-4 col-xs-3 insight-col text-left\"\n  }, [_c('button', {\n    staticClass: \"btn btn-info p-5 p-l-10 p-r-10 btn-block\",\n    on: {\n      \"click\": function($event) {\n        _vm.handlePrevMonth()\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-ios-arrow-back\"\n  })])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-md-4 col-xs-6 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn btn-info p-5 p-l-10 p-r-10 btn-block\"\n  }, [_vm._v(_vm._s(_vm.current_month.format('MMMM')) + \" / \" + _vm._s(_vm.current_month.format('YYYY')))])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-md-4 col-xs-3 insight-col text-right\"\n  }, [_c('button', {\n    staticClass: \"btn btn-info p-5 p-l-10 p-r-10 btn-block\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleNextMonth()\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-ios-arrow-forward\"\n  })])])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"container m-t-30\"\n  }, [(_vm.currentValueReceived) ? _c('div', {\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-header ch-alt text-center\"\n  }, [_c('h4', {\n    staticClass: \"f-300 m-0 m-b-10\"\n  }, [_vm._v(\"Valor recebido em \" + _vm._s(_vm.current_month.format('MMMM')))]), _vm._v(\" \"), _c('span', {\n    staticClass: \"label label-success p-5 p-l-10 p-r-10 f-14\"\n  }, [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.currentValueReceived)))])])]) : _vm._e(), _vm._v(\" \"), _c('div', {\n    staticClass: \"row insight-row\"\n  }, _vm._l((_vm.invoices), function(invoice) {\n    return _c('div', {\n      staticClass: \"col-sm-2 col-xs-6 insight-col\"\n    }, [_c('div', {\n      staticClass: \"card\"\n    }, [_c('div', {\n      staticClass: \"card-header ch-alt text-center p-5\"\n    }, [_c('h4', {\n      staticClass: \"f-300 t-overflow m-t-10 m-b-10\"\n    }, [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(invoice.value)))]), _vm._v(\" \"), _c('p', [_vm._v(_vm._s(invoice.subscription.plan.category.name))]), _vm._v(\" \"), (invoice.is_confirmed) ? _c('span', {\n      staticClass: \"label label-success p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Confirmada\")]) : _vm._e(), _vm._v(\" \"), (invoice.is_canceled) ? _c('span', {\n      staticClass: \"label label-warning p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Cancelada\")]) : _vm._e(), _vm._v(\" \"), (!invoice.is_confirmed && !invoice.is_canceled && _vm.isExpired(invoice.expire_at) > -1) ? _c('span', {\n      staticClass: \"label label-default p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Aguardando\")]) : _vm._e(), _vm._v(\" \"), (!invoice.is_confirmed && !invoice.is_canceled && _vm.isExpired(invoice.expire_at) < -1) ? _c('span', {\n      staticClass: \"label label-danger p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Atrasada\")]) : _vm._e(), _vm._v(\" \"), _c('hr'), _vm._v(\" \"), _c('small', {\n      staticClass: \"f-300\"\n    }, [_vm._v(\"vencimento em:\\n                            \" + _vm._s(invoice.expire_at) + \"\\n                        \")])])])])\n  }))]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.invoices.length),\n      expression: \"!invoices.length\"\n    }],\n    staticClass: \"container\"\n  }, [_c('div', {\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body\"\n  }, [_c('p', {\n    staticClass: \"f-300 f-danger text-center m-t-10\"\n  }, [_vm._v(\"\\n                    Não foi possível localizar nenhuma fatura no mês de\\n                    \"), _c('strong', [_vm._v(_vm._s(_vm.current_month.format('MMMM')) + \" de \" + _vm._s(_vm.current_month.format('YYYY')))]), _vm._v(\".\\n                \")])])])]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.invoices.length),\n      expression: \"invoices.length\"\n    }],\n    staticClass: \"container\"\n  }, [_c('div', {\n    staticClass: \"row insight-row\"\n  }, [_c('div', {\n    staticClass: \"col-sm-12 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn f-18 btn-light btn-block f-300 m-b-10\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleChartType('by_status')\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-checkmark-round f-22 m-r-5\"\n  }), _vm._v(\"\\n                    Gráfico por status\\n                \")]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.interactions.chartByStatus),\n      expression: \"interactions.chartByStatus\"\n    }],\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body p-l-5 p-r-5 text-center\"\n  }, [_c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.invoices.length),\n      expression: \"invoices.length\"\n    }],\n    staticClass: \"text-center m-t-5 m-b-30\"\n  }, [_c('div', {\n    staticClass: \"row insight-row\"\n  }, [_c('div', {\n    staticClass: \"col-xs-6 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-success p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Confirmado\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.confirmed)))])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-xs-6 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-default p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Pendente\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.pending)))])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-xs-6 m-t-10 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-warning p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Cancelado\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.canceled)))])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-xs-6 m-t-10 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-danger p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Atrasado\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.expired)))])])])])]), _vm._v(\" \"), _c('canvas', {\n    ref: \"chartByStatus\",\n    staticClass: \"canvas-default\"\n  })])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-sm-6 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn f-18 btn-light btn-block f-300 m-b-10\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleChartType('by_week')\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-stats-bars f-22 m-r-5\"\n  }), _vm._v(\"\\n                    Gráfico por semana\\n                \")]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.interactions.chartByWeek),\n      expression: \"interactions.chartByWeek\"\n    }],\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body text-center\"\n  }, [_c('canvas', {\n    ref: \"chartByWeek\",\n    staticClass: \"canvas-default\"\n  })])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-sm-6 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn f-18 btn-light btn-block f-300 m-b-10\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleChartType('by_category')\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-ios-pie-outline f-22 m-r-5\"\n  }), _vm._v(\"\\n                    Gráfico de categorias\\n                \")]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.interactions.chartByCategory),\n      expression: \"interactions.chartByCategory\"\n    }],\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body text-center\"\n  }, [_c('canvas', {\n    ref: \"chartByCategory\",\n    staticClass: \"canvas-default\"\n  })])])])])])], 1)\n},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 422:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/* styles */\n__webpack_require__(1302)\n\nvar Component = __webpack_require__(2)(\n  /* script */\n  __webpack_require__(1080),\n  /* template */\n  __webpack_require__(1486),\n  /* scopeId */\n  \"data-v-831fff60\",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 865:\n/***/ (function(module, exports, __webpack_require__) {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(0));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"moment-range\", [\"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moment-range\"] = factory(require(\"moment\"));\n\telse\n\t\troot[\"moment-range\"] = factory(root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 19);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(15)() ? Symbol : __webpack_require__(17);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar assign        = __webpack_require__(3)\n  , normalizeOpts = __webpack_require__(10)\n  , isCallable    = __webpack_require__(6)\n  , contains      = __webpack_require__(12)\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(4)()\n\t? Object.assign\n\t: __webpack_require__(5);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== 'function') return false;\n\tobj = { foo: 'raz' };\n\tassign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n\treturn (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar keys  = __webpack_require__(7)\n  , value = __webpack_require__(11)\n\n  , max = Math.max;\n\nmodule.exports = function (dest, src/*, …srcn*/) {\n\tvar error, i, l = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry { dest[key] = src[key]; } catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < l; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Deprecated\n\n\n\nmodule.exports = function (obj) { return typeof obj === 'function'; };\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(8)()\n\t? Object.keys\n\t: __webpack_require__(9);\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys('primitive');\n\t\treturn true;\n\t} catch (e) { return false; }\n};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n\treturn keys(object == null ? object : Object(object));\n};\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\nmodule.exports = function (options/*, …options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (options == null) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (value) {\n\tif (value == null) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(13)()\n\t? String.prototype.contains\n\t: __webpack_require__(14);\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar str = 'razdwatrzy';\n\nmodule.exports = function () {\n\tif (typeof str.contains !== 'function') return false;\n\treturn ((str.contains('dwa') === true) && (str.contains('foo') === false));\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar symbol;\n\tif (typeof Symbol !== 'function') return false;\n\tsymbol = Symbol('test symbol');\n\ttry { String(symbol); } catch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (x) {\n\tif (!x) return false;\n\tif (typeof x === 'symbol') return true;\n\tif (!x.constructor) return false;\n\tif (x.constructor.name !== 'Symbol') return false;\n\treturn (x[x.constructor.toStringTag] === 'Symbol');\n};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// ES2015 Symbol polyfill for environments that do not support it (or partially support it)\n\n\n\nvar d              = __webpack_require__(2)\n  , validateSymbol = __webpack_require__(18)\n\n  , create = Object.create, defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty, objPrototype = Object.prototype\n  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)\n  , isNativeSafe;\n\nif (typeof Symbol === 'function') {\n\tNativeSymbol = Symbol;\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n}\n\nvar generateName = (function () {\n\tvar created = create(null);\n\treturn function (desc) {\n\t\tvar postfix = 0, name, ie11BugWorkaround;\n\t\twhile (created[desc + (postfix || '')]) ++postfix;\n\t\tdesc += (postfix || '');\n\t\tcreated[desc] = true;\n\t\tname = '@@' + desc;\n\t\tdefineProperty(objPrototype, name, d.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t}));\n\t\treturn name;\n\t};\n}());\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = (description === undefined ? '' : String(description));\n\treturn defineProperties(symbol, {\n\t\t__description__: d('', description),\n\t\t__name__: d('', generateName(description))\n\t});\n};\ndefineProperties(SymbolPolyfill, {\n\tfor: d(function (key) {\n\t\tif (globalSymbols[key]) return globalSymbols[key];\n\t\treturn (globalSymbols[key] = SymbolPolyfill(String(key)));\n\t}),\n\tkeyFor: d(function (s) {\n\t\tvar key;\n\t\tvalidateSymbol(s);\n\t\tfor (key in globalSymbols) if (globalSymbols[key] === s) return key;\n\t}),\n\n\t// If there's native implementation of given symbol, let's fallback to it\n\t// to ensure proper interoperability with other native functions e.g. Array.from\n\thasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),\n\tisConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\tSymbolPolyfill('isConcatSpreadable')),\n\titerator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),\n\tmatch: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),\n\treplace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),\n\tsearch: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),\n\tspecies: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),\n\tsplit: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),\n\ttoPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),\n\ttoStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),\n\tunscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))\n});\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d('', function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {\n\tvar symbol = validateSymbol(this);\n\tif (typeof symbol === 'symbol') return symbol;\n\treturn symbol.toString();\n}));\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isSymbol = __webpack_require__(16);\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DateRange = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.extendMoment = extendMoment;\n\nvar _moment = __webpack_require__(1);\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _es6Symbol = __webpack_require__(0);\n\nvar _es6Symbol2 = _interopRequireDefault(_es6Symbol);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nvar INTERVALS = {\n  year: true,\n  quarter: true,\n  month: true,\n  week: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true\n};\n\n//-----------------------------------------------------------------------------\n// Date Ranges\n//-----------------------------------------------------------------------------\n\nvar DateRange = exports.DateRange = function () {\n  function DateRange(start, end) {\n    _classCallCheck(this, DateRange);\n\n    var s = start;\n    var e = end;\n\n    if (arguments.length === 1 || end === undefined) {\n      if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object' && start.length === 2) {\n        var _start = _slicedToArray(start, 2);\n\n        s = _start[0];\n        e = _start[1];\n      } else if (typeof start === 'string') {\n        var _start$split = start.split('/');\n\n        var _start$split2 = _slicedToArray(_start$split, 2);\n\n        s = _start$split2[0];\n        e = _start$split2[1];\n      }\n    }\n\n    this.start = s === null ? (0, _moment2.default)(-8640000000000000) : (0, _moment2.default)(s);\n    this.end = e === null ? (0, _moment2.default)(8640000000000000) : (0, _moment2.default)(e);\n  }\n\n  _createClass(DateRange, [{\n    key: 'adjacent',\n    value: function adjacent(other) {\n      var sameStartEnd = this.start.isSame(other.end);\n      var sameEndStart = this.end.isSame(other.start);\n\n      return sameStartEnd && other.start.valueOf() <= this.start.valueOf() || sameEndStart && other.end.valueOf() >= this.end.valueOf();\n    }\n  }, {\n    key: 'add',\n    value: function add(other) {\n      if (this.overlaps(other)) {\n        return new this.constructor(_moment2.default.min(this.start, other.start), _moment2.default.max(this.end, other.end));\n      }\n\n      return null;\n    }\n  }, {\n    key: 'by',\n    value: function by(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        var exclusive = options.exclusive || false;\n        var step = options.step || 1;\n        var diff = Math.abs(range.start.diff(range.end, interval)) / step;\n        var iteration = 0;\n\n        return {\n          next: function next() {\n            var current = range.start.clone().add(iteration * step, interval);\n            var done = exclusive ? !(iteration < diff) : !(iteration <= diff);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'byRange',\n    value: function byRange(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n      var step = options.step || 1;\n      var diff = this.valueOf() / interval.valueOf() / step;\n      var exclusive = options.exclusive || false;\n      var unit = Math.floor(diff);\n      var iteration = 0;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        if (unit === Infinity) {\n          return { done: true };\n        }\n\n        return {\n          next: function next() {\n            var current = (0, _moment2.default)(range.start.valueOf() + interval.valueOf() * iteration * step);\n            var done = unit === diff && exclusive ? !(iteration < unit) : !(iteration <= unit);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'center',\n    value: function center() {\n      var center = this.start.valueOf() + this.diff() / 2;\n\n      return (0, _moment2.default)(center);\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return new this.constructor(this.start, this.end);\n    }\n  }, {\n    key: 'contains',\n    value: function contains(other) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false };\n\n      var start = this.start.valueOf();\n      var end = this.end.valueOf();\n      var oStart = other.valueOf();\n      var oEnd = other.valueOf();\n\n      if (other instanceof DateRange) {\n        oStart = other.start.valueOf();\n        oEnd = other.end.valueOf();\n      }\n\n      var startInRange = start < oStart || start <= oStart && !options.exclusive;\n      var endInRange = end > oEnd || end >= oEnd && !options.exclusive;\n\n      return startInRange && endInRange;\n    }\n  }, {\n    key: 'diff',\n    value: function diff(unit, rounded) {\n      return this.end.diff(this.start, unit, rounded);\n    }\n  }, {\n    key: 'duration',\n    value: function duration(unit, rounded) {\n      return this.diff(unit, rounded);\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect(other) {\n      var start = this.start.valueOf();\n      var end = this.end.valueOf();\n      var oStart = other.start.valueOf();\n      var oEnd = other.end.valueOf();\n\n      if (start <= oStart && oStart < end && end < oEnd) {\n        return new this.constructor(oStart, end);\n      } else if (oStart < start && start < oEnd && oEnd <= end) {\n        return new this.constructor(start, oEnd);\n      } else if (oStart < start && start <= end && end < oEnd) {\n        return this;\n      } else if (start <= oStart && oStart <= oEnd && oEnd <= end) {\n        return other;\n      }\n\n      return null;\n    }\n  }, {\n    key: 'isEqual',\n    value: function isEqual(other) {\n      return this.start.isSame(other.start) && this.end.isSame(other.end);\n    }\n  }, {\n    key: 'isSame',\n    value: function isSame(other) {\n      return this.isEqual(other);\n    }\n  }, {\n    key: 'overlaps',\n    value: function overlaps(other) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { adjacent: false };\n\n      var intersect = this.intersect(other) !== null;\n\n      if (options.adjacent && !intersect) {\n        return this.adjacent(other);\n      }\n\n      return intersect;\n    }\n  }, {\n    key: 'reverseBy',\n    value: function reverseBy(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        var exclusive = options.exclusive || false;\n        var step = options.step || 1;\n        var diff = Math.abs(range.start.diff(range.end, interval)) / step;\n        var iteration = 0;\n\n        return {\n          next: function next() {\n            var current = range.end.clone().subtract(iteration * step, interval);\n            var done = exclusive ? !(iteration < diff) : !(iteration <= diff);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'reverseByRange',\n    value: function reverseByRange(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n      var step = options.step || 1;\n      var diff = this.valueOf() / interval.valueOf() / step;\n      var exclusive = options.exclusive || false;\n      var unit = Math.floor(diff);\n      var iteration = 0;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        if (unit === Infinity) {\n          return { done: true };\n        }\n\n        return {\n          next: function next() {\n            var current = (0, _moment2.default)(range.end.valueOf() - interval.valueOf() * iteration * step);\n            var done = unit === diff && exclusive ? !(iteration < unit) : !(iteration <= unit);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'subtract',\n    value: function subtract(other) {\n      var start = this.start.valueOf();\n      var end = this.end.valueOf();\n      var oStart = other.start.valueOf();\n      var oEnd = other.end.valueOf();\n\n      if (this.intersect(other) === null) {\n        return [this];\n      } else if (oStart <= start && start < end && end <= oEnd) {\n        return [];\n      } else if (oStart <= start && start < oEnd && oEnd < end) {\n        return [new this.constructor(oEnd, end)];\n      } else if (start < oStart && oStart < end && end <= oEnd) {\n        return [new this.constructor(start, oStart)];\n      } else if (start < oStart && oStart < oEnd && oEnd < end) {\n        return [new this.constructor(start, oStart), new this.constructor(oEnd, end)];\n      } else if (start < oStart && oStart < end && oEnd < end) {\n        return [new this.constructor(start, oStart), new this.constructor(oStart, end)];\n      }\n\n      return [];\n    }\n  }, {\n    key: 'toDate',\n    value: function toDate() {\n      return [this.start.toDate(), this.end.toDate()];\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.start.format() + '/' + this.end.format();\n    }\n  }, {\n    key: 'valueOf',\n    value: function valueOf() {\n      return this.end.valueOf() - this.start.valueOf();\n    }\n  }]);\n\n  return DateRange;\n}();\n\n//-----------------------------------------------------------------------------\n// Moment Extensions\n//-----------------------------------------------------------------------------\n\nfunction extendMoment(moment) {\n  /**\n   * Build a date range.\n   */\n  moment.range = function range(start, end) {\n    var m = this;\n\n    if (INTERVALS.hasOwnProperty(start)) {\n      return new DateRange(moment(m).startOf(start), moment(m).endOf(start));\n    }\n\n    return new DateRange(start, end);\n  };\n\n  /**\n   * Alias of static constructor.\n   */\n  moment.fn.range = moment.range;\n\n  /**\n   * Expose constructor\n   */\n  moment.range.constructor = DateRange;\n\n  /**\n   * Check if the current moment is within a given date range.\n   */\n  moment.fn.within = function (range) {\n    return range.contains(this.toDate());\n  };\n\n  return moment;\n}\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=moment-range.js.map\n\n/***/ }),\n\n/***/ 894:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* MIT license */\nvar convert = __webpack_require__(952);\nvar string = __webpack_require__(950);\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = string.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = string.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = string.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn string.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn string.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn string.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn string.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = convert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nmodule.exports = Color;\n\n\n/***/ }),\n\n/***/ 907:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @namespace Chart\n */\nvar Chart = __webpack_require__(928)();\n\n__webpack_require__(926)(Chart);\n__webpack_require__(940)(Chart);\n__webpack_require__(922)(Chart);\n__webpack_require__(925)(Chart);\n__webpack_require__(930)(Chart);\n__webpack_require__(921)(Chart);\n__webpack_require__(923)(Chart);\n__webpack_require__(924)(Chart);\n__webpack_require__(929)(Chart);\n__webpack_require__(932)(Chart);\n__webpack_require__(933)(Chart);\n__webpack_require__(931)(Chart);\n__webpack_require__(927)(Chart);\n__webpack_require__(934)(Chart);\n\n__webpack_require__(935)(Chart);\n__webpack_require__(936)(Chart);\n__webpack_require__(937)(Chart);\n__webpack_require__(938)(Chart);\n\n__webpack_require__(946)(Chart);\n__webpack_require__(944)(Chart);\n__webpack_require__(945)(Chart);\n__webpack_require__(947)(Chart);\n__webpack_require__(948)(Chart);\n__webpack_require__(949)(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\n__webpack_require__(915)(Chart);\n__webpack_require__(916)(Chart);\n__webpack_require__(917)(Chart);\n__webpack_require__(918)(Chart);\n__webpack_require__(919)(Chart);\n__webpack_require__(920)(Chart);\n\n__webpack_require__(908)(Chart);\n__webpack_require__(909)(Chart);\n__webpack_require__(910)(Chart);\n__webpack_require__(911)(Chart);\n__webpack_require__(912)(Chart);\n__webpack_require__(913)(Chart);\n__webpack_require__(914)(Chart);\n\n// Loading built-it plugins\nvar plugins = [];\n\nplugins.push(\n    __webpack_require__(941)(Chart),\n    __webpack_require__(942)(Chart),\n    __webpack_require__(943)(Chart)\n);\n\nChart.plugins.register(plugins);\n\nmodule.exports = Chart;\nif (typeof window !== 'undefined') {\n\twindow.Chart = Chart;\n}\n\n\n/***/ }),\n\n/***/ 908:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Bar = function(context, config) {\n\t\tconfig.type = 'bar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 909:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Bubble = function(context, config) {\n\t\tconfig.type = 'bubble';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 910:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Doughnut = function(context, config) {\n\t\tconfig.type = 'doughnut';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 911:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Line = function(context, config) {\n\t\tconfig.type = 'line';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 912:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.PolarArea = function(context, config) {\n\t\tconfig.type = 'polarArea';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 913:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tChart.Radar = function(context, config) {\n\t\tconfig.type = 'radar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 914:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear', // scatter should not use a category axis\n\t\t\t\tposition: 'bottom',\n\t\t\t\tid: 'x-axis-1' // need an ID so datasets can reference the scale\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left',\n\t\t\t\tid: 'y-axis-1'\n\t\t\t}]\n\t\t},\n\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem) {\n\t\t\t\t\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Register the default config for this type\n\tChart.defaults.scatter = defaultConfig;\n\n\t// Scatter charts use line controllers\n\tChart.controllers.scatter = Chart.controllers.line;\n\n\tChart.Scatter = function(context, config) {\n\t\tconfig.type = 'scatter';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n/***/ }),\n\n/***/ 915:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.bar = {\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\n\t\t\t\t// Specific to Bar Controller\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t// grid line settings\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear'\n\t\t\t}]\n\t\t}\n\t};\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar elements = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(elements[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset? base : vpixels.base;\n\t\t\tmodel.x = horizontal? reset? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal? ipixels.center : reset? base : vpixels.head;\n\t\t\tmodel.height = horizontal? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks.length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex) {\n\t\t\treturn this.getStackCount(datasetIndex) - 1;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar options = scale.options;\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar fullSize = scale.isHorizontal()? scale.width : scale.height;\n\t\t\tvar tickSize = fullSize / scale.ticks.length;\n\t\t\tvar categorySize = tickSize * options.categoryPercentage;\n\t\t\tvar fullBarSize = categorySize / stackCount;\n\t\t\tvar barSize = fullBarSize * options.barPercentage;\n\n\t\t\tbarSize = Math.min(\n\t\t\t\thelpers.getValueOrDefault(options.barThickness, barSize),\n\t\t\t\thelpers.getValueOrDefault(options.maxBarThickness, Infinity));\n\n\t\t\treturn {\n\t\t\t\tstackCount: stackCount,\n\t\t\t\ttickSize: tickSize,\n\t\t\t\tcategorySize: categorySize,\n\t\t\t\tcategorySpacing: tickSize - categorySize,\n\t\t\t\tfullBarSize: fullBarSize,\n\t\t\t\tbarSize: barSize,\n\t\t\t\tbarSpacing: fullBarSize - barSize,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = Number(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar scale = ruler.scale;\n\t\t\tvar isCombo = me.chart.isCombo;\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex);\n\t\t\tvar base = scale.getPixelForValue(null, index, datasetIndex, isCombo);\n\t\t\tvar size = ruler.barSize;\n\n\t\t\tbase -= isCombo? ruler.tickSize / 2 : 0;\n\t\t\tbase += ruler.fullBarSize * stackIndex;\n\t\t\tbase += ruler.categorySpacing / 2;\n\t\t\tbase += ruler.barSpacing / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: base + size,\n\t\t\t\tcenter: base + size / 2\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar elements = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\t\t\tvar d;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\td = dataset.data[i];\n\t\t\t\tif (d !== null && d !== undefined && !isNaN(d)) {\n\t\t\t\t\telements[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\n\t\tsetHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t}\n\t});\n\n\n\t// including horizontalBar in the bar file, instead of a file of its own\n\t// it extends bar (like pie extends doughnut)\n\tChart.defaults.horizontalBar = {\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'bottom'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\tposition: 'left',\n\t\t\t\ttype: 'category',\n\n\t\t\t\t// Specific to Horizontal Bar Controller\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t// grid line settings\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}]\n\t\t},\n\t\telements: {\n\t\t\trectangle: {\n\t\t\t\tborderSkipped: 'left'\n\t\t\t}\n\t\t},\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t\t// Pick first xLabel for now\n\t\t\t\t\tvar title = '';\n\n\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\tif (tooltipItems[0].yLabel) {\n\t\t\t\t\t\t\ttitle = tooltipItems[0].yLabel;\n\t\t\t\t\t\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\n\t\t\t\t\t\t\ttitle = data.labels[tooltipItems[0].index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn title;\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\treturn datasetLabel + ': ' + tooltipItem.xLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 916:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.bubble = {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\t\tposition: 'bottom',\n\t\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t},\n\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t\t\t\t\treturn datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.bubble = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar dsIndex = me.index;\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_xScale: xScale,\n\t\t\t\t_yScale: yScale,\n\t\t\t\t_datasetIndex: dsIndex,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\n\t\t\t\t\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\n\t\t\t\t\t// Appearance\n\t\t\t\t\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Trick to reset the styles of the point\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\n\n\t\t\tvar model = point._model;\n\t\t\tmodel.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\n\n\t\t\tpoint.pivot();\n\t\t},\n\n\t\tgetRadius: function(value) {\n\t\t\treturn value.r || this.chart.options.elements.point.radius;\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tChart.DatasetController.prototype.setHoverStyle.call(me, point);\n\n\t\t\t// Radius\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\n\n\t\t\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 917:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tdefaults = Chart.defaults;\n\n\tdefaults.doughnut = {\n\t\tanimation: {\n\t\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\t\tanimateRotate: true,\n\t\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\t\tanimateScale: false\n\t\t},\n\t\taspectRatio: 1,\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t// toggle visibility of index if exists\n\t\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\n\t\t// The percentage of the chart that we cut out of the middle.\n\t\tcutoutPercentage: 50,\n\n\t\t// The rotation of the chart, where the first data arc begins.\n\t\trotation: Math.PI * -0.5,\n\n\t\t// The total circumference of the chart.\n\t\tcircumference: Math.PI * 2.0,\n\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataLabel += value;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn dataLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tdefaults.pie = helpers.clone(defaults.doughnut);\n\thelpers.extend(defaults.pie, {\n\t\tcutoutPercentage: 0\n\t});\n\n\n\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ringIndex;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart,\n\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\topts = chart.options,\n\t\t\t\tarcOpts = opts.elements.arc,\n\t\t\t\tavailableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\n\t\t\t\tavailableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\n\t\t\t\tminSize = Math.min(availableWidth, availableHeight),\n\t\t\t\toffset = {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t},\n\t\t\t\tmeta = me.getMeta(),\n\t\t\t\tcutoutPercentage = opts.cutoutPercentage,\n\t\t\t\tcircumference = opts.circumference;\n\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\n\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart,\n\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\topts = chart.options,\n\t\t\t\tanimationOpts = opts.animation,\n\t\t\t\tcenterX = (chartArea.left + chartArea.right) / 2,\n\t\t\t\tcenterY = (chartArea.top + chartArea.bottom) / 2,\n\t\t\t\tstartAngle = opts.rotation, // non reset case handled later\n\t\t\t\tendAngle = opts.rotation, // non reset case handled later\n\t\t\t\tdataset = me.getDataset(),\n\t\t\t\tcircumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\n\t\t\t\tinnerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\n\t\t\t\touterRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\n\t\t\t\tvalueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar model = arc._model;\n\t\t\t// Resets the visual styles\n\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\n\t\t\treturn total;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (value / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(elements) {\n\t\t\tvar max = 0,\n\t\t\t\tindex = this.index,\n\t\t\t\tlength = elements.length,\n\t\t\t\tborderWidth,\n\t\t\t\thoverWidth;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tborderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\n\t\t\t\thoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 918:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.line = {\n\t\tshowLines: true,\n\t\tspanGaps: false,\n\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\t\t\t\tid: 'x-axis-0'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t}\n\t};\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: Chart.elements.Line,\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\t\t\tvar labels = me.chart.data.labels || [];\n\t\t\tvar includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar i = 0;\n\n\t\t\tChart.canvasHelpers.clipArea(chart.ctx, area);\n\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tChart.canvasHelpers.unclipArea(chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 919:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.polarArea = {\n\n\t\tscale: {\n\t\t\ttype: 'radialLinear',\n\t\t\tangleLines: {\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\t\tgridLines: {\n\t\t\t\tcircular: true\n\t\t\t},\n\t\t\tpointLabels: {\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\t\tticks: {\n\t\t\t\tbeginAtZero: true\n\t\t\t}\n\t\t},\n\n\t\t// Boolean - Whether to animate the rotation of the chart\n\t\tanimation: {\n\t\t\tanimateRotate: true,\n\t\t\tanimateScale: true\n\t\t},\n\n\t\tstartAngle: -0.5 * Math.PI,\n\t\taspectRatio: 1,\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\tvar labels = chart.data.labels;\n\n\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\tvar visibleCount = 0;\n\t\t\tvar meta = me.getMeta();\n\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t++visibleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply border and fill style\n\t\t\tme.removeHoverStyle(arc);\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn count;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar count = this.getMeta().count;\n\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 920:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.radar = {\n\t\taspectRatio: 1,\n\t\tscale: {\n\t\t\ttype: 'radialLinear'\n\t\t},\n\t\telements: {\n\t\t\tline: {\n\t\t\t\ttension: 0 // no bezier in radar\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: Chart.elements.Line,\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data;\n\t\t\tvar custom = line.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\tvar scale = me.chart.scale;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_scale: scale,\n\t\t\t\t// Data\n\t\t\t\t_children: points,\n\t\t\t\t_loop: true,\n\t\t\t\t// Model\n\t\t\t\t_model: {\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmeta.dataset.pivot();\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t}, me);\n\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\t},\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t},\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\tvar meta = this.getMeta();\n\n\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tpoint.pivot();\n\t\t\t});\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 921:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* global window: false */\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.animation = {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t};\n\n\tChart.Animation = Chart.Element.extend({\n\t\tchart: null, // the animation associated chart instance\n\t\tcurrentStep: 0, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @param {Chart} chart - The chart to animate.\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t\t * @param {Number} duration - The animation duration in ms.\n\t\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chart, animation, duration, lazy) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar i, ilen;\n\n\t\t\tanimation.chart = chart;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchart.animating = true;\n\t\t\t}\n\n\t\t\tfor (i=0, ilen=animations.length; i < ilen; ++i) {\n\t\t\t\tif (animations[i].chart === chart) {\n\t\t\t\t\tanimations[i] = animation;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(animation);\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (animations.length === 1) {\n\t\t\t\tthis.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\tcancelAnimation: function(chart) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animation) {\n\t\t\t\treturn animation.chart === chart;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchart.animating = false;\n\t\t\t}\n\t\t},\n\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tme.advance(1 + framesToDrop);\n\n\t\t\tvar endTime = Date.now();\n\n\t\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tadvance: function(count) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar animation, chart;\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < animations.length) {\n\t\t\t\tanimation = animations[i];\n\t\t\t\tchart = animation.chart;\n\n\t\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\n\t\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n\n\t\t\t\thelpers.callback(animation.render, [chart, animation], chart);\n\t\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\t\tif (animation.currentStep >= animation.numSteps) {\n\t\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\t\tchart.animating = false;\n\t\t\t\t\tanimations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation instead\n\t * @prop Chart.Animation#animationObject\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'animationObject', {\n\t\tget: function() {\n\t\t\treturn this;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\n\t * @prop Chart.Animation#chartInstance\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'chartInstance', {\n\t\tget: function() {\n\t\t\treturn this.chart;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.chart = value;\n\t\t}\n\t});\n\n};\n\n\n/***/ }),\n\n/***/ 922:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\t// Global Chart canvas helpers object for drawing items to canvas\n\tvar helpers = Chart.canvasHelpers = {};\n\n\thelpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\tif (typeof pointStyle === 'object') {\n\t\t\ttype = pointStyle.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2, pointStyle.width, pointStyle.height);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (pointStyle) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.beginPath();\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\tvar leftX = x - offset;\n\t\t\tvar topY = y - offset;\n\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\tChart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rectRot':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - size, y);\n\t\t\tctx.lineTo(x, y + size);\n\t\t\tctx.lineTo(x + size, y);\n\t\t\tctx.lineTo(x, y - size);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'cross':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\tctx.beginPath();\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.stroke();\n\t};\n\n\thelpers.clipArea = function(ctx, clipArea) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);\n\t\tctx.clip();\n\t};\n\n\thelpers.unclipArea = function(ctx) {\n\t\tctx.restore();\n\t};\n\n\thelpers.lineTo = function(ctx, previous, target, flip) {\n\t\tif (target.steppedLine) {\n\t\t\tif (target.steppedLine === 'after') {\n\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t} else {\n\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t}\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target.tension) {\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tctx.bezierCurveTo(\n\t\t\tflip? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\tflip? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\tflip? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\tflip? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\ttarget.x,\n\t\t\ttarget.y);\n\t};\n\n\tChart.helpers.canvas = helpers;\n};\n\n\n/***/ }),\n\n/***/ 923:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar plugins = Chart.plugins;\n\tvar platform = Chart.platform;\n\n\t// Create a dictionary of chart types, to allow for extension of existing types\n\tChart.types = {};\n\n\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\tChart.instances = {};\n\n\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\tChart.controllers = {};\n\n\t/**\n\t * Initializes the given config with global and chart default values.\n\t */\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\n\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\n\t\tconfig.options = helpers.configMerge(\n\t\t\tChart.defaults.global,\n\t\t\tChart.defaults[config.type],\n\t\t\tconfig.options || {});\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Updates the config of the chart\n\t * @param chart {Chart} chart to update the options for\n\t */\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\n\t\t// Update Scale(s) with options\n\t\tif (newOptions.scale) {\n\t\t\tchart.scale.options = newOptions.scale;\n\t\t} else if (newOptions.scales) {\n\t\t\tnewOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {\n\t\t\t\tchart.scales[scaleOptions.id].options = scaleOptions;\n\t\t\t});\n\t\t}\n\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t}\n\n\tfunction positionIsHorizontal(position) {\n\t\treturn position === 'top' || position === 'bottom';\n\t}\n\n\thelpers.extend(Chart.prototype, /** @lends Chart */ {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tconstruct: function(item, config) {\n\t\t\tvar me = this;\n\n\t\t\tconfig = initConfig(config);\n\n\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\tvar canvas = context && context.canvas;\n\t\t\tvar height = canvas && canvas.height;\n\t\t\tvar width = canvas && canvas.width;\n\n\t\t\tme.id = helpers.uid();\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = canvas;\n\t\t\tme.config = config;\n\t\t\tme.width = width;\n\t\t\tme.height = height;\n\t\t\tme.aspectRatio = height? width / height : null;\n\t\t\tme.options = config.options;\n\t\t\tme._bufferedRender = false;\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t\t * @prop Chart#chart\n\t\t\t * @deprecated since version 2.6.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tme.chart = me;\n\t\t\tme.controller = me;  // chart.chart.controller #inception\n\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[me.id] = me;\n\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn me.config.data;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\tme.config.data = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!context || !canvas) {\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.initialize();\n\t\t\tme.update();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\n\t\t\t// Before init plugin notification\n\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\thelpers.retinaScale(me);\n\n\t\t\tme.bindEvents();\n\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildScales();\n\t\t\tme.initToolTip();\n\n\t\t\t// After init plugin notification\n\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\treturn me;\n\t\t},\n\n\t\tclear: function() {\n\t\t\thelpers.clear(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\t\t\tvar newWidth = Math.floor(helpers.getMaximumWidth(canvas));\n\t\t\tvar newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\n\n\t\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvas.width = me.width = newWidth;\n\t\t\tcanvas.height = me.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\thelpers.retinaScale(me);\n\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\n\t\t\t\tme.stop();\n\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t}\n\t\t},\n\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\n\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\n\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales = {};\n\t\t\tvar items = [];\n\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({\n\t\t\t\t\toptions: options.scale,\n\t\t\t\t\tdtype: 'radialLinear',\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tdposition: 'chartArea'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\n\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\tif (!scaleClass) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t\t}\n\n\t\t\t\tvar scale = new scaleClass({\n\t\t\t\t\tid: scaleOptions.id,\n\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\tchart: me\n\t\t\t\t});\n\n\t\t\t\tscales[scale.id] = scale;\n\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t},\n\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar types = [];\n\t\t\tvar newControllers = [];\n\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tif (!meta.type) {\n\t\t\t\t\tmeta.type = dataset.type || me.config.type;\n\t\t\t\t}\n\n\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t} else {\n\t\t\t\t\tvar ControllerClass = Chart.controllers[meta.type];\n\t\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\tif (types.length > 1) {\n\t\t\t\tfor (var i = 1; i < types.length; i++) {\n\t\t\t\t\tif (types[i] !== types[i - 1]) {\n\t\t\t\t\t\tme.isCombo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newControllers;\n\t\t},\n\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\n\t\tupdate: function(animationDuration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tupdateConfig(me);\n\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\n\t\t\tme.updateLayout();\n\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\tcontroller.reset();\n\t\t\t});\n\n\t\t\tme.updateDatasets();\n\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tlazy: lazy,\n\t\t\t\t\tduration: animationDuration\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(animationDuration, lazy);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tChart.layoutService.update(this, this.width, this.height);\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\tplugins.notify(me, 'afterLayout');\n\t\t},\n\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.updateDataset(i);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\n\t\t/**\n\t\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDataset: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.update();\n\n\t\t\tplugins.notify(me, 'afterDatasetUpdate', [args]);\n\t\t},\n\n\t\trender: function(duration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar onComplete = function(animation) {\n\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\thelpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t\t};\n\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\tvar animation = new Chart.Animation({\n\t\t\t\t\tnumSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\n\t\t\t\t\teasing: animationOptions.easing,\n\n\t\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers.easingEffects[animationObject.easing];\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t\t},\n\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\t\tonAnimationComplete: onComplete\n\t\t\t\t});\n\n\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\t\tonComplete(new Chart.Animation({numSteps: 0, chart: me}));\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tme.clear();\n\n\t\t\tif (easingValue === undefined || easingValue === null) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\n\t\t\tme.transition(easingValue);\n\n\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw all the scales\n\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\n\t\t\tif (me.scale) {\n\t\t\t\tme.scale.draw();\n\t\t\t}\n\n\t\t\tme.drawDatasets(easingValue);\n\n\t\t\t// Finally draw the tooltip\n\t\t\tme.tooltip.draw();\n\n\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\ttransition: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tfor (var i=0, ilen=(me.data.datasets || []).length; i<ilen; ++i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.tooltip.transition(easingValue);\n\t\t},\n\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw datasets reversed to support proper line stacking\n\t\t\tfor (var i=(me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDataset: function(index, easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.draw(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDatasetDraw', [args]);\n\t\t},\n\n\t\t// Get the single element that was clicked on\n\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.single(this, e);\n\t\t},\n\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn Chart.Interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = Chart.Interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t},\n\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn meta;\n\t\t},\n\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar meta, i, ilen;\n\n\t\t\tme.stop();\n\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tmeta = me.getDatasetMeta(i);\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.destroy();\n\t\t\t\t\tmeta.controller = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers.clear(me);\n\t\t\t\tplatform.releaseContext(me.ctx);\n\t\t\t\tme.canvas = null;\n\t\t\t\tme.ctx = null;\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\n\t\ttoBase64Image: function() {\n\t\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t\t},\n\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t_chart: me,\n\t\t\t\t_chartInstance: me,            // deprecated, backward compatibility\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t\tme.tooltip.initialize();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\n\t\t\thelpers.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\n\t\t\t// Responsiveness is currently based on the use of an iframe, however this method causes\n\t\t\t// performance issues and could be troublesome when used with ad blockers. So make sure\n\t\t\t// that the user is still able to create a chart without iframe when responsive is false.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete me._listeners;\n\t\t\thelpers.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\n\t\t\tfor (i=0, ilen=elements.length; i<ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\n\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\tchanged |= tooltip && tooltip.handleEvent(e);\n\n\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest.duration, bufferedRequest.lazy);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t}\n\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\treturn me;\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {Boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\n\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\n\t\t\t// On Hover hook\n\t\t\tif (hoverOptions.onHover) {\n\t\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\t\thoverOptions.onHover.call(me, e.native, me.active);\n\t\t\t}\n\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\n\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart instead.\n\t * @class Chart.Controller\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.Controller = Chart;\n};\n\n\n/***/ }),\n\n/***/ 924:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\thelpers.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\n\t\tdelete array._chartjs;\n\t}\n\n\t// Base class for all dataset controllers (line, bar, etc)\n\tChart.DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\n\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tif (meta.xAxisID === null) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i=0, ilen=data.length; i<ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\tme._data = data;\n\t\t\t}\n\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\n\t\tupdate: helpers.noop,\n\n\t\ttransition: function(easingValue) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\telements[i].transition(easingValue);\n\t\t\t}\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.transition(easingValue);\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\telements[i].draw();\n\t\t\t}\n\t\t},\n\n\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\tindex = element._index,\n\t\t\t\tcustom = element.custom || {},\n\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\tmodel = element._model;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t},\n\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\tindex = element._index,\n\t\t\t\tcustom = element.custom || {},\n\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\tgetHoverColor = helpers.getHoverColor,\n\t\t\t\tmodel = element._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i=0; i<count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tthis.insertElements(this.getDataset().data.length-1, arguments.length);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\n\tChart.DatasetController.extend = helpers.inherits;\n};\n\n\n/***/ }),\n\n/***/ 925:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar color = __webpack_require__(894);\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tfunction interpolate(start, view, model, ease) {\n\t\tvar keys = Object.keys(model);\n\t\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\n\t\tfor (i=0, ilen=keys.length; i<ilen; ++i) {\n\t\t\tkey = keys[i];\n\n\t\t\ttarget = model[key];\n\n\t\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\t\tif (!view.hasOwnProperty(key)) {\n\t\t\t\tview[key] = target;\n\t\t\t}\n\n\t\t\tactual = view[key];\n\n\t\t\tif (actual === target || key[0] === '_') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!start.hasOwnProperty(key)) {\n\t\t\t\tstart[key] = actual;\n\t\t\t}\n\n\t\t\torigin = start[key];\n\n\t\t\ttype = typeof(target);\n\n\t\t\tif (type === typeof(origin)) {\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tc0 = color(origin);\n\t\t\t\t\tif (c0.valid) {\n\t\t\t\t\t\tc1 = color(target);\n\t\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 'number' && isFinite(origin) && isFinite(target)) {\n\t\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tview[key] = target;\n\t\t}\n\t}\n\n\tChart.elements = {};\n\n\tChart.Element = function(configuration) {\n\t\thelpers.extend(this, configuration);\n\t\tthis.initialize.apply(this, arguments);\n\t};\n\n\thelpers.extend(Chart.Element.prototype, {\n\n\t\tinitialize: function() {\n\t\t\tthis.hidden = false;\n\t\t},\n\n\t\tpivot: function() {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t}\n\t\t\tme._start = {};\n\t\t\treturn me;\n\t\t},\n\n\t\ttransition: function(ease) {\n\t\t\tvar me = this;\n\t\t\tvar model = me._model;\n\t\t\tvar start = me._start;\n\t\t\tvar view = me._view;\n\n\t\t\t// No animation -> No Transition\n\t\t\tif (!model || ease === 1) {\n\t\t\t\tme._view = model;\n\t\t\t\tme._start = null;\n\t\t\t\treturn me;\n\t\t\t}\n\n\t\t\tif (!view) {\n\t\t\t\tview = me._view = {};\n\t\t\t}\n\n\t\t\tif (!start) {\n\t\t\t\tstart = me._start = {};\n\t\t\t}\n\n\t\t\tinterpolate(start, view, model, ease);\n\n\t\t\treturn me;\n\t\t},\n\n\t\ttooltipPosition: function() {\n\t\t\treturn {\n\t\t\t\tx: this._model.x,\n\t\t\t\ty: this._model.y\n\t\t\t};\n\t\t},\n\n\t\thasValue: function() {\n\t\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t\t}\n\t});\n\n\tChart.Element.extend = helpers.inherits;\n};\n\n\n/***/ }),\n\n/***/ 926:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* global window: false */\n/* global document: false */\n\n\nvar color = __webpack_require__(894);\n\nmodule.exports = function(Chart) {\n\t// Global Chart helpers object for utility methods and classes\n\tvar helpers = Chart.helpers = {};\n\n\t// -- Basic js utility methods\n\thelpers.each = function(loopable, callback, self, reverse) {\n\t\t// Check to see if null or undefined firstly.\n\t\tvar i, len;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typeof loopable === 'object') {\n\t\t\tvar keys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tcallback.call(self, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t};\n\thelpers.clone = function(obj) {\n\t\tvar objClone = {};\n\t\thelpers.each(obj, function(value, key) {\n\t\t\tif (helpers.isArray(value)) {\n\t\t\t\tobjClone[key] = value.slice(0);\n\t\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\t\tobjClone[key] = helpers.clone(value);\n\t\t\t} else {\n\t\t\t\tobjClone[key] = value;\n\t\t\t}\n\t\t});\n\t\treturn objClone;\n\t};\n\thelpers.extend = function(base) {\n\t\tvar setFn = function(value, key) {\n\t\t\tbase[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn base;\n\t};\n\t// Need a special merge function to chart configs since they are now grouped\n\thelpers.configMerge = function(_base) {\n\t\tvar base = helpers.clone(_base);\n\t\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\n\t\t\thelpers.each(extension, function(value, key) {\n\t\t\t\tvar baseHasProperty = base.hasOwnProperty(key);\n\t\t\t\tvar baseVal = baseHasProperty ? base[key] : {};\n\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// Scale config merging is complex. Add our own function here for that\n\t\t\t\t\tbase[key] = helpers.scaleMerge(baseVal, value);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// Used in polar area & radar charts since there is only one scale\n\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\n\t\t\t\t} else if (baseHasProperty\n\t\t\t\t\t\t&& typeof baseVal === 'object'\n\t\t\t\t\t\t&& !helpers.isArray(baseVal)\n\t\t\t\t\t\t&& baseVal !== null\n\t\t\t\t\t\t&& typeof value === 'object'\n\t\t\t\t\t\t&& !helpers.isArray(value)) {\n\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, value);\n\t\t\t\t} else {\n\t\t\t\t\t// can just overwrite the value in this case\n\t\t\t\t\tbase[key] = value;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn base;\n\t};\n\thelpers.scaleMerge = function(_base, extension) {\n\t\tvar base = helpers.clone(_base);\n\n\t\thelpers.each(extension, function(value, key) {\n\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t// These properties are arrays of items\n\t\t\t\tif (base.hasOwnProperty(key)) {\n\t\t\t\t\thelpers.each(value, function(valueObj, index) {\n\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\n\t\t\t\t\t\tif (index >= base[key].length || !base[key][index].type) {\n\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\n\t\t\t\t\t\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\n\t\t\t\t\t\t\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\n\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Type is the same\n\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tbase[key] = [];\n\t\t\t\t\thelpers.each(value, function(valueObj) {\n\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\n\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\tbase[key] = helpers.configMerge(base[key], value);\n\n\t\t\t} else {\n\t\t\t\t// can just overwrite the value in this case\n\t\t\t\tbase[key] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn base;\n\t};\n\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tif (helpers.isArray(value)) {\n\t\t\treturn index < value.length ? value[index] : defaultValue;\n\t\t}\n\n\t\treturn value;\n\t};\n\thelpers.getValueOrDefault = function(value, defaultValue) {\n\t\treturn value === undefined ? defaultValue : value;\n\t};\n\thelpers.indexOf = Array.prototype.indexOf?\n\t\tfunction(array, item) {\n\t\t\treturn array.indexOf(item);\n\t\t}:\n\t\tfunction(array, item) {\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (array[i] === item) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.where = function(collection, filterCallback) {\n\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers.findIndex = Array.prototype.findIndex?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.inherits = function(extensions) {\n\t\t// Basic javascript inheritance based on the model created in Backbone.js\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\n\t\treturn ChartElement;\n\t};\n\thelpers.noop = function() {};\n\thelpers.uid = (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}());\n\t// -- Math methods\n\thelpers.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers.sign = Math.sign?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers.log10 = Math.log10?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\treturn Math.log(x) / Math.LN10;\n\t\t};\n\thelpers.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\n\t\t\tdistanceFromYCenter = anglePoint.y - centrePoint.y,\n\t\t\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\thelpers.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\n\t\t\tcurrent = middlePoint,\n\t\t\tnext = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\thelpers.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bézier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Easing functions adapted from Robert Penner's easing equations\n\t// http://www.robertpenner.com/easing/\n\tvar easingEffects = helpers.easingEffects = {\n\t\tlinear: function(t) {\n\t\t\treturn t;\n\t\t},\n\t\teaseInQuad: function(t) {\n\t\t\treturn t * t;\n\t\t},\n\t\teaseOutQuad: function(t) {\n\t\t\treturn -1 * t * (t - 2);\n\t\t},\n\t\teaseInOutQuad: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t;\n\t\t\t}\n\t\t\treturn -1 / 2 * ((--t) * (t - 2) - 1);\n\t\t},\n\t\teaseInCubic: function(t) {\n\t\t\treturn t * t * t;\n\t\t},\n\t\teaseOutCubic: function(t) {\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\n\t\t},\n\t\teaseInOutCubic: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t;\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * t + 2);\n\t\t},\n\t\teaseInQuart: function(t) {\n\t\t\treturn t * t * t * t;\n\t\t},\n\t\teaseOutQuart: function(t) {\n\t\t\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\n\t\t},\n\t\teaseInOutQuart: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t * t;\n\t\t\t}\n\t\t\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\n\t\t},\n\t\teaseInQuint: function(t) {\n\t\t\treturn 1 * (t /= 1) * t * t * t * t;\n\t\t},\n\t\teaseOutQuint: function(t) {\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\n\t\t},\n\t\teaseInOutQuint: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t * t * t;\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\n\t\t},\n\t\teaseInSine: function(t) {\n\t\t\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\n\t\t},\n\t\teaseOutSine: function(t) {\n\t\t\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\n\t\t},\n\t\teaseInOutSine: function(t) {\n\t\t\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\n\t\t},\n\t\teaseInExpo: function(t) {\n\t\t\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\n\t\t},\n\t\teaseOutExpo: function(t) {\n\t\t\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\n\t\t},\n\t\teaseInOutExpo: function(t) {\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (t === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\n\t\t\t}\n\t\t\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\n\t\t},\n\t\teaseInCirc: function(t) {\n\t\t\tif (t >= 1) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\n\t\t},\n\t\teaseOutCirc: function(t) {\n\t\t\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\n\t\t},\n\t\teaseInOutCirc: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\n\t\t\t}\n\t\t\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t\t},\n\t\teaseInElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1) === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * 0.3;\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t},\n\t\teaseOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1) === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * 0.3;\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\n\t\t},\n\t\teaseInOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1 / 2) === 2) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * (0.3 * 1.5);\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\tif (t < 1) {\n\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\t},\n\t\teaseInBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\n\t\t},\n\t\teaseOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\n\t\t},\n\t\teaseInOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t\t},\n\t\teaseInBounce: function(t) {\n\t\t\treturn 1 - easingEffects.easeOutBounce(1 - t);\n\t\t},\n\t\teaseOutBounce: function(t) {\n\t\t\tif ((t /= 1) < (1 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * t * t);\n\t\t\t} else if (t < (2 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\n\t\t\t} else if (t < (2.5 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\n\t\t\t}\n\t\t\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\n\t\t},\n\t\teaseInOutBounce: function(t) {\n\t\t\tif (t < 1 / 2) {\n\t\t\t\treturn easingEffects.easeInBounce(t * 2) * 0.5;\n\t\t\t}\n\t\t\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\n\t\t}\n\t};\n\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers.requestAnimFrame = (function() {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn function(callback) {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t}\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt,\n\t\t\tcanvas = evt.currentTarget || evt.srcElement,\n\t\t\tboundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\thelpers.addEvent = function(node, eventType, method) {\n\t\tif (node.addEventListener) {\n\t\t\tnode.addEventListener(eventType, method);\n\t\t} else if (node.attachEvent) {\n\t\t\tnode.attachEvent('on' + eventType, method);\n\t\t} else {\n\t\t\tnode['on' + eventType] = method;\n\t\t}\n\t};\n\thelpers.removeEvent = function(node, eventType, handler) {\n\t\tif (node.removeEventListener) {\n\t\t\tnode.removeEventListener(eventType, handler, false);\n\t\t} else if (node.detachEvent) {\n\t\t\tnode.detachEvent('on' + eventType, handler);\n\t\t} else {\n\t\t\tnode['on' + eventType] = helpers.noop;\n\t\t}\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof(styleValue) === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t// Private helper to get a constraint dimension\n\t// @param domNode : the node to check the constraint on\n\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = domNode.parentNode;\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\thelpers.getMaximumWidth = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\treturn isNaN(cw)? w : Math.min(w, cw);\n\t};\n\thelpers.getMaximumHeight = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\treturn isNaN(ch)? h : Math.min(h, ch);\n\t};\n\thelpers.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers.retinaScale = function(chart) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tcanvas.style.height = height + 'px';\n\t\tcanvas.style.width = width + 'px';\n\t};\n\t// -- Canvas methods\n\thelpers.clear = function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t};\n\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t};\n\n\thelpers.color = !color?\n\t\tfunction(value) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn value;\n\t\t} :\n\t\tfunction(value) {\n\t\t\t/* global CanvasGradient */\n\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\tvalue = Chart.defaults.global.defaultColor;\n\t\t\t}\n\n\t\t\treturn color(value);\n\t\t};\n\n\thelpers.isArray = Array.isArray?\n\t\tfunction(obj) {\n\t\t\treturn Array.isArray(obj);\n\t\t} :\n\t\tfunction(obj) {\n\t\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t\t};\n\t// ! @see http://stackoverflow.com/a/14853974\n\thelpers.arrayEquals = function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen=a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\thelpers.callback = function(fn, args, thisArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\tfn.apply(thisArg, args);\n\t\t}\n\t};\n\thelpers.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\tcolorValue :\n\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers#callback instead.\n\t * @function Chart.helpers#callCallback\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\thelpers.callCallback = helpers.callback;\n};\n\n\n/***/ }),\n\n/***/ 927:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Helper function to get relative position for an event\n\t * @param {Event|IEvent} event - The event to get the position for\n\t * @param {Chart} chart - The chart\n\t * @returns {Point} the event position\n\t */\n\tfunction getRelativePosition(e, chart) {\n\t\tif (e.native) {\n\t\t\treturn {\n\t\t\t\tx: e.x,\n\t\t\t\ty: e.y\n\t\t\t};\n\t\t}\n\n\t\treturn helpers.getRelativePosition(e, chart);\n\t}\n\n\t/**\n\t * Helper function to traverse all of the visible elements in the chart\n\t * @param chart {chart} the chart\n\t * @param handler {Function} the callback to execute for each visible item\n\t */\n\tfunction parseVisibleItems(chart, handler) {\n\t\tvar datasets = chart.data.datasets;\n\t\tvar meta, i, j, ilen, jlen;\n\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\t\tvar element = meta.data[j];\n\t\t\t\tif (!element._view.skip) {\n\t\t\t\t\thandler(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to get the items that intersect the event position\n\t * @param items {ChartElement[]} elements to filter\n\t * @param position {Point} the point to be nearest to\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getIntersectItems(chart, position) {\n\t\tvar elements = [];\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\n\t * @param chart {Chart} the chart to look at elements from\n\t * @param position {Point} the point to be nearest to\n\t * @param intersect {Boolean} if true, only consider items that intersect the position\n\t * @param distanceMetric {Function} Optional function to provide the distance between\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\tvar nearestItems = [];\n\n\t\tif (!distanceMetric) {\n\t\t\tdistanceMetric = helpers.distanceBetweenPoints;\n\t\t}\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar center = element.getCenterPoint();\n\t\t\tvar distance = distanceMetric(position, center);\n\n\t\t\tif (distance < minDistance) {\n\t\t\t\tnearestItems = [element];\n\t\t\t\tminDistance = distance;\n\t\t\t} else if (distance === minDistance) {\n\t\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\t\tnearestItems.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn nearestItems;\n\t}\n\n\tfunction indexMode(chart, e, options) {\n\t\tvar position = getRelativePosition(e, chart);\n\t\tvar distanceMetric = function(pt1, pt2) {\n\t\t\treturn Math.abs(pt1.x - pt2.x);\n\t\t};\n\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\tvar elements = [];\n\n\t\tif (!items.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex),\n\t\t\t\t\telement = meta.data[items[0]._index];\n\n\t\t\t\t// don't count items that are skipped (null data)\n\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * @interface IInteractionOptions\n\t */\n\t/**\n\t * If true, only consider items that intersect the point\n\t * @name IInterfaceOptions#boolean\n\t * @type Boolean\n\t */\n\n\t/**\n\t * Contains interaction related functions\n\t * @namespace Chart.Interaction\n\t */\n\tChart.Interaction = {\n\t\t// Helper function for different modes\n\t\tmodes: {\n\t\t\tsingle: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar elements = [];\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\treturn elements;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn elements.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.label\n\t\t\t * @deprecated since version 2.4.0\n\t \t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tlabel: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t\t * @function Chart.Interaction.modes.index\n\t\t\t * @since v2.4.0\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tindex: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t\t * @function Chart.Interaction.modes.dataset\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tdataset: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n\n\t\t\t\tif (items.length > 0) {\n\t\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t\t}\n\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.x-axis\n\t\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\t'x-axis': function(chart, e) {\n\t\t\t\treturn indexMode(chart, e, true);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Point mode returns all elements that hit test based on the event position\n\t\t\t * of the event\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tpoint: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\treturn getIntersectItems(chart, position);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * nearest mode returns the element closest to the point\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tnearest: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect);\n\n\t\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\t\tif (nearestItems.length > 1) {\n\t\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Return only 1 item\n\t\t\t\treturn nearestItems.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t\t * @function Chart.Interaction.modes.x\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tx: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t\t * @function Chart.Interaction.modes.y\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\ty: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 928:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function() {\n\n\t// Occupy the global variable of Chart, and create a simple base class\n\tvar Chart = function(item, config) {\n\t\tthis.construct(item, config);\n\t\treturn this;\n\t};\n\n\t// Globally expose the defaults to allow for user updating/changing\n\tChart.defaults = {\n\t\tglobal: {\n\t\t\tresponsive: true,\n\t\t\tresponsiveAnimationDuration: 0,\n\t\t\tmaintainAspectRatio: true,\n\t\t\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\t\t\thover: {\n\t\t\t\tonHover: null,\n\t\t\t\tmode: 'nearest',\n\t\t\t\tintersect: true,\n\t\t\t\tanimationDuration: 400\n\t\t\t},\n\t\t\tonClick: null,\n\t\t\tdefaultColor: 'rgba(0,0,0,0.1)',\n\t\t\tdefaultFontColor: '#666',\n\t\t\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\t\tdefaultFontSize: 12,\n\t\t\tdefaultFontStyle: 'normal',\n\t\t\tshowLines: true,\n\n\t\t\t// Element defaults defined in element extensions\n\t\t\telements: {},\n\n\t\t\t// Legend callback string\n\t\t\tlegendCallback: function(chart) {\n\t\t\t\tvar text = [];\n\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\t\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t\ttext.push('</ul>');\n\n\t\t\t\treturn text.join('');\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.Chart = Chart;\n\n\treturn Chart;\n};\n\n\n/***/ }),\n\n/***/ 929:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tfunction filterByPosition(array, position) {\n\t\treturn helpers.where(array, function(v) {\n\t\t\treturn v.position === position;\n\t\t});\n\t}\n\n\tfunction sortByWeight(array, reverse) {\n\t\tarray.forEach(function(v, i) {\n\t\t\tv._tmpIndex_ = i;\n\t\t\treturn v;\n\t\t});\n\t\tarray.sort(function(a, b) {\n\t\t\tvar v0 = reverse ? b : a;\n\t\t\tvar v1 = reverse ? a : b;\n\t\t\treturn v0.weight === v1.weight ?\n\t\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\t\tv0.weight - v1.weight;\n\t\t});\n\t\tarray.forEach(function(v) {\n\t\t\tdelete v._tmpIndex_;\n\t\t});\n\t}\n\n\t/**\n\t * @interface ILayoutItem\n\t * @prop {String} position - The position of the item in the chart layout. Possible values are\n\t * 'left', 'top', 'right', 'bottom', and 'chartArea'\n\t * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n\t * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n\t * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n\t * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n\t * @prop {Function} getPadding -  Returns an object with padding on the edges\n\t * @prop {Number} width - Width of item. Must be valid after update()\n\t * @prop {Number} height - Height of item. Must be valid after update()\n\t * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n\t */\n\n\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n\t// It is this service's responsibility of carrying out that layout.\n\tChart.layoutService = {\n\t\tdefaults: {},\n\n\t\t/**\n\t\t * Register a box to a chart.\n\t\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t\t * @param {Chart} chart - the chart to use\n\t\t * @param {ILayoutItem} item - the item to add to be layed out\n\t\t */\n\t\taddBox: function(chart, item) {\n\t\t\tif (!chart.boxes) {\n\t\t\t\tchart.boxes = [];\n\t\t\t}\n\n\t\t\t// initialize item with default values\n\t\t\titem.fullWidth = item.fullWidth || false;\n\t\t\titem.position = item.position || 'top';\n\t\t\titem.weight = item.weight || 0;\n\n\t\t\tchart.boxes.push(item);\n\t\t},\n\n\t\t/**\n\t\t * Remove a layoutItem from a chart\n\t\t * @param {Chart} chart - the chart to remove the box from\n\t\t * @param {Object} layoutItem - the item to remove from the layout\n\t\t */\n\t\tremoveBox: function(chart, layoutItem) {\n\t\t\tvar index = chart.boxes? chart.boxes.indexOf(layoutItem) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tchart.boxes.splice(index, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sets (or updates) options on the given `item`.\n\t\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t\t * @param {Object} item - the item to configure with the given options\n\t\t * @param {Object} options - the new item options.\n\t\t */\n\t\tconfigure: function(chart, item, options) {\n\t\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\t\tvar ilen = props.length;\n\t\t\tvar i = 0;\n\t\t\tvar prop;\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\tprop = props[i];\n\t\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\t\titem[prop] = options[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t\t * then running a fitting algorithm\n\t\t * @param {Chart} chart - the chart\n\t\t * @param {Number} width - the width to fit into\n\t\t * @param {Number} height - the height to fit into\n\t\t */\n\t\tupdate: function(chart, width, height) {\n\t\t\tif (!chart) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar layoutOptions = chart.options.layout;\n\t\t\tvar padding = layoutOptions ? layoutOptions.padding : null;\n\n\t\t\tvar leftPadding = 0;\n\t\t\tvar rightPadding = 0;\n\t\t\tvar topPadding = 0;\n\t\t\tvar bottomPadding = 0;\n\n\t\t\tif (!isNaN(padding)) {\n\t\t\t\t// options.layout.padding is a number. assign to all\n\t\t\t\tleftPadding = padding;\n\t\t\t\trightPadding = padding;\n\t\t\t\ttopPadding = padding;\n\t\t\t\tbottomPadding = padding;\n\t\t\t} else {\n\t\t\t\tleftPadding = padding.left || 0;\n\t\t\t\trightPadding = padding.right || 0;\n\t\t\t\ttopPadding = padding.top || 0;\n\t\t\t\tbottomPadding = padding.bottom || 0;\n\t\t\t}\n\n\t\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\t\tsortByWeight(leftBoxes, true);\n\t\t\tsortByWeight(rightBoxes, false);\n\t\t\tsortByWeight(topBoxes, true);\n\t\t\tsortByWeight(bottomBoxes, false);\n\n\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t\t// Our canvas looks like the following.\n\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t\t// B1 is the bottom axis\n\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t\t// an error will be thrown.\n\t\t\t//\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  T1 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |    |    |                 T2                  |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    | C1 |                           | C2 |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    | C3 |                           | C4 |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    |                 B1                  |    |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  B2 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t//\n\t\t\t// What we do to find the best sizing, we do the following\n\t\t\t// 1. Determine the minimum size of the chart area.\n\t\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t\t// 6. Refit each axis\n\t\t\t// 7. Position each axis in the final location\n\t\t\t// 8. Tell the chart the final location of the chart area\n\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t\t// Step 1\n\t\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t\t// Step 2\n\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t\t// Step 3\n\t\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t\t// Step 4\n\t\t\tvar maxChartAreaWidth = chartWidth;\n\t\t\tvar maxChartAreaHeight = chartHeight;\n\t\t\tvar minBoxSizes = [];\n\n\t\t\tfunction getMinimumBoxSize(box) {\n\t\t\t\tvar minSize;\n\t\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t\t} else {\n\t\t\t\t\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\n\t\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t\t}\n\n\t\t\t\tminBoxSizes.push({\n\t\t\t\t\thorizontal: isHorizontal,\n\t\t\t\t\tminSize: minSize,\n\t\t\t\t\tbox: box,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\t\tvar maxHorizontalLeftPadding = 0;\n\t\t\tvar maxHorizontalRightPadding = 0;\n\t\t\tvar maxVerticalTopPadding = 0;\n\t\t\tvar maxVerticalBottomPadding = 0;\n\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\t\tif (verticalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t\t// be if the axes are drawn at their minimum sizes.\n\t\t\t// Steps 5 & 6\n\t\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\t\tvar totalRightBoxesWidth = rightPadding;\n\t\t\tvar totalTopBoxesHeight = topPadding;\n\t\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t\t// Function to fit a box\n\t\t\tfunction fitBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\t\treturn minBox.box === box;\n\t\t\t\t});\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\t// Set the Left and Right margins for the horizontal boxes\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\tfunction finalFitVerticalBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\t\treturn minSize.box === box;\n\t\t\t\t});\n\n\t\t\t\tvar scaleMargin = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t\t};\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the left layout know the final margin\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\t\ttotalLeftBoxesWidth = leftPadding;\n\t\t\ttotalRightBoxesWidth = rightPadding;\n\t\t\ttotalTopBoxesHeight = topPadding;\n\t\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\t// We may be adding some padding to account for rotated x axis labels\n\t\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t\t// without calling `fit` again\n\t\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t\t}\n\n\t\t\t// Step 7 - Position the boxes\n\t\t\tvar left = leftPadding + leftPaddingAddition;\n\t\t\tvar top = topPadding + topPaddingAddition;\n\n\t\t\tfunction placeBox(box) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\t\tbox.top = top;\n\t\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\ttop = box.bottom;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.left = left;\n\t\t\t\t\tbox.right = left + box.width;\n\t\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\tleft = box.right;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t\t// Account for chart width and height\n\t\t\tleft += maxChartAreaWidth;\n\t\t\ttop += maxChartAreaHeight;\n\n\t\t\thelpers.each(rightBoxes, placeBox);\n\t\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t\t// Step 8\n\t\t\tchart.chartArea = {\n\t\t\t\tleft: totalLeftBoxesWidth,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t\t};\n\n\t\t\t// Step 9\n\t\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\t\tbox.left = chart.chartArea.left;\n\t\t\t\tbox.top = chart.chartArea.top;\n\t\t\t\tbox.right = chart.chartArea.right;\n\t\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 930:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.plugins = {};\n\n\t/**\n\t * The plugin service singleton\n\t * @namespace Chart.plugins\n\t * @since 2.1.0\n\t */\n\tChart.plugins = {\n\t\t/**\n\t\t * Globally registered plugins.\n\t\t * @private\n\t\t */\n\t\t_plugins: [],\n\n\t\t/**\n\t\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t\t * incremented and descriptors are regenerated during following API calls.\n\t\t * @private\n\t\t */\n\t\t_cacheId: 0,\n\n\t\t/**\n\t\t * Registers the given plugin(s) if not already registered.\n\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t */\n\t\tregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\t\tp.push(plugin);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Unregisters the given plugin(s) only if registered.\n\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t */\n\t\tunregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tvar idx = p.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tp.splice(idx, 1);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Remove all registered plugins.\n\t\t * @since 2.1.5\n\t\t */\n\t\tclear: function() {\n\t\t\tthis._plugins = [];\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Returns the number of registered plugins?\n\t\t * @returns {Number}\n\t\t * @since 2.1.5\n\t\t */\n\t\tcount: function() {\n\t\t\treturn this._plugins.length;\n\t\t},\n\n\t\t/**\n\t\t * Returns all registered plugin instances.\n\t\t * @returns {Array} array of plugin objects.\n\t\t * @since 2.1.5\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn this._plugins;\n\t\t},\n\n\t\t/**\n\t\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t\t * returned value can be used, for instance, to interrupt the current action.\n\t\t * @param {Object} chart - The chart instance for which plugins should be called.\n\t\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t\t */\n\t\tnotify: function(chart, hook, args) {\n\t\t\tvar descriptors = this.descriptors(chart);\n\t\t\tvar ilen = descriptors.length;\n\t\t\tvar i, descriptor, plugin, params, method;\n\n\t\t\tfor (i=0; i<ilen; ++i) {\n\t\t\t\tdescriptor = descriptors[i];\n\t\t\t\tplugin = descriptor.plugin;\n\t\t\t\tmethod = plugin[hook];\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\t\tparams.push(descriptor.options);\n\t\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Returns descriptors of enabled plugins for the given chart.\n\t\t * @returns {Array} [{ plugin, options }]\n\t\t * @private\n\t\t */\n\t\tdescriptors: function(chart) {\n\t\t\tvar cache = chart._plugins || (chart._plugins = {});\n\t\t\tif (cache.id === this._cacheId) {\n\t\t\t\treturn cache.descriptors;\n\t\t\t}\n\n\t\t\tvar plugins = [];\n\t\t\tvar descriptors = [];\n\t\t\tvar config = (chart && chart.config) || {};\n\t\t\tvar defaults = Chart.defaults.global.plugins;\n\t\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar id = plugin.id;\n\t\t\t\tvar opts = options[id];\n\t\t\t\tif (opts === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (opts === true) {\n\t\t\t\t\topts = helpers.clone(defaults[id]);\n\t\t\t\t}\n\n\t\t\t\tplugins.push(plugin);\n\t\t\t\tdescriptors.push({\n\t\t\t\t\tplugin: plugin,\n\t\t\t\t\toptions: opts || {}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcache.descriptors = descriptors;\n\t\t\tcache.id = this._cacheId;\n\t\t\treturn descriptors;\n\t\t}\n\t};\n\n\t/**\n\t * Plugin extension hooks.\n\t * @interface IPlugin\n\t * @since 2.1.0\n\t */\n\t/**\n\t * @method IPlugin#beforeInit\n\t * @desc Called before initializing `chart`.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#afterInit\n\t * @desc Called after `chart` has been initialized and before the first update.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeUpdate\n\t * @desc Called before updating `chart`. If any plugin returns `false`, the update\n\t * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart update.\n\t */\n\t/**\n\t * @method IPlugin#afterUpdate\n\t * @desc Called after `chart` has been updated and before rendering. Note that this\n\t * hook will not be called if the chart update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetsUpdate\n \t * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n\t * the datasets update is cancelled until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} false to cancel the datasets update.\n\t * @since version 2.1.5\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetsUpdate\n\t * @desc Called after the `chart` datasets have been updated. Note that this hook\n\t * will not be called if the datasets update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @since version 2.1.5\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetUpdate\n \t * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n\t * returns `false`, the datasets update is cancelled until another `update` is triggered.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetUpdate\n \t * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n\t * that this hook will not be called if the datasets update has been previously cancelled.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeLayout\n\t * @desc Called before laying out `chart`. If any plugin returns `false`,\n\t * the layout update is cancelled until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart layout.\n\t */\n\t/**\n\t * @method IPlugin#afterLayout\n\t * @desc Called after the `chart` has been layed out. Note that this hook will not\n\t * be called if the layout update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeRender\n\t * @desc Called before rendering `chart`. If any plugin returns `false`,\n\t * the rendering is cancelled until another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart rendering.\n\t */\n\t/**\n\t * @method IPlugin#afterRender\n\t * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n\t * that this hook will not be called if the rendering has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDraw\n\t * @desc Called before drawing `chart` at every animation frame specified by the given\n\t * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n\t * another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDraw\n\t * @desc Called after the `chart` has been drawn for the specific easing value. Note\n\t * that this hook will not be called if the drawing has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetsDraw\n \t * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n\t * the datasets drawing is cancelled until another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetsDraw\n\t * @desc Called after the `chart` datasets have been drawn. Note that this hook\n\t * will not be called if the datasets drawing has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetDraw\n \t * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n\t * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n\t * is cancelled until another `render` is triggered.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetDraw\n \t * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n\t * (datasets are drawn in the reverse order). Note that this hook will not be called\n\t * if the datasets drawing has been previously cancelled.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeEvent\n \t * @desc Called before processing the specified `event`. If any plugin returns `false`,\n\t * the event will be discarded.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {IEvent} event - The event object.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#afterEvent\n\t * @desc Called after the `event` has been consumed. Note that this hook\n\t * will not be called if the `event` has been previously discarded.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {IEvent} event - The event object.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#resize\n\t * @desc Called after the chart as been resized.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#destroy\n\t * @desc Called after the chart as been destroyed.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\n\t/**\n\t * Provided for backward compatibility, use Chart.plugins instead\n\t * @namespace Chart.pluginService\n\t * @deprecated since version 2.1.5\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.pluginService = Chart.plugins;\n\n\t/**\n\t * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n\t * effect, instead simply create/register plugins via plain JavaScript objects.\n\t * @interface Chart.PluginBase\n\t * @deprecated since version 2.5.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.PluginBase = Chart.Element.extend({});\n};\n\n\n/***/ }),\n\n/***/ 931:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.scale = {\n\t\tdisplay: true,\n\t\tposition: 'left',\n\n\t\t// grid line settings\n\t\tgridLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1,\n\t\t\tdrawBorder: true,\n\t\t\tdrawOnChartArea: true,\n\t\t\tdrawTicks: true,\n\t\t\ttickMarkLength: 10,\n\t\t\tzeroLineWidth: 1,\n\t\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\t\tzeroLineBorderDash: [],\n\t\t\tzeroLineBorderDashOffset: 0.0,\n\t\t\toffsetGridLines: false,\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0\n\t\t},\n\n\t\t// scale label\n\t\tscaleLabel: {\n\t\t\t// actual label\n\t\t\tlabelString: '',\n\n\t\t\t// display property\n\t\t\tdisplay: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tbeginAtZero: false,\n\t\t\tminRotation: 0,\n\t\t\tmaxRotation: 50,\n\t\t\tmirror: false,\n\t\t\tpadding: 0,\n\t\t\treverse: false,\n\t\t\tdisplay: true,\n\t\t\tautoSkip: true,\n\t\t\tautoSkipPadding: 0,\n\t\t\tlabelOffset: 0,\n\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\t\tcallback: Chart.Ticks.formatters.values\n\t\t}\n\t};\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\tvar size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tChart.Scale = Chart.Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks\n\t\t\tme.beforeBuildTicks();\n\t\t\tme.buildTicks();\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\t\t\tme.convertTicksToLabels();\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation;\n\t\t\t\tvar sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += scaleLabelFontSize;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += scaleLabelFontSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * tallestLabelHeightInLines);\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\n\t\t\t\t\tvar firstTick = me.ticks[0];\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\n\n\t\t\t\t\tvar lastTick = me.ticks[me.ticks.length - 1];\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n\t\t\t\t\t// by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n\t\t\t\t\t// Account for padding\n\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlargestTextWidth += me.options.ticks.padding;\n\t\t\t\t\t}\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (rawValue === null || typeof(rawValue) === 'undefined') {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (typeof(rawValue) === 'object') {\n\t\t\t\tif ((rawValue instanceof Date) || (rawValue.isValid)) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t}\n\t\t\t\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t// Used to get the value to display in the tooltip for the data at the given index\n\t\t// function getLabelForIndex(index, datasetIndex)\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t// Used for tick location, should\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (includeOffset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));\n\t\t},\n\n\t\t// Utility for getting the pixel location of a percentage of scale\n\t\tgetPixelForDecimal: function(decimal /* , includeOffset*/) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\tvar optionTicks = options.ticks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar skipRatio;\n\t\t\tvar useAutoskipper = optionTicks.autoSkip;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\t\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\n\t\t\t// Make sure we draw text in the correct color and font\n\t\t\tcontext.fillStyle = tickFontColor;\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && me.ticks.length > maxTicks) {\n\t\t\t\t\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n\t\t\t\t\t\tif (!skipRatio) {\n\t\t\t\t\t\t\tskipRatio = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tskipRatio += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!useAutoskipper) {\n\t\t\t\t\tskipRatio = false;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n\n\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t// If the callback returned a null or undefined value, do not draw this line\n\t\t\t\tif (label === undefined || label === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar isLastTick = me.ticks.length === index + 1;\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\n\t\t\t\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\tborderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\n\t\t\t\tif (isHorizontal) {\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated? 'top':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'right';\n\t\t\t\t\t\tlabelY = me.top + tl;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated? 'bottom':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'left';\n\t\t\t\t\t\tlabelY = me.bottom - tl;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n\t\t\t\t\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar tickPadding = optionTicks.padding;\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\t\t\t\t\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = tickFont.font;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tfor (var i = 0, y = 0; i < label.length; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += (tickFont.size * 1.5);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left,\n\t\t\t\t\tx2 = me.right,\n\t\t\t\t\ty1 = me.top,\n\t\t\t\t\ty2 = me.bottom;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 932:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, defaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers.clone(defaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar defaults = this.defaults;\n\t\t\tif (defaults.hasOwnProperty(type)) {\n\t\t\t\tdefaults[type] = helpers.extend(defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chart) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers.each(chart.scales, function(scale) {\n\t\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\t\tscale.position = scale.options.position;\n\t\t\t\tscale.weight = scale.options.weight;\n\t\t\t\tChart.layoutService.addBox(chart, scale);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 933:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Namespace to hold static tick generation functions\n\t * @namespace Chart.Ticks\n\t */\n\tChart.Ticks = {\n\t\t/**\n\t\t * Namespace to hold generators for different types of ticks\n\t\t * @namespace Chart.Ticks.generators\n\t\t */\n\t\tgenerators: {\n\t\t\t/**\n\t\t\t * Interface for the options provided to the numeric tick generator\n\t\t\t * @interface INumericTickGenerationOptions\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum number of ticks to display\n\t\t\t * @name INumericTickGenerationOptions#maxTicks\n\t\t\t * @type Number\n\t\t\t */\n\t\t\t/**\n\t\t\t * The distance between each tick.\n\t\t\t * @name INumericTickGenerationOptions#stepSize\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n\t\t\t * @name INumericTickGenerationOptions#min\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n\t\t\t * @name INumericTickGenerationOptions#max\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\n\t\t\t/**\n\t\t\t * Generate a set of linear ticks\n\t\t\t * @method Chart.Ticks.generators.linear\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlinear: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t\t// for details.\n\n\t\t\t\tvar spacing;\n\t\t\t\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\t\t\t\tspacing = generationOptions.stepSize;\n\t\t\t\t} else {\n\t\t\t\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\t\t\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t\t\t\t}\n\t\t\t\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\t\t\t\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t\t\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\t\t\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t\t\t\t// If very close to our whole number, use it.\n\t\t\t\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\t\t\t\tniceMin = generationOptions.min;\n\t\t\t\t\t\tniceMax = generationOptions.max;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\t\t\t// If very close to our rounded value, use it.\n\t\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t\t}\n\n\t\t\t\t// Put the values into the ticks array\n\t\t\t\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\t\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\t\tticks.push(niceMin + (j * spacing));\n\t\t\t\t}\n\t\t\t\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\t\t\t\treturn ticks;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Generate a set of logarithmic ticks\n\t\t\t * @method Chart.Ticks.generators.logarithmic\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlogarithmic: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t// the graph\n\t\t\t\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\t\t\t\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\t\t\t\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\t\t\tvar exp;\n\t\t\t\tvar significand;\n\n\t\t\t\tif (tickVal === 0) {\n\t\t\t\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\t\t\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\t\t\t\tticks.push(tickVal);\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} else {\n\t\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tticks.push(tickVal);\n\n\t\t\t\t\t++significand;\n\t\t\t\t\tif (significand === 10) {\n\t\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t\t++exp;\n\t\t\t\t\t}\n\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\t\t\t\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\n\t\t\t\tticks.push(lastTick);\n\n\t\t\t\treturn ticks;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Namespace to hold formatters for different types of ticks\n\t\t * @namespace Chart.Ticks.formatters\n\t\t */\n\t\tformatters: {\n\t\t\t/**\n\t\t\t * Formatter for value labels\n\t\t\t * @method Chart.Ticks.formatters.values\n\t\t\t * @param value the value to display\n\t\t\t * @return {String|Array} the label to display\n\t\t\t */\n\t\t\tvalues: function(value) {\n\t\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Formatter for linear numeric ticks\n\t\t\t * @method Chart.Ticks.formatters.linear\n\t\t\t * @param tickValue {Number} the value to be formatted\n\t\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t\t * @return {String} string representation of the tickValue parameter\n\t\t\t */\n\t\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\t\tvar tickString = '';\n\n\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t} else {\n\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t}\n\n\t\t\t\treturn tickString;\n\t\t\t},\n\n\t\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\t\tif (tickValue === 0) {\n\t\t\t\t\treturn '0';\n\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\t\treturn tickValue.toExponential();\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 934:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t/**\n \t * Helper method to merge the opacity into a color\n \t */\n\tfunction mergeOpacity(colorString, opacity) {\n\t\tvar color = helpers.color(colorString);\n\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t}\n\n\tChart.defaults.global.tooltips = {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tafterLabel: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers.noop,\n\t\t\tfooter: helpers.noop,\n\t\t\tafterFooter: helpers.noop\n\t\t}\n\t};\n\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\n\t\treturn base;\n\t}\n\n\t// Private helper to create a tooltip item model\n\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t// @return : new tooltip item\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index,\n\t\t\tdatasetIndex = element._datasetIndex;\n\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {Object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors,\n\t\t\tborderColor: tooltipOpts.borderColor,\n\t\t\tborderWidth: tooltipOpts.borderWidth\n\t\t};\n\t}\n\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize,\n\t\t\tbodyFontSize = model.bodyFontSize,\n\t\t\tfooterFontSize = model.footerFontSize;\n\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\n\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t// Body width\n\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers.each(body, function(bodyItem) {\n\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t});\n\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\n\t\t// Footer width\n\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chart.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\n\t\tolf = function(x) {\n\t\t\treturn x + size.width > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\n\t/**\n\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\n\t\tvar caretSize = vm.caretSize,\n\t\t\tcaretPadding = vm.caretPadding,\n\t\t\tcornerRadius = vm.cornerRadius,\n\t\t\txAlign = alignment.xAlign,\n\t\t\tyAlign = alignment.yAlign,\n\t\t\tpaddingAndSize = caretSize + caretPadding,\n\t\t\tradiusAndPadding = cornerRadius + caretPadding;\n\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t}\n\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\tChart.Tooltip = Chart.Element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t},\n\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),\n\t\t\t\ttitle = callbacks.title.apply(me, arguments),\n\t\t\t\tafterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\tlines = pushOrConcat(lines, title);\n\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\n\t\t\treturn bodyItems;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\n\t\t\tvar data = me._data;\n\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\n\t\t\tvar i, len;\n\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\tvar labelColors = [];\n\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\n\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\t});\n\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\t\tmodel.labelColors = labelColors;\n\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\tme._model = model;\n\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\t\tdrawCaret: function(tooltipPoint, size) {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\n\t\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t},\n\t\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\t\tvar x1, x2, x3;\n\t\t\tvar y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign,\n\t\t\t\tyAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x,\n\t\t\t\tptY = tooltipPoint.y;\n\t\t\tvar width = size.width,\n\t\t\t\theight = size.height;\n\n\t\t\tif (yAlign === 'center') {\n\t\t\t\ty2 = ptY + (height / 2);\n\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\t\ty3 = y2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = ptX + (width / 2);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t\t// invert drawing order\n\t\t\t\t\tvar tmp = x3;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t\t},\n\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\tvar title = vm.title;\n\n\t\t\tif (title.length) {\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tvar titleFontSize = vm.titleFontSize,\n\t\t\t\t\ttitleSpacing = vm.titleSpacing;\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar body = vm.body;\n\n\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\n\t\t\tvar textColor = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\tctx.fillStyle = textColor;\n\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t// Before Body\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\n\t\t\t// Before body lines\n\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\n\t\t\t// Draw body lines now\n\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\n\t\t\t// After body lines\n\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\tvar footer = vm.footer;\n\n\t\t\tif (footer.length) {\n\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\tctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);\n\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar x = pt.x;\n\t\t\tvar y = pt.y;\n\t\t\tvar width = tooltipSize.width;\n\t\t\tvar height = tooltipSize.height;\n\t\t\tvar radius = vm.cornerRadius;\n\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tif (yAlign === 'top') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tif (yAlign === 'bottom') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\n\t\t\tctx.fill();\n\n\t\t\tif (vm.borderWidth > 0) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\t// Truthy/falsey value for empty tooltip\n\t\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n\t\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {Boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\n\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\n\t\t\t// If tooltip didn't change, do not handle the target event\n\t\t\tif (!changed) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tme._lastActive = me._active;\n\n\t\t\tif (options.enabled || options.custom) {\n\t\t\t\tme._eventPosition = {\n\t\t\t\t\tx: e.x,\n\t\t\t\t\ty: e.y\n\t\t\t\t};\n\n\t\t\t\tvar model = me._model;\n\t\t\t\tme.update(true);\n\t\t\t\tme.pivot();\n\n\t\t\t\t// See if our tooltip position changed\n\t\t\t\tchanged |= (model.x !== me._model.x) || (model.y !== me._model.y);\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tChart.Tooltip.positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {Point} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / count),\n\t\t\t\ty: Math.round(y / count)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {Point} the position of the event in canvas coordinates\n\t\t * @returns {Point} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\n\t\t\tvar nearestElement;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len;\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 935:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tglobalOpts = Chart.defaults.global;\n\n\tglobalOpts.elements.arc = {\n\t\tbackgroundColor: globalOpts.defaultColor,\n\t\tborderColor: '#fff',\n\t\tborderWidth: 2\n\t};\n\n\tChart.elements.Arc = Chart.Element.extend({\n\t\tinLabelRange: function(mouseX) {\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm) {\n\t\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tinRange: function(chartX, chartY) {\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm) {\n\t\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {\n\t\t\t\t\t\tx: chartX,\n\t\t\t\t\t\ty: chartY\n\t\t\t\t\t}),\n\t\t\t\t\tangle = pointRelativePosition.angle,\n\t\t\t\t\tdistance = pointRelativePosition.distance;\n\n\t\t\t\t// Sanitise angle range\n\t\t\t\tvar startAngle = vm.startAngle;\n\t\t\t\tvar endAngle = vm.endAngle;\n\t\t\t\twhile (endAngle < startAngle) {\n\t\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle > endAngle) {\n\t\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle < startAngle) {\n\t\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\t// Check if within the range of the open/close angle\n\t\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle),\n\t\t\t\t\twithinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\t\treturn (betweenAngles && withinRadius);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\t\treturn {\n\t\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t\t};\n\t\t},\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\n\t\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\n\t\t\t\trangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\t\t\treturn {\n\t\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t\t};\n\t\t},\n\t\tdraw: function() {\n\n\t\t\tvar ctx = this._chart.ctx,\n\t\t\t\tvm = this._view,\n\t\t\t\tsA = vm.startAngle,\n\t\t\t\teA = vm.endAngle;\n\n\t\t\tctx.beginPath();\n\n\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\t\tctx.closePath();\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = vm.borderWidth;\n\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\t\tctx.fill();\n\t\t\tctx.lineJoin = 'bevel';\n\n\t\t\tif (vm.borderWidth) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 936:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tChart.defaults.global.elements.line = {\n\t\ttension: 0.4,\n\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\tborderWidth: 3,\n\t\tborderColor: globalDefaults.defaultColor,\n\t\tborderCapStyle: 'butt',\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0,\n\t\tborderJoinStyle: 'miter',\n\t\tcapBezierPoints: true,\n\t\tfill: true, // do we fill in the area between the line and its base axis\n\t};\n\n\tChart.elements.Line = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar vm = me._view;\n\t\t\tvar ctx = me._chart.ctx;\n\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\tvar points = me._children.slice(); // clone array\n\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\tvar lastDrawnIndex = -1;\n\t\t\tvar index, current, previous, currentVM;\n\n\t\t\t// If we are looping, adding the first point again\n\t\t\tif (me._loop && points.length) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\tctx.save();\n\n\t\t\t// Stroke Line Options\n\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t\t// IE 9 and 10 do not support line dash\n\t\t\tif (ctx.setLineDash) {\n\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t}\n\n\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t\t// Stroke Line\n\t\t\tctx.beginPath();\n\t\t\tlastDrawnIndex = -1;\n\n\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\tcurrent = points[index];\n\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\thelpers.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 937:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tglobalOpts = Chart.defaults.global,\n\t\tdefaultColor = globalOpts.defaultColor;\n\n\tglobalOpts.elements.point = {\n\t\tradius: 3,\n\t\tpointStyle: 'circle',\n\t\tbackgroundColor: defaultColor,\n\t\tborderWidth: 1,\n\t\tborderColor: defaultColor,\n\t\t// Hover\n\t\thitRadius: 1,\n\t\thoverRadius: 4,\n\t\thoverBorderWidth: 1\n\t};\n\n\tfunction xRange(mouseX) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n\t}\n\n\tfunction yRange(mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n\t}\n\n\tChart.elements.Point = Chart.Element.extend({\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t\t},\n\n\t\tinLabelRange: xRange,\n\t\tinXRange: xRange,\n\t\tinYRange: yRange,\n\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t},\n\t\tgetArea: function() {\n\t\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y,\n\t\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t\t};\n\t\t},\n\t\tdraw: function(chartArea) {\n\t\t\tvar vm = this._view;\n\t\t\tvar model = this._model;\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar pointStyle = vm.pointStyle;\n\t\t\tvar radius = vm.radius;\n\t\t\tvar x = vm.x;\n\t\t\tvar y = vm.y;\n\t\t\tvar color = Chart.helpers.color;\n\t\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\t\tvar ratio = 0;\n\n\t\t\tif (vm.skip) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\t\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\n\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t\t// Cliping for Points.\n\t\t\t// going out from inner charArea?\n\t\t\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {\n\t\t\t\t// Point fade out\n\t\t\t\tif (model.x < chartArea.left) {\n\t\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t\t} else if (chartArea.right*errMargin < model.x) {\n\t\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t\t} else if (chartArea.bottom*errMargin < model.y) {\n\t\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t\t}\n\t\t\t\tratio = Math.round(ratio*100) / 100;\n\t\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t\t}\n\n\t\t\tChart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 938:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar globalOpts = Chart.defaults.global;\n\n\tglobalOpts.elements.rectangle = {\n\t\tbackgroundColor: globalOpts.defaultColor,\n\t\tborderWidth: 0,\n\t\tborderColor: globalOpts.defaultColor,\n\t\tborderSkipped: 'bottom'\n\t};\n\n\tfunction isVertical(bar) {\n\t\treturn bar._view.width !== undefined;\n\t}\n\n\t/**\n\t * Helper function to get the bounds of the bar regardless of the orientation\n\t * @private\n\t * @param bar {Chart.Element.Rectangle} the bar\n\t * @return {Bounds} bounds of the bar\n\t */\n\tfunction getBarBounds(bar) {\n\t\tvar vm = bar._view;\n\t\tvar x1, x2, y1, y2;\n\n\t\tif (isVertical(bar)) {\n\t\t\t// vertical\n\t\t\tvar halfWidth = vm.width / 2;\n\t\t\tx1 = vm.x - halfWidth;\n\t\t\tx2 = vm.x + halfWidth;\n\t\t\ty1 = Math.min(vm.y, vm.base);\n\t\t\ty2 = Math.max(vm.y, vm.base);\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tvar halfHeight = vm.height / 2;\n\t\t\tx1 = Math.min(vm.x, vm.base);\n\t\t\tx2 = Math.max(vm.x, vm.base);\n\t\t\ty1 = vm.y - halfHeight;\n\t\t\ty2 = vm.y + halfHeight;\n\t\t}\n\n\t\treturn {\n\t\t\tleft: x1,\n\t\t\ttop: y1,\n\t\t\tright: x2,\n\t\t\tbottom: y2\n\t\t};\n\t}\n\n\tChart.elements.Rectangle = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\t\tvar borderWidth = vm.borderWidth;\n\n\t\t\tif (!vm.horizontal) {\n\t\t\t\t// bar\n\t\t\t\tleft = vm.x - vm.width / 2;\n\t\t\t\tright = vm.x + vm.width / 2;\n\t\t\t\ttop = vm.y;\n\t\t\t\tbottom = vm.base;\n\t\t\t\tsignX = 1;\n\t\t\t\tsignY = bottom > top? 1: -1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t\t} else {\n\t\t\t\t// horizontal bar\n\t\t\t\tleft = vm.base;\n\t\t\t\tright = vm.x;\n\t\t\t\ttop = vm.y - vm.height / 2;\n\t\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\t\tsignX = right > left? 1: -1;\n\t\t\t\tsignY = 1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t\t}\n\n\t\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\t\tif (borderWidth) {\n\t\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\t\tborderWidth = borderWidth > barSize? barSize: borderWidth;\n\t\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\t\tvar borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);\n\t\t\t\tvar borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);\n\t\t\t\tvar borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);\n\t\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);\n\t\t\t\t// not become a vertical line?\n\t\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\t\ttop = borderTop;\n\t\t\t\t\tbottom = borderBottom;\n\t\t\t\t}\n\t\t\t\t// not become a horizontal line?\n\t\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\t\tleft = borderLeft;\n\t\t\t\t\tright = borderRight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = borderWidth;\n\n\t\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t\t// | 1 2 |\n\t\t\t// | 0 3 |\n\t\t\tvar corners = [\n\t\t\t\t[left, bottom],\n\t\t\t\t[left, top],\n\t\t\t\t[right, top],\n\t\t\t\t[right, bottom]\n\t\t\t];\n\n\t\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\t\tif (startCorner === -1) {\n\t\t\t\tstartCorner = 0;\n\t\t\t}\n\n\t\t\tfunction cornerAt(index) {\n\t\t\t\treturn corners[(startCorner + index) % 4];\n\t\t\t}\n\n\t\t\t// Draw rectangle from 'startCorner'\n\t\t\tvar corner = cornerAt(0);\n\t\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\t\tfor (var i = 1; i < 4; i++) {\n\t\t\t\tcorner = cornerAt(i);\n\t\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t\t}\n\n\t\t\tctx.fill();\n\t\t\tif (borderWidth) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\theight: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.base - vm.y;\n\t\t},\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar inRange = false;\n\n\t\t\tif (this._view) {\n\t\t\t\tvar bounds = getBarBounds(this);\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinLabelRange: function(mouseX, mouseY) {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar inRange = false;\n\t\t\tvar bounds = getBarBounds(me);\n\n\t\t\tif (isVertical(me)) {\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t\t} else {\n\t\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinXRange: function(mouseX) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t},\n\t\tinYRange: function(mouseY) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t},\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar x, y;\n\t\t\tif (isVertical(this)) {\n\t\t\t\tx = vm.x;\n\t\t\t\ty = (vm.y + vm.base) / 2;\n\t\t\t} else {\n\t\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\t\ty = vm.y;\n\t\t\t}\n\n\t\t\treturn {x: x, y: y};\n\t\t},\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t}\n\t});\n\n};\n\n\n/***/ }),\n\n/***/ 939:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Chart.Platform implementation for targeting a web browser\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\n\t// DOM event types -> Chart.js event types.\n\t// Note: only events with different types are mapped.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events\n\tvar eventTypeMap = {\n\t\t// Touch events\n\t\ttouchstart: 'mousedown',\n\t\ttouchmove: 'mousemove',\n\t\ttouchend: 'mouseup',\n\n\t\t// Pointer events\n\t\tpointerenter: 'mouseenter',\n\t\tpointerdown: 'mousedown',\n\t\tpointermove: 'mousemove',\n\t\tpointerup: 'mouseup',\n\t\tpointerleave: 'mouseout',\n\t\tpointerout: 'mouseout'\n\t};\n\n\t/**\n\t * The \"used\" size is the final value of a dimension property after all calculations have\n\t * been performed. This method uses the computed style of `element` but returns undefined\n\t * if the computed style is not expressed in pixels. That can happen in some cases where\n\t * `element` has a size relative to its parent and this last one is not yet displayed,\n\t * for example because of `display: none` on a parent node.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n\t * @returns {Number} Size in pixels or undefined if unknown.\n\t */\n\tfunction readUsedSize(element, property) {\n\t\tvar value = helpers.getStyle(element, property);\n\t\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\t\treturn matches? Number(matches[1]) : undefined;\n\t}\n\n\t/**\n\t * Initializes the canvas style and render size without modifying the canvas display size,\n\t * since responsiveness is handled by the controller.resize() method. The config is used\n\t * to determine the aspect ratio to apply in case no explicit height has been specified.\n\t */\n\tfunction initCanvas(canvas, config) {\n\t\tvar style = canvas.style;\n\n\t\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\t\tvar renderHeight = canvas.getAttribute('height');\n\t\tvar renderWidth = canvas.getAttribute('width');\n\n\t\t// Chart.js modifies some canvas values that we want to restore on destroy\n\t\tcanvas._chartjs = {\n\t\t\tinitial: {\n\t\t\t\theight: renderHeight,\n\t\t\t\twidth: renderWidth,\n\t\t\t\tstyle: {\n\t\t\t\t\tdisplay: style.display,\n\t\t\t\t\theight: style.height,\n\t\t\t\t\twidth: style.width\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Force canvas to display as block to avoid extra space caused by inline\n\t\t// elements, which would interfere with the responsive resize process.\n\t\t// https://github.com/chartjs/Chart.js/issues/2538\n\t\tstyle.display = style.display || 'block';\n\n\t\tif (renderWidth === null || renderWidth === '') {\n\t\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.width = displayWidth;\n\t\t\t}\n\t\t}\n\n\t\tif (renderHeight === null || renderHeight === '') {\n\t\t\tif (canvas.style.height === '') {\n\t\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t\t} else {\n\t\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\t\tif (displayWidth !== undefined) {\n\t\t\t\t\tcanvas.height = displayHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn canvas;\n\t}\n\n\tfunction createEvent(type, chart, x, y, nativeEvent) {\n\t\treturn {\n\t\t\ttype: type,\n\t\t\tchart: chart,\n\t\t\tnative: nativeEvent || null,\n\t\t\tx: x !== undefined? x : null,\n\t\t\ty: y !== undefined? y : null,\n\t\t};\n\t}\n\n\tfunction fromNativeEvent(event, chart) {\n\t\tvar type = eventTypeMap[event.type] || event.type;\n\t\tvar pos = helpers.getRelativePosition(event, chart);\n\t\treturn createEvent(type, chart, pos.x, pos.y, event);\n\t}\n\n\tfunction createResizer(handler) {\n\t\tvar iframe = document.createElement('iframe');\n\t\tiframe.className = 'chartjs-hidden-iframe';\n\t\tiframe.style.cssText =\n\t\t\t'display:block;'+\n\t\t\t'overflow:hidden;'+\n\t\t\t'border:0;'+\n\t\t\t'margin:0;'+\n\t\t\t'top:0;'+\n\t\t\t'left:0;'+\n\t\t\t'bottom:0;'+\n\t\t\t'right:0;'+\n\t\t\t'height:100%;'+\n\t\t\t'width:100%;'+\n\t\t\t'position:absolute;'+\n\t\t\t'pointer-events:none;'+\n\t\t\t'z-index:-1;';\n\n\t\t// Prevent the iframe to gain focus on tab.\n\t\t// https://github.com/chartjs/Chart.js/issues/3090\n\t\tiframe.tabIndex = -1;\n\n\t\t// If the iframe is re-attached to the DOM, the resize listener is removed because the\n\t\t// content is reloaded, so make sure to install the handler after the iframe is loaded.\n\t\t// https://github.com/chartjs/Chart.js/issues/3521\n\t\thelpers.addEvent(iframe, 'load', function() {\n\t\t\thelpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);\n\n\t\t\t// The iframe size might have changed while loading, which can also\n\t\t\t// happen if the size has been changed while detached from the DOM.\n\t\t\thandler();\n\t\t});\n\n\t\treturn iframe;\n\t}\n\n\tfunction addResizeListener(node, listener, chart) {\n\t\tvar stub = node._chartjs = {\n\t\t\tticking: false\n\t\t};\n\n\t\t// Throttle the callback notification until the next animation frame.\n\t\tvar notify = function() {\n\t\t\tif (!stub.ticking) {\n\t\t\t\tstub.ticking = true;\n\t\t\t\thelpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tif (stub.resizer) {\n\t\t\t\t\t\tstub.ticking = false;\n\t\t\t\t\t\treturn listener(createEvent('resize', chart));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// Let's keep track of this added iframe and thus avoid DOM query when removing it.\n\t\tstub.resizer = createResizer(notify);\n\n\t\tnode.insertBefore(stub.resizer, node.firstChild);\n\t}\n\n\tfunction removeResizeListener(node) {\n\t\tif (!node || !node._chartjs) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar resizer = node._chartjs.resizer;\n\t\tif (resizer) {\n\t\t\tresizer.parentNode.removeChild(resizer);\n\t\t\tnode._chartjs.resizer = null;\n\t\t}\n\n\t\tdelete node._chartjs;\n\t}\n\n\treturn {\n\t\tacquireContext: function(item, config) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.getElementById(item);\n\t\t\t} else if (item.length) {\n\t\t\t\t// Support for array based queries (such as jQuery)\n\t\t\t\titem = item[0];\n\t\t\t}\n\n\t\t\tif (item && item.canvas) {\n\t\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\t\titem = item.canvas;\n\t\t\t}\n\n\t\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\tvar context = item && item.getContext && item.getContext('2d');\n\n\t\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\t\tif (context && context.canvas === item) {\n\t\t\t\tinitCanvas(item, config);\n\t\t\t\treturn context;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\treleaseContext: function(context) {\n\t\t\tvar canvas = context.canvas;\n\t\t\tif (!canvas._chartjs) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar initial = canvas._chartjs.initial;\n\t\t\t['height', 'width'].forEach(function(prop) {\n\t\t\t\tvar value = initial[prop];\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t\t} else {\n\t\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(initial.style || {}, function(value, key) {\n\t\t\t\tcanvas.style[key] = value;\n\t\t\t});\n\n\t\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\t\tcanvas.width = canvas.width;\n\n\t\t\tdelete canvas._chartjs;\n\t\t},\n\n\t\taddEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\taddResizeListener(canvas.parentNode, listener, chart);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stub = listener._chartjs || (listener._chartjs = {});\n\t\t\tvar proxies = stub.proxies || (stub.proxies = {});\n\t\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t\t};\n\n\t\t\thelpers.addEvent(canvas, type, proxy);\n\t\t},\n\n\t\tremoveEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\tremoveResizeListener(canvas.parentNode, listener);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stub = listener._chartjs || {};\n\t\t\tvar proxies = stub.proxies || {};\n\t\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\t\tif (!proxy) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thelpers.removeEvent(canvas, type, proxy);\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 940:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// By default, select the browser (DOM) platform.\n// @TODO Make possible to select another platform at build time.\nvar implementation = __webpack_require__(939);\n\nmodule.exports = function(Chart) {\n\t/**\n\t * @namespace Chart.platform\n\t * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n\t * @since 2.4.0\n\t */\n\tChart.platform = {\n\t\t/**\n\t\t * Called at chart construction time, returns a context2d instance implementing\n\t\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t\t * @param {Object} options - The chart options\n\t\t * @returns {CanvasRenderingContext2D} context2d instance\n\t\t */\n\t\tacquireContext: function() {},\n\n\t\t/**\n\t\t * Called at chart destruction time, releases any resources associated to the context\n\t\t * previously returned by the acquireContext() method.\n\t\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t\t * @returns {Boolean} true if the method succeeded, else false\n\t\t */\n\t\treleaseContext: function() {},\n\n\t\t/**\n\t\t * Registers the specified listener on the given chart.\n\t\t * @param {Chart} chart - Chart from which to listen for event\n\t\t * @param {String} type - The ({@link IEvent}) type to listen for\n\t\t * @param {Function} listener - Receives a notification (an object that implements\n\t\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t\t */\n\t\taddEventListener: function() {},\n\n\t\t/**\n\t\t * Removes the specified listener previously registered with addEventListener.\n\t\t * @param {Chart} chart -Chart from which to remove the listener\n\t\t * @param {String} type - The ({@link IEvent}) type to remove\n\t\t * @param {Function} listener - The listener function to remove from the event target.\n\t\t */\n\t\tremoveEventListener: function() {}\n\t};\n\n\t/**\n\t * @interface IPlatform\n\t * Allows abstracting platform dependencies away from the chart\n\t * @borrows Chart.platform.acquireContext as acquireContext\n\t * @borrows Chart.platform.releaseContext as releaseContext\n\t * @borrows Chart.platform.addEventListener as addEventListener\n\t * @borrows Chart.platform.removeEventListener as removeEventListener\n\t */\n\n\t/**\n\t * @interface IEvent\n\t * @prop {String} type - The event type name, possible values are:\n\t * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n\t * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n\t * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n\t * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n\t * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n\t */\n\n\tChart.helpers.extend(Chart.platform, implementation(Chart));\n};\n\n\n/***/ }),\n\n/***/ 941:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\t/**\n\t * Plugin based on discussion from the following Chart.js issues:\n\t * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n\t * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n\t */\n\tChart.defaults.global.plugins.filler = {\n\t\tpropagate: true\n\t};\n\n\tvar defaults = Chart.defaults;\n\tvar helpers = Chart.helpers;\n\tvar mappers = {\n\t\tdataset: function(source) {\n\t\t\tvar index = source.fill;\n\t\t\tvar chart = source.chart;\n\t\t\tvar meta = chart.getDatasetMeta(index);\n\t\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\t\tvar points = (visible && meta.dataset._children) || [];\n\n\t\t\treturn !points.length? null : function(point, i) {\n\t\t\t\treturn points[i]._view || null;\n\t\t\t};\n\t\t},\n\n\t\tboundary: function(source) {\n\t\t\tvar boundary = source.boundary;\n\t\t\tvar x = boundary? boundary.x : null;\n\t\t\tvar y = boundary? boundary.y : null;\n\n\t\t\treturn function(point) {\n\t\t\t\treturn {\n\t\t\t\t\tx: x === null? point.x : x,\n\t\t\t\t\ty: y === null? point.y : y,\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\t};\n\n\t// @todo if (fill[0] === '#')\n\tfunction decodeFill(el, index, count) {\n\t\tvar model = el._model || {};\n\t\tvar fill = model.fill;\n\t\tvar target;\n\n\t\tif (fill === undefined) {\n\t\t\tfill = !!model.backgroundColor;\n\t\t}\n\n\t\tif (fill === false || fill === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fill === true) {\n\t\t\treturn 'origin';\n\t\t}\n\n\t\ttarget = parseFloat(fill, 10);\n\t\tif (isFinite(target) && Math.floor(target) === target) {\n\t\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\t\ttarget = index + target;\n\t\t\t}\n\n\t\t\tif (target === index || target < 0 || target >= count) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\tswitch (fill) {\n\t\t// compatibility\n\t\tcase 'bottom':\n\t\t\treturn 'start';\n\t\tcase 'top':\n\t\t\treturn 'end';\n\t\tcase 'zero':\n\t\t\treturn 'origin';\n\t\t// supported boundaries\n\t\tcase 'origin':\n\t\tcase 'start':\n\t\tcase 'end':\n\t\t\treturn fill;\n\t\t// invalid fill values\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction computeBoundary(source) {\n\t\tvar model = source.el._model || {};\n\t\tvar scale = source.el._scale || {};\n\t\tvar fill = source.fill;\n\t\tvar target = null;\n\t\tvar horizontal;\n\n\t\tif (isFinite(fill)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t\t// controllers might still use it (e.g. the Smith chart).\n\n\t\tif (fill === 'start') {\n\t\t\ttarget = model.scaleBottom === undefined? scale.bottom : model.scaleBottom;\n\t\t} else if (fill === 'end') {\n\t\t\ttarget = model.scaleTop === undefined? scale.top : model.scaleTop;\n\t\t} else if (model.scaleZero !== undefined) {\n\t\t\ttarget = model.scaleZero;\n\t\t} else if (scale.getBasePosition) {\n\t\t\ttarget = scale.getBasePosition();\n\t\t} else if (scale.getBasePixel) {\n\t\t\ttarget = scale.getBasePixel();\n\t\t}\n\n\t\tif (target !== undefined && target !== null) {\n\t\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\t\thorizontal = scale.isHorizontal();\n\t\t\t\treturn {\n\t\t\t\t\tx: horizontal? target : null,\n\t\t\t\t\ty: horizontal? null : target\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction resolveTarget(sources, index, propagate) {\n\t\tvar source = sources[index];\n\t\tvar fill = source.fill;\n\t\tvar visited = [index];\n\t\tvar target;\n\n\t\tif (!propagate) {\n\t\t\treturn fill;\n\t\t}\n\n\t\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\t\tif (!isFinite(fill)) {\n\t\t\t\treturn fill;\n\t\t\t}\n\n\t\t\ttarget = sources[fill];\n\t\t\tif (!target) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (target.visible) {\n\t\t\t\treturn fill;\n\t\t\t}\n\n\t\t\tvisited.push(fill);\n\t\t\tfill = target.fill;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction createMapper(source) {\n\t\tvar fill = source.fill;\n\t\tvar type = 'dataset';\n\n\t\tif (fill === false) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!isFinite(fill)) {\n\t\t\ttype = 'boundary';\n\t\t}\n\n\t\treturn mappers[type](source);\n\t}\n\n\tfunction isDrawable(point) {\n\t\treturn point && !point.skip;\n\t}\n\n\tfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\t\tvar i;\n\n\t\tif (!len0 || !len1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// building first area curve (normal)\n\t\tctx.moveTo(curve0[0].x, curve0[0].y);\n\t\tfor (i=1; i<len0; ++i) {\n\t\t\thelpers.canvas.lineTo(ctx, curve0[i-1], curve0[i]);\n\t\t}\n\n\t\t// joining the two area curves\n\t\tctx.lineTo(curve1[len1-1].x, curve1[len1-1].y);\n\n\t\t// building opposite area curve (reverse)\n\t\tfor (i=len1-1; i>0; --i) {\n\t\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i-1], true);\n\t\t}\n\t}\n\n\tfunction doFill(ctx, points, mapper, view, color, loop) {\n\t\tvar count = points.length;\n\t\tvar span = view.spanGaps;\n\t\tvar curve0 = [];\n\t\tvar curve1 = [];\n\t\tvar len0 = 0;\n\t\tvar len1 = 0;\n\t\tvar i, ilen, index, p0, p1, d0, d1;\n\n\t\tctx.beginPath();\n\n\t\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\t\tindex = i%count;\n\t\t\tp0 = points[index]._view;\n\t\t\tp1 = mapper(p0, index, view);\n\t\t\td0 = isDrawable(p0);\n\t\t\td1 = isDrawable(p1);\n\n\t\t\tif (d0 && d1) {\n\t\t\t\tlen0 = curve0.push(p0);\n\t\t\t\tlen1 = curve1.push(p1);\n\t\t\t} else if (len0 && len1) {\n\t\t\t\tif (!span) {\n\t\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\t\tlen0 = len1 = 0;\n\t\t\t\t\tcurve0 = [];\n\t\t\t\t\tcurve1 = [];\n\t\t\t\t} else {\n\t\t\t\t\tif (d0) {\n\t\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t\t}\n\t\t\t\t\tif (d1) {\n\t\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\t\tctx.closePath();\n\t\tctx.fillStyle = color;\n\t\tctx.fill();\n\t}\n\n\treturn {\n\t\tid: 'filler',\n\n\t\tafterDatasetsUpdate: function(chart, options) {\n\t\t\tvar count = (chart.data.datasets || []).length;\n\t\t\tvar propagate = options.propagate;\n\t\t\tvar sources = [];\n\t\t\tvar meta, i, el, source;\n\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tel = meta.dataset;\n\t\t\t\tsource = null;\n\n\t\t\t\tif (el && el._model && el instanceof Chart.elements.Line) {\n\t\t\t\t\tsource = {\n\t\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\t\tchart: chart,\n\t\t\t\t\t\tel: el\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tmeta.$filler = source;\n\t\t\t\tsources.push(source);\n\t\t\t}\n\n\t\t\tfor (i=0; i<count; ++i) {\n\t\t\t\tsource = sources[i];\n\t\t\t\tif (!source) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\t\tsource.boundary = computeBoundary(source);\n\t\t\t\tsource.mapper = createMapper(source);\n\t\t\t}\n\t\t},\n\n\t\tbeforeDatasetDraw: function(chart, args) {\n\t\t\tvar meta = args.meta.$filler;\n\t\t\tif (!meta) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar el = meta.el;\n\t\t\tvar view = el._view;\n\t\t\tvar points = el._children || [];\n\t\t\tvar mapper = meta.mapper;\n\t\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\t\tif (mapper && color && points.length) {\n\t\t\t\tdoFill(chart.ctx, points, mapper, view, color, el._loop);\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 942:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar layout = Chart.layoutService;\n\tvar noop = helpers.noop;\n\n\tChart.defaults.global.legend = {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Helper function to get the box width based on the usePointStyle option\n\t * @param labelopts {Object} the label options on the legend\n\t * @param fontSize {Number} the label font size\n\t * @return {Number} width of the color box area\n\t */\n\tfunction getBoxWidth(labelOpts, fontSize) {\n\t\treturn labelOpts.usePointStyle ?\n\t\t\tfontSize * Math.SQRT2 :\n\t\t\tlabelOpts.boxWidth;\n\t}\n\n\tChart.Legend = Chart.Element.extend({\n\n\t\tinitialize: function(config) {\n\t\t\thelpers.extend(this, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tthis.legendHitBoxes = [];\n\n\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\tthis.doughnutMode = false;\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\t// Any function defined here is inherited by all legend types.\n\t\t// Any function can be extended by the legend type\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: function() {\n\t\t\tvar me = this;\n\t\t\tvar labelOpts = me.options.labels;\n\t\t\tvar legendItems = labelOpts.generateLabels.call(me, me.chart);\n\n\t\t\tif (labelOpts.filter) {\n\t\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (me.options.reverse) {\n\t\t\t\tlegendItems.reverse();\n\t\t\t}\n\n\t\t\tme.legendItems = legendItems;\n\t\t},\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar display = opts.display;\n\n\t\t\tvar ctx = me.ctx;\n\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t// Reset hit boxes\n\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\t\tvar minSize = me.minSize;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Increase sizes here\n\t\t\tif (display) {\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// Labels\n\n\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t});\n\n\t\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t\t} else {\n\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\n\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\n\t\t// Actually draw the legend on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\tlineDefault = globalDefault.elements.line,\n\t\t\t\tlegendWidth = me.width,\n\t\t\t\tlineWidths = me.lineWidths;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx,\n\t\t\t\t\tcursor,\n\t\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n\t\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t\t// Canvas setup\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize),\n\t\t\t\t\thitboxes = me.legendHitBoxes;\n\n\t\t\t\t// current position\n\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\tctx.save();\n\n\t\t\t\t\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\t\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\t\tvar isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.restore();\n\t\t\t\t};\n\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\t\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\n\n\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\n\t\t\t\t\t\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Horizontal\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width,\n\t\t\t\t\t\twidth = boxWidth + (fontSize / 2) + textWidth,\n\t\t\t\t\t\tx = cursor.x,\n\t\t\t\t\t\ty = cursor.y;\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t\t// Fill the actual label\n\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @return {Boolean} true if a change occured\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\t\tvar changed = false;\n\n\t\t\tif (type === 'mousemove') {\n\t\t\t\tif (!opts.onHover) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (type === 'click') {\n\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Chart event already has relative position in it\n\t\t\tvar x = e.x,\n\t\t\t\ty = e.y;\n\n\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\tvar lh = me.legendHitBoxes;\n\t\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\tfunction createNewLegendAndAttach(chart, legendOpts) {\n\t\tvar legend = new Chart.Legend({\n\t\t\tctx: chart.ctx,\n\t\t\toptions: legendOpts,\n\t\t\tchart: chart\n\t\t});\n\n\t\tlayout.configure(chart, legend, legendOpts);\n\t\tlayout.addBox(chart, legend);\n\t\tchart.legend = legend;\n\t}\n\n\treturn {\n\t\tid: 'legend',\n\n\t\tbeforeInit: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t},\n\n\t\tbeforeUpdate: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\t\t\tvar legend = chart.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tlegendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n\n\t\t\t\tif (legend) {\n\t\t\t\t\tlayout.configure(chart, legend, legendOpts);\n\t\t\t\t\tlegend.options = legendOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t\t}\n\t\t\t} else if (legend) {\n\t\t\t\tlayout.removeBox(chart, legend);\n\t\t\t\tdelete chart.legend;\n\t\t\t}\n\t\t},\n\n\t\tafterEvent: function(chart, e) {\n\t\t\tvar legend = chart.legend;\n\t\t\tif (legend) {\n\t\t\t\tlegend.handleEvent(e);\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 943:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar layout = Chart.layoutService;\n\tvar noop = helpers.noop;\n\n\tChart.defaults.global.title = {\n\t\tdisplay: false,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\tweight: 2000,        // by default greater than legend (1000) to be above\n\t\tfontStyle: 'bold',\n\t\tpadding: 10,\n\n\t\t// actual title\n\t\ttext: ''\n\t};\n\n\tChart.Title = Chart.Element.extend({\n\t\tinitialize: function(config) {\n\t\t\tvar me = this;\n\t\t\thelpers.extend(me, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tme.legendHitBoxes = [];\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: noop,\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this,\n\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\topts = me.options,\n\t\t\t\tglobalDefaults = Chart.defaults.global,\n\t\t\t\tdisplay = opts.display,\n\t\t\t\tfontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\tminSize = me.minSize;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\tvar pos = this.options.position;\n\t\t\treturn pos === 'top' || pos === 'bottom';\n\t\t},\n\n\t\t// Actually draw the title block on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this,\n\t\t\t\tctx = me.ctx,\n\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\topts = me.options,\n\t\t\t\tglobalDefaults = Chart.defaults.global;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\tfontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\tfontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\ttitleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\n\t\t\t\t\trotation = 0,\n\t\t\t\t\ttitleX,\n\t\t\t\t\ttitleY,\n\t\t\t\t\ttop = me.top,\n\t\t\t\t\tleft = me.left,\n\t\t\t\t\tbottom = me.bottom,\n\t\t\t\t\tright = me.right,\n\t\t\t\t\tmaxWidth;\n\n\t\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\t\tctx.font = titleFont;\n\n\t\t\t\t// Horizontal\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\t\ttitleY = top + ((bottom - top) / 2); // midpoint of the height\n\t\t\t\t\tmaxWidth = right - left;\n\t\t\t\t} else {\n\t\t\t\t\ttitleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\n\t\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t\t}\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(titleX, titleY);\n\t\t\t\tctx.rotate(rotation);\n\t\t\t\tctx.textAlign = 'center';\n\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\tctx.fillText(opts.text, 0, 0, maxWidth);\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\t\tvar title = new Chart.Title({\n\t\t\tctx: chart.ctx,\n\t\t\toptions: titleOpts,\n\t\t\tchart: chart\n\t\t});\n\n\t\tlayout.configure(chart, title, titleOpts);\n\t\tlayout.addBox(chart, title);\n\t\tchart.titleBlock = title;\n\t}\n\n\treturn {\n\t\tid: 'title',\n\n\t\tbeforeInit: function(chart) {\n\t\t\tvar titleOpts = chart.options.title;\n\n\t\t\tif (titleOpts) {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t},\n\n\t\tbeforeUpdate: function(chart) {\n\t\t\tvar titleOpts = chart.options.title;\n\t\t\tvar titleBlock = chart.titleBlock;\n\n\t\t\tif (titleOpts) {\n\t\t\t\ttitleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);\n\n\t\t\t\tif (titleBlock) {\n\t\t\t\t\tlayout.configure(chart, titleBlock, titleOpts);\n\t\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t\t}\n\t\t\t} else if (titleBlock) {\n\t\t\t\tChart.layoutService.removeBox(chart, titleBlock);\n\t\t\t\tdelete chart.titleBlock;\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n/***/ }),\n\n/***/ 944:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\n\t\t\tvar me = this;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (me.options.gridLines.offsetGridLines) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 945:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = isFinite(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t\treturn Math.round(pixel);\n\t\t\t}\n\n\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\treturn Math.round(pixel);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 946:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tnoop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n\n\n/***/ }),\n\n/***/ 947:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tvalues[index] = 100;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\n\t\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = getValueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = getValueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = 1;\n\t\t\t\t\tme.max = 10;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n\n\t\t\tif (!me.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tticks.reverse();\n\t\t\t}\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension;\n\t\t\tvar pixel;\n\n\t\t\tvar start = me.start;\n\t\t\tvar newVal = +me.getRightValue(value);\n\t\t\tvar range;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\t\t\t\tif (newVal === 0) {\n\t\t\t\t\tpixel = me.left;\n\t\t\t\t} else {\n\t\t\t\t\tinnerDimension = me.width;\n\t\t\t\t\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Bottom - top since pixels increase downward on a screen\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tif (start === 0 && !tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === start) {\n\t\t\t\t\t\tpixel = me.bottom;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (me.end === 0 && tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === me.end) {\n\t\t\t\t\t\tpixel = me.top;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (newVal === 0) {\n\t\t\t\t\tpixel = tickOpts.reverse ? me.top : me.bottom;\n\t\t\t\t} else {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start);\n\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\tpixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\n\t\t\tvar value, innerDimension;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n\t\t\t} else {  // todo: if start === 0\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 948:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tr: scale.width,\n\t\t\tl: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i;\n\t\tvar textSize;\n\t\tvar pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty+= spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\tctx.font = plFont.font;\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.gridLines.circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t} else {\n\t\t\t\tfit(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea,\n\t\t\t\tmaxLeft = leftMovement + me.drawingArea,\n\t\t\t\tmaxTop = topMovement + me.drawingArea,\n\t\t\t\tmaxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || opts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\t\t\t\t\t\tvar yHeight = me.yCenter - yCenterOffset;\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, me.xCenter, yHeight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 949:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* global window: false */\n\n\nvar moment = __webpack_require__(0);\nmoment = typeof(moment) === 'function' ? moment : window.moment;\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar interval = {\n\t\tmillisecond: {\n\t\t\tsize: 1,\n\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t},\n\t\tsecond: {\n\t\t\tsize: 1000,\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t},\n\t\tminute: {\n\t\t\tsize: 60000,\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t},\n\t\thour: {\n\t\t\tsize: 3600000,\n\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t},\n\t\tday: {\n\t\t\tsize: 86400000,\n\t\t\tsteps: [1, 2, 5]\n\t\t},\n\t\tweek: {\n\t\t\tsize: 604800000,\n\t\t\tmaxStep: 4\n\t\t},\n\t\tmonth: {\n\t\t\tsize: 2.628e9,\n\t\t\tmaxStep: 3\n\t\t},\n\t\tquarter: {\n\t\t\tsize: 7.884e9,\n\t\t\tmaxStep: 4\n\t\t},\n\t\tyear: {\n\t\t\tsize: 3.154e10,\n\t\t\tmaxStep: false\n\t\t}\n\t};\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\thour: 'MMM D, hA', // Sept 4, 5PM\n\t\t\t\tday: 'll', // Sep 4 2015\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false\n\t\t}\n\t};\n\n\t/**\n\t * Helper function to parse time to a moment object\n\t * @param axis {TimeAxis} the time axis\n\t * @param label {Date|string|number|Moment} The thing to parse\n\t * @return {Moment} parsed time\n\t */\n\tfunction parseTime(axis, label) {\n\t\tvar timeOpts = axis.options.time;\n\t\tif (typeof timeOpts.parser === 'string') {\n\t\t\treturn moment(label, timeOpts.parser);\n\t\t}\n\t\tif (typeof timeOpts.parser === 'function') {\n\t\t\treturn timeOpts.parser(label);\n\t\t}\n\t\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\n\t\t\t// Date objects\n\t\t\treturn moment(label);\n\t\t}\n\t\tif (label.isValid && label.isValid()) {\n\t\t\t// Moment support\n\t\t\treturn label;\n\t\t}\n\t\tvar format = timeOpts.format;\n\t\tif (typeof format !== 'string' && format.call) {\n\t\t\t// Custom parsing (return an instance of moment)\n\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\treturn format(label);\n\t\t}\n\t\t// Moment format parsing\n\t\treturn moment(label, format);\n\t}\n\n\t/**\n\t * Figure out which is the best unit for the scale\n\t * @param minUnit {String} minimum unit to use\n\t * @param min {Number} scale minimum\n\t * @param max {Number} scale maximum\n\t * @return {String} the unit to use\n\t */\n\tfunction determineUnit(minUnit, min, max, maxTicks) {\n\t\tvar units = Object.keys(interval);\n\t\tvar unit;\n\t\tvar numUnits = units.length;\n\n\t\tfor (var i = units.indexOf(minUnit); i < numUnits; i++) {\n\t\t\tunit = units[i];\n\t\t\tvar unitDetails = interval[unit];\n\t\t\tvar steps = (unitDetails.steps && unitDetails.steps[unitDetails.steps.length - 1]) || unitDetails.maxStep;\n\t\t\tif (steps === undefined || Math.ceil((max - min) / (steps * unitDetails.size)) <= maxTicks) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn unit;\n\t}\n\n\t/**\n\t * Determines how we scale the unit\n\t * @param min {Number} the scale minimum\n\t * @param max {Number} the scale maximum\n\t * @param unit {String} the unit determined by the {@see determineUnit} method\n\t * @return {Number} the axis step size as a multiple of unit\n\t */\n\tfunction determineStepSize(min, max, unit, maxTicks) {\n\t\t// Using our unit, figoure out what we need to scale as\n\t\tvar unitDefinition = interval[unit];\n\t\tvar unitSizeInMilliSeconds = unitDefinition.size;\n\t\tvar sizeInUnits = Math.ceil((max - min) / unitSizeInMilliSeconds);\n\t\tvar multiplier = 1;\n\t\tvar range = max - min;\n\n\t\tif (unitDefinition.steps) {\n\t\t\t// Have an array of steps\n\t\t\tvar numSteps = unitDefinition.steps.length;\n\t\t\tfor (var i = 0; i < numSteps && sizeInUnits > maxTicks; i++) {\n\t\t\t\tmultiplier = unitDefinition.steps[i];\n\t\t\t\tsizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));\n\t\t\t}\n\t\t} else {\n\t\t\twhile (sizeInUnits > maxTicks && maxTicks > 0) {\n\t\t\t\t++multiplier;\n\t\t\t\tsizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));\n\t\t\t}\n\t\t}\n\n\t\treturn multiplier;\n\t}\n\n\t/**\n\t * Helper for generating axis labels.\n\t * @param options {ITimeGeneratorOptions} the options for generation\n\t * @param dataRange {IRange} the data range\n\t * @param niceRange {IRange} the pretty range to display\n\t * @return {Number[]} ticks\n\t */\n\tfunction generateTicks(options, dataRange, niceRange) {\n\t\tvar ticks = [];\n\t\tif (options.maxTicks) {\n\t\t\tvar stepSize = options.stepSize;\n\t\t\tticks.push(options.min !== undefined ? options.min : niceRange.min);\n\t\t\tvar cur = moment(niceRange.min);\n\t\t\twhile (cur.add(stepSize, options.unit).valueOf() < niceRange.max) {\n\t\t\t\tticks.push(cur.valueOf());\n\t\t\t}\n\t\t\tvar realMax = options.max || niceRange.max;\n\t\t\tif (ticks[ticks.length - 1] !== realMax) {\n\t\t\t\tticks.push(realMax);\n\t\t\t}\n\t\t}\n\t\treturn ticks;\n\t}\n\n\t/**\n\t * @function Chart.Ticks.generators.time\n\t * @param options {ITimeGeneratorOptions} the options for generation\n\t * @param dataRange {IRange} the data range\n\t * @return {Number[]} ticks\n\t */\n\tChart.Ticks.generators.time = function(options, dataRange) {\n\t\tvar niceMin;\n\t\tvar niceMax;\n\t\tvar isoWeekday = options.isoWeekday;\n\t\tif (options.unit === 'week' && isoWeekday !== false) {\n\t\t\tniceMin = moment(dataRange.min).startOf('isoWeek').isoWeekday(isoWeekday).valueOf();\n\t\t\tniceMax = moment(dataRange.max).startOf('isoWeek').isoWeekday(isoWeekday);\n\t\t\tif (dataRange.max - niceMax > 0) {\n\t\t\t\tniceMax.add(1, 'week');\n\t\t\t}\n\t\t\tniceMax = niceMax.valueOf();\n\t\t} else {\n\t\t\tniceMin = moment(dataRange.min).startOf(options.unit).valueOf();\n\t\t\tniceMax = moment(dataRange.max).startOf(options.unit);\n\t\t\tif (dataRange.max - niceMax > 0) {\n\t\t\t\tniceMax.add(1, options.unit);\n\t\t\t}\n\t\t\tniceMax = niceMax.valueOf();\n\t\t}\n\t\treturn generateTicks(options, dataRange, {\n\t\t\tmin: niceMin,\n\t\t\tmax: niceMax\n\t\t});\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar timeOpts = me.options.time;\n\n\t\t\t// We store the data range as unix millisecond timestamps so dataMin and dataMax will always be integers.\n\t\t\tvar dataMin = Number.MAX_SAFE_INTEGER;\n\t\t\tvar dataMax = Number.MIN_SAFE_INTEGER;\n\n\t\t\tvar chartData = me.chart.data;\n\t\t\tvar parsedData = {\n\t\t\t\tlabels: [],\n\t\t\t\tdatasets: []\n\t\t\t};\n\n\t\t\tvar timestamp;\n\n\t\t\thelpers.each(chartData.labels, function(label, labelIndex) {\n\t\t\t\tvar labelMoment = parseTime(me, label);\n\n\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t// We need to round the time\n\t\t\t\t\tif (timeOpts.round) {\n\t\t\t\t\t\tlabelMoment.startOf(timeOpts.round);\n\t\t\t\t\t}\n\n\t\t\t\t\ttimestamp = labelMoment.valueOf();\n\t\t\t\t\tdataMin = Math.min(timestamp, dataMin);\n\t\t\t\t\tdataMax = Math.max(timestamp, dataMax);\n\n\t\t\t\t\t// Store this value for later\n\t\t\t\t\tparsedData.labels[labelIndex] = timestamp;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(chartData.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar timestamps = [];\n\n\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null && me.chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t// We have potential point data, so we need to parse this\n\t\t\t\t\thelpers.each(dataset.data, function(value, dataIndex) {\n\t\t\t\t\t\tvar dataMoment = parseTime(me, me.getRightValue(value));\n\n\t\t\t\t\t\tif (dataMoment.isValid()) {\n\t\t\t\t\t\t\tif (timeOpts.round) {\n\t\t\t\t\t\t\t\tdataMoment.startOf(timeOpts.round);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttimestamp = dataMoment.valueOf();\n\t\t\t\t\t\t\tdataMin = Math.min(timestamp, dataMin);\n\t\t\t\t\t\t\tdataMax = Math.max(timestamp, dataMax);\n\t\t\t\t\t\t\ttimestamps[dataIndex] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// We have no x coordinates, so use the ones from the labels\n\t\t\t\t\ttimestamps = parsedData.labels.slice();\n\t\t\t\t}\n\n\t\t\t\tparsedData.datasets[datasetIndex] = timestamps;\n\t\t\t});\n\n\t\t\tme.dataMin = dataMin;\n\t\t\tme.dataMax = dataMax;\n\t\t\tme._parsedData = parsedData;\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar timeOpts = me.options.time;\n\n\t\t\tvar minTimestamp;\n\t\t\tvar maxTimestamp;\n\t\t\tvar dataMin = me.dataMin;\n\t\t\tvar dataMax = me.dataMax;\n\n\t\t\tif (timeOpts.min) {\n\t\t\t\tvar minMoment = parseTime(me, timeOpts.min);\n\t\t\t\tif (timeOpts.round) {\n\t\t\t\t\tminMoment.round(timeOpts.round);\n\t\t\t\t}\n\t\t\t\tminTimestamp = minMoment.valueOf();\n\t\t\t}\n\n\t\t\tif (timeOpts.max) {\n\t\t\t\tmaxTimestamp = parseTime(me, timeOpts.max).valueOf();\n\t\t\t}\n\n\t\t\tvar maxTicks = me.getLabelCapacity(minTimestamp || dataMin);\n\t\t\tvar unit = timeOpts.unit || determineUnit(timeOpts.minUnit, minTimestamp || dataMin, maxTimestamp || dataMax, maxTicks);\n\t\t\tme.displayFormat = timeOpts.displayFormats[unit];\n\n\t\t\tvar stepSize = timeOpts.stepSize || determineStepSize(minTimestamp || dataMin, maxTimestamp || dataMax, unit, maxTicks);\n\t\t\tme.ticks = Chart.Ticks.generators.time({\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: minTimestamp,\n\t\t\t\tmax: maxTimestamp,\n\t\t\t\tstepSize: stepSize,\n\t\t\t\tunit: unit,\n\t\t\t\tisoWeekday: timeOpts.isoWeekday\n\t\t\t}, {\n\t\t\t\tmin: dataMin,\n\t\t\t\tmax: dataMax\n\t\t\t});\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(me.ticks);\n\t\t\tme.min = helpers.min(me.ticks);\n\t\t},\n\t\t// Get tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n\t\t\tvar value = me.chart.data.datasets[datasetIndex].data[index];\n\n\t\t\tif (value !== null && typeof value === 'object') {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\n\t\t\t// Format nicely\n\t\t\tif (me.options.time.tooltipFormat) {\n\t\t\t\tlabel = parseTime(me, label).format(me.options.time.tooltipFormat);\n\t\t\t}\n\n\t\t\treturn label;\n\t\t},\n\t\t// Function to format an individual tick mark\n\t\ttickFormatFunction: function(tick, index, ticks) {\n\t\t\tvar formattedTick = tick.format(this.displayFormat);\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\tif (callback) {\n\t\t\t\treturn callback(formattedTick, index, ticks);\n\t\t\t}\n\t\t\treturn formattedTick;\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsTimestamps = me.ticks;\n\t\t\tme.ticks = me.ticks.map(function(tick) {\n\t\t\t\treturn moment(tick);\n\t\t\t}).map(me.tickFormatFunction, me);\n\t\t},\n\t\tgetPixelForOffset: function(offset) {\n\t\t\tvar me = this;\n\t\t\tvar epochWidth = me.max - me.min;\n\t\t\tvar decimal = epochWidth ? (offset - me.min) / epochWidth : 0;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueOffset = (me.width * decimal);\n\t\t\t\treturn me.left + Math.round(valueOffset);\n\t\t\t}\n\n\t\t\tvar heightOffset = (me.height * decimal);\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar offset = null;\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\toffset = me._parsedData.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (offset === null) {\n\t\t\t\tif (!value || !value.isValid) {\n\t\t\t\t\t// not already a moment object\n\t\t\t\t\tvalue = parseTime(me, me.getRightValue(value));\n\t\t\t\t}\n\n\t\t\t\tif (value && value.isValid && value.isValid()) {\n\t\t\t\t\toffset = value.valueOf();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (offset !== null) {\n\t\t\t\treturn me.getPixelForOffset(offset);\n\t\t\t}\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForOffset(this.ticksAsTimestamps[index]);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension = me.isHorizontal() ? me.width : me.height;\n\t\t\tvar offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\n\t\t\treturn moment(me.min + (offset * (me.max - me.min)));\n\t\t},\n\t\t// Crude approximation of what the label width might be\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticks = me.options.ticks;\n\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar cosRotation = Math.cos(helpers.toRadians(ticks.maxRotation));\n\t\t\tvar sinRotation = Math.sin(helpers.toRadians(ticks.maxRotation));\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(ticks.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tme.displayFormat = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\t\t\tvar labelCapacity = innerWidth / tickLabelWidth;\n\t\t\treturn labelCapacity;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n\n};\n\n\n/***/ }),\n\n/***/ 950:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* MIT license */\r\nvar colorNames = __webpack_require__(953);\r\n\r\nmodule.exports = {\r\n   getRgba: getRgba,\r\n   getHsla: getHsla,\r\n   getRgb: getRgb,\r\n   getHsl: getHsl,\r\n   getHwb: getHwb,\r\n   getAlpha: getAlpha,\r\n\r\n   hexString: hexString,\r\n   rgbString: rgbString,\r\n   rgbaString: rgbaString,\r\n   percentString: percentString,\r\n   percentaString: percentaString,\r\n   hslString: hslString,\r\n   hslaString: hslaString,\r\n   hwbString: hwbString,\r\n   keyword: keyword\r\n}\r\n\r\nfunction getRgba(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var abbr =  /^#([a-fA-F0-9]{3})$/,\r\n       hex =  /^#([a-fA-F0-9]{6})$/,\r\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n       keyword = /(\\w+)/;\r\n\r\n   var rgb = [0, 0, 0],\r\n       a = 1,\r\n       match = string.match(abbr);\r\n   if (match) {\r\n      match = match[1];\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match[i] + match[i], 16);\r\n      }\r\n   }\r\n   else if (match = string.match(hex)) {\r\n      match = match[1];\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\r\n      }\r\n   }\r\n   else if (match = string.match(rgba)) {\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match[i + 1]);\r\n      }\r\n      a = parseFloat(match[4]);\r\n   }\r\n   else if (match = string.match(per)) {\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\r\n      }\r\n      a = parseFloat(match[4]);\r\n   }\r\n   else if (match = string.match(keyword)) {\r\n      if (match[1] == \"transparent\") {\r\n         return [0, 0, 0, 0];\r\n      }\r\n      rgb = colorNames[match[1]];\r\n      if (!rgb) {\r\n         return;\r\n      }\r\n   }\r\n\r\n   for (var i = 0; i < rgb.length; i++) {\r\n      rgb[i] = scale(rgb[i], 0, 255);\r\n   }\r\n   if (!a && a != 0) {\r\n      a = 1;\r\n   }\r\n   else {\r\n      a = scale(a, 0, 1);\r\n   }\r\n   rgb[3] = a;\r\n   return rgb;\r\n}\r\n\r\nfunction getHsla(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n   var match = string.match(hsl);\r\n   if (match) {\r\n      var alpha = parseFloat(match[4]);\r\n      var h = scale(parseInt(match[1]), 0, 360),\r\n          s = scale(parseFloat(match[2]), 0, 100),\r\n          l = scale(parseFloat(match[3]), 0, 100),\r\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n      return [h, s, l, a];\r\n   }\r\n}\r\n\r\nfunction getHwb(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n   var match = string.match(hwb);\r\n   if (match) {\r\n    var alpha = parseFloat(match[4]);\r\n      var h = scale(parseInt(match[1]), 0, 360),\r\n          w = scale(parseFloat(match[2]), 0, 100),\r\n          b = scale(parseFloat(match[3]), 0, 100),\r\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n      return [h, w, b, a];\r\n   }\r\n}\r\n\r\nfunction getRgb(string) {\r\n   var rgba = getRgba(string);\r\n   return rgba && rgba.slice(0, 3);\r\n}\r\n\r\nfunction getHsl(string) {\r\n  var hsla = getHsla(string);\r\n  return hsla && hsla.slice(0, 3);\r\n}\r\n\r\nfunction getAlpha(string) {\r\n   var vals = getRgba(string);\r\n   if (vals) {\r\n      return vals[3];\r\n   }\r\n   else if (vals = getHsla(string)) {\r\n      return vals[3];\r\n   }\r\n   else if (vals = getHwb(string)) {\r\n      return vals[3];\r\n   }\r\n}\r\n\r\n// generators\r\nfunction hexString(rgb) {\r\n   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\r\n              + hexDouble(rgb[2]);\r\n}\r\n\r\nfunction rgbString(rgba, alpha) {\r\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n      return rgbaString(rgba, alpha);\r\n   }\r\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\r\n}\r\n\r\nfunction rgbaString(rgba, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\r\n   }\r\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\r\n           + \", \" + alpha + \")\";\r\n}\r\n\r\nfunction percentString(rgba, alpha) {\r\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n      return percentaString(rgba, alpha);\r\n   }\r\n   var r = Math.round(rgba[0]/255 * 100),\r\n       g = Math.round(rgba[1]/255 * 100),\r\n       b = Math.round(rgba[2]/255 * 100);\r\n\r\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\r\n}\r\n\r\nfunction percentaString(rgba, alpha) {\r\n   var r = Math.round(rgba[0]/255 * 100),\r\n       g = Math.round(rgba[1]/255 * 100),\r\n       b = Math.round(rgba[2]/255 * 100);\r\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\r\n}\r\n\r\nfunction hslString(hsla, alpha) {\r\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\r\n      return hslaString(hsla, alpha);\r\n   }\r\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\r\n}\r\n\r\nfunction hslaString(hsla, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\r\n   }\r\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\r\n           + alpha + \")\";\r\n}\r\n\r\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\r\n// (hwb have alpha optional & 1 is default value)\r\nfunction hwbString(hwb, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\r\n   }\r\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\r\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\r\n}\r\n\r\nfunction keyword(rgb) {\r\n  return reverseNames[rgb.slice(0, 3)];\r\n}\r\n\r\n// helpers\r\nfunction scale(num, min, max) {\r\n   return Math.min(Math.max(min, num), max);\r\n}\r\n\r\nfunction hexDouble(num) {\r\n  var str = num.toString(16).toUpperCase();\r\n  return (str.length < 2) ? \"0\" + str : str;\r\n}\r\n\r\n\r\n//create a list of reverse color names\r\nvar reverseNames = {};\r\nfor (var name in colorNames) {\r\n   reverseNames[colorNames[name]] = name;\r\n}\r\n\n\n/***/ }),\n\n/***/ 951:\n/***/ (function(module, exports) {\n\n/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n\n\n/***/ }),\n\n/***/ 952:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar conversions = __webpack_require__(951);\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;\n\n/***/ }),\n\n/***/ 953:\n/***/ (function(module, exports) {\n\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\n/***/ }),\n\n/***/ 964:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = defaultBar;\n/* harmony export (immutable) */ __webpack_exports__[\"f\"] = horizontalBar;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = pie;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = cleanInsightsByWeek;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = cleanInsightsByCategory;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = cleanInsightsByStatus;\nfunction defaultBar(data) {\n    return {\n        type: 'bar',\n        data: data,\n        options: {\n            legend: {\n                display: false\n            },\n            scales: {\n                yAxes: [{\n                    ticks: {\n                        beginAtZero: true\n                    }\n\n                }]\n            }\n        }\n    };\n}\n\nfunction horizontalBar(data) {\n    return {\n        type: 'horizontalBar',\n        data: data,\n        options: {\n            legend: {\n                display: false\n            },\n            scales: {\n                xAxes: [{\n                    ticks: {\n                        beginAtZero: true\n                    },\n                    label: {\n                        display: false\n                    }\n                }],\n                yAxes: [{\n                    display: false,\n                    stacked: true\n                }]\n            }\n\n        }\n    };\n}\n\nfunction pie(data) {\n    return {\n        type: 'pie',\n        data: data,\n        options: {}\n    };\n}\n\nfunction cleanInsightsByWeek() {\n    return {\n        labels: ['Semana: 1', 'Semana: 2', 'Semana: 3', 'Semana: 4', 'Semana: 5'],\n        datasets: [{\n            label: 'Confirmado',\n            data: [0, 0, 0, 0, 0],\n            backgroundColor: 'rgba(0, 163, 105, .7)',\n            borderColor: '#00A369',\n            borderWidth: 0\n        }, {\n            label: 'Pendente',\n            data: [0, 0, 0, 0, 0],\n            backgroundColor: 'rgba(204, 204, 204, .7)',\n            borderColor: '#CCCCCC',\n            borderWidth: 0\n        }, {\n            label: 'Cancelado',\n            data: [0, 0, 0, 0, 0],\n            backgroundColor: 'rgba(255, 204, 95, .7)',\n            borderColor: '#FFCC5F',\n            borderWidth: 0\n        }, {\n            label: 'Atrasado',\n            data: [0, 0, 0, 0, 0],\n            backgroundColor: 'rgba(225, 74, 69, .7)',\n            borderColor: '#E14A45',\n            borderWidth: 0\n        }]\n    };\n}\nfunction cleanInsightsByCategory() {\n    return {\n        labels: [],\n        datasets: [{\n            label: '',\n            data: [],\n            backgroundColor: [],\n            borderColor: [],\n            borderWidth: 0\n        }]\n    };\n}\nfunction cleanInsightsByStatus() {\n    return {\n        labels: ['Confirmadas', 'Pendentes', 'canceladas', 'atrasadas'],\n        datasets: [{\n            label: '',\n            data: [],\n            backgroundColor: ['rgba(0, 163, 105, .7)', 'rgba(204, 204, 204, .7)', 'rgba(255, 204, 95, .7)', 'rgba(225, 74, 69, .7)'],\n            borderColor: ['#00A369', '#CCCCCC', '#FFCC5F', '#E14A45'],\n            borderWidth: 2\n        }]\n    };\n}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/6.c985f554f2d43f76e5d2.js","<template lang=\"html\">\n\n    <div class=\"first-container\">\n\n        <main-header\n            :type=\"'center'\"\n            :title=\"'Insights'\"\n            :cursor=\"false\"\n            :action=\"function(){ return false}\"\n            :hasback=\"true\"\n        >\n        </main-header>\n\n        <div class=\"container\">\n\n            <h2 class=\"f-300 text-center m-b-30\">Faturas</h2>\n\n            <div class=\"text-center row m-t-30 insight-row\">\n\n                <div class=\"col-md-4 col-xs-3 insight-col text-left\">\n                    <button class=\"btn btn-info p-5 p-l-10 p-r-10 btn-block\" @click=\"handlePrevMonth()\">\n                        <i class=\"ion-ios-arrow-back\"></i>\n                    </button>\n                </div>\n                <div class=\"col-md-4 col-xs-6 insight-col\">\n                    <button class=\"btn btn-info p-5 p-l-10 p-r-10 btn-block\">{{current_month.format('MMMM')}} / {{current_month.format('YYYY')}}</button>\n                </div>\n                <div class=\"col-md-4 col-xs-3 insight-col text-right\">\n                    <button class=\"btn btn-info p-5 p-l-10 p-r-10 btn-block\" @click=\"handleNextMonth()\">\n                        <i class=\"ion-ios-arrow-forward\"></i>\n                    </button>\n                </div>\n\n            </div>\n        </div>\n\n        <!-- Invoices -->\n        <div class=\"container m-t-30\">\n\n            <div class=\"card\" v-if=\"currentValueReceived\">\n                <div class=\"card-header ch-alt text-center\">\n                    <h4 class=\"f-300 m-0 m-b-10\">Valor recebido em {{current_month.format('MMMM')}}</h4>\n                    <span class=\"label label-success p-5 p-l-10 p-r-10 f-14\">{{ currentValueReceived | formatCurrency }}</span>\n                </div>\n            </div>\n\n            <!-- <card-placeholder v-if=\"placeholder.professional\" :onlyHeader=\"true\"></card-placeholder> -->\n            <div class=\"row insight-row\">\n                <div class=\"col-sm-2 col-xs-6 insight-col\" v-for=\"invoice in invoices\">\n                    <div class=\"card\">\n                        <div class=\"card-header ch-alt text-center p-5\">\n                            <h4 class=\"f-300 t-overflow m-t-10 m-b-10\">{{ invoice.value | formatCurrency }}</h4>\n                            <p>{{ invoice.subscription.plan.category.name }}</p>\n                            <span class=\"label label-success p-5 p-l-10 p-r-10\" v-if=\"invoice.is_confirmed\">Confirmada</span>\n                            <span class=\"label label-warning p-5 p-l-10 p-r-10\" v-if=\"invoice.is_canceled\">Cancelada</span>\n                            <span class=\"label label-default p-5 p-l-10 p-r-10\" v-if=\"!invoice.is_confirmed && !invoice.is_canceled && isExpired(invoice.expire_at) > -1\">Aguardando</span>\n                            <span class=\"label label-danger p-5 p-l-10 p-r-10\" v-if=\"!invoice.is_confirmed && !invoice.is_canceled && isExpired(invoice.expire_at) < -1\">Atrasada</span>\n                            <hr>\n                            <small class=\"f-300\">vencimento em:\n                                {{ invoice.expire_at }}\n                            </small>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <!-- / Invoices -->\n\n        <!-- By Status -->\n        <div class=\"container\" v-show=\"!invoices.length\">\n            <div class=\"card\">\n                <div class=\"card-body\">\n                    <p class=\"f-300 f-danger text-center m-t-10\">\n                        Não foi possível localizar nenhuma fatura no mês de\n                        <strong>{{ current_month.format('MMMM') }} de {{ current_month.format('YYYY') }}</strong>.\n                    </p>\n                </div>\n            </div>\n        </div>\n        <!-- By Status -->\n\n        <div class=\"container\" v-show=\"invoices.length\">\n            <div class=\"row insight-row\">\n\n                <!-- By Status -->\n                <div class=\"col-sm-12 insight-col\">\n\n                    <button class=\"btn f-18 btn-light btn-block f-300 m-b-10\" @click=\"handleChartType('by_status')\">\n                        <i class=\"ion-checkmark-round f-22 m-r-5\"></i>\n                        Gráfico por status\n                    </button>\n\n                    <div class=\"card\" v-show=\"interactions.chartByStatus\">\n                        <div class=\"card-body p-l-5 p-r-5 text-center\">\n                            <!-- Custom Labels -->\n                            <div class=\"text-center m-t-5 m-b-30\" v-show=\"invoices.length\">\n                                <div class=\"row insight-row\">\n                                    <div class=\"col-xs-6 insight-col\">\n                                        <span class=\"btn btn-xs btn-block btn-success p-5 p-l-10 p-r-10 f-12\">Confirmado<br> <strong>{{ statusCount.confirmed | formatCurrency }}</strong></span>\n                                    </div>\n                                    <div class=\"col-xs-6 insight-col\">\n                                        <span class=\"btn btn-xs btn-block btn-default p-5 p-l-10 p-r-10 f-12\">Pendente<br> <strong>{{ statusCount.pending | formatCurrency }}</strong></span>\n                                    </div>\n                                    <div class=\"col-xs-6 m-t-10 insight-col\">\n                                        <span class=\"btn btn-xs btn-block btn-warning p-5 p-l-10 p-r-10 f-12\">Cancelado<br> <strong>{{ statusCount.canceled | formatCurrency }}</strong></span>\n                                    </div>\n                                    <div class=\"col-xs-6 m-t-10 insight-col\">\n                                        <span class=\"btn btn-xs btn-block btn-danger p-5 p-l-10 p-r-10 f-12\">Atrasado<br> <strong>{{ statusCount.expired | formatCurrency }}</strong></span>\n                                    </div>\n                                </div>\n                            </div>\n                            <!-- /Custom Labels -->\n\n                            <canvas ref=\"chartByStatus\" class=\"canvas-default\"></canvas>\n                        </div>\n                    </div>\n                </div>\n                <!-- By Status -->\n\n                <!-- By Week -->\n                <div class=\"col-sm-6 insight-col\">\n\n                    <button class=\"btn f-18 btn-light btn-block f-300 m-b-10\" @click=\"handleChartType('by_week')\">\n                        <i class=\"ion-stats-bars f-22 m-r-5\"></i>\n                        Gráfico por semana\n                    </button>\n\n                    <div class=\"card\" v-show=\"interactions.chartByWeek\">\n                        <div class=\"card-body text-center\">\n                            <canvas ref=\"chartByWeek\" class=\"canvas-default\"></canvas>\n                        </div>\n                    </div>\n                </div>\n                <!-- / By Week -->\n\n                <!-- By Category -->\n                <div class=\"col-sm-6 insight-col\">\n\n                    <button class=\"btn f-18 btn-light btn-block f-300 m-b-10\" @click=\"handleChartType('by_category')\">\n                        <i class=\"ion-ios-pie-outline f-22 m-r-5\"></i>\n                        Gráfico de categorias\n                    </button>\n\n                    <div class=\"card\" v-show=\"interactions.chartByCategory\">\n                        <div class=\"card-body text-center\">\n                            <canvas ref=\"chartByCategory\" class=\"canvas-default\"></canvas>\n                        </div>\n                    </div>\n                </div>\n                <!-- By Category -->\n\n            </div>\n        </div>\n    </div>\n</template>\n\n\n<script>\n\n    import { mapGetters, mapActions } from 'vuex'\n    import mainHeader from '@/components/main-header.vue'\n    import cardPlaceholder from '@/components/card-placeholder.vue'\n\n    import Chart from 'chart.js'\n    import { defaultBar, horizontalBar, pie, cleanInsightsByWeek, cleanInsightsByStatus, cleanInsightsByCategory } from '@/models/ChartOptions'\n\n    import Moment from 'moment'\n    import { extendMoment } from 'moment-range'\n    const moment = extendMoment(Moment)\n\n    export default {\n        name: 'company-calendar-insight',\n        components: {\n            mainHeader,\n            cardPlaceholder,\n        },\n        data() {\n            return {\n                current_month: moment(),\n                currentValueReceived: 0,\n                statusCount: {\n                    confirmed: 0, pending: 0, canceled: 0, expired: 0\n                },\n                invoices: [],\n                categories: [],\n                interactions: {\n                    professionalsCardsOpened: [],\n                    chartByStatus: true,\n                    chartByWeek: true,\n                    chartByCategory: true,\n                },\n                placeholder: {\n                    invoices: true\n                },\n                insights: {\n                    by_status: cleanInsightsByStatus(),\n                    by_week: cleanInsightsByWeek(),\n                    by_category: cleanInsightsByCategory(),\n                }\n            }\n        },\n\n        mounted(){\n            this.getInvoices();\n        },\n\n        methods: {\n\n            isExpired(date) {\n                return moment(date, 'DD/MM/YYYY').diff(moment(), 'days')\n            },\n\n            resetData() {\n\n                this.interactions.chartByStatus = true\n                this.interactions.chartByWeek = true\n                this.interactions.chartByCategory = true\n\n                this.currentValueReceived = 0\n                this.statusCount.confirmed = 0\n                this.statusCountpending = 0\n                this.statusCountcanceled = 0\n                this.statusCountexpired = 0\n\n                this.insights.by_week = cleanInsightsByWeek()\n                this.insights.by_status = cleanInsightsByStatus()\n                this.insights.by_category = cleanInsightsByCategory()\n            },\n\n            dataByCategory() {\n                let that = this\n\n                let categoriesNames = _.flatten(that.categories.map((category) => category.name)).sort()\n                let categoriesSlug = _.flatten(that.categories.map((category) => category.slug)).sort()\n\n                // Remove valores repetidos\n                that.insights.by_category.labels = _.uniq(categoriesNames)\n\n                categoriesSlug = _.uniq(categoriesSlug)\n\n                that.insights.by_category.labels.forEach((label, indexCategories) => {\n                    const currentColor = categoriesSlug[indexCategories].colorByCategory()\n                    that.insights.by_category.datasets[0].backgroundColor.push(currentColor.hex)\n                    that.insights.by_category.datasets[0].borderColor.push(currentColor.rgba)\n                })\n\n                let values = new Array(that.insights.by_category.labels.length)\n                for (var i = 0; i < values.length; i++) {\n                    values[i] = 0\n                }\n\n                that.insights.by_category.labels.forEach((label, labelIndex) => {\n                    that.invoices.forEach((invoice) => {\n                        if (label === invoice.subscription.plan.category.name) {\n                            values[labelIndex]+= invoice.value\n                        }\n                    })\n                })\n                that.insights.by_category.datasets[0].data = values\n\n\n            },\n\n            countStatus() {\n                let that = this\n                that.statusCount = { confirmed: 0, pending: 0, canceled: 0, expired: 0 }\n                that.invoices.map((invoice) => {\n                    let is_expired = that.isExpired(invoice.expire_at)\n\n                    // Confirmadas\n                    if (invoice.is_confirmed) {\n                        that.statusCount.confirmed+= invoice.value\n                    }\n                    // Canceladas\n                    if (invoice.is_canceled) {\n                        that.statusCount.canceled+= invoice.value\n                    }\n                    // Pendentes\n                    if (!invoice.is_confirmed && !invoice.is_canceled && is_expired > -1) {\n                        that.statusCount.pending+= invoice.value\n                    }\n                    // Atrasadas\n                    if (!invoice.is_confirmed && !invoice.is_canceled && is_expired < -1) {\n                        that.statusCount.expired+= invoice.value\n                    }\n                })\n            },\n\n            dataByWeek() {\n                let that = this\n\n                that.insights.by_week.labels.forEach((label, indexDataSet) => {\n                    that.invoices.forEach((invoice) => {\n\n                        const currentDate = `Semana: ${ Math.ceil(moment(invoice.expire_at, 'DD/MM/YYYY').date() / 7) }`\n                        const is_expired = that.isExpired(invoice.expire_at)\n\n                        if (currentDate === that.insights.by_week.labels[indexDataSet]) {\n                            // Confirmadas\n                            if (invoice.is_confirmed) {\n                                that.insights.by_week.datasets[0].data[indexDataSet]+= invoice.value\n                            }\n                            // Pendentes\n                            if (!invoice.is_confirmed && !invoice.is_canceled && is_expired > -1) {\n                                that.insights.by_week.datasets[1].data[indexDataSet]+= invoice.value\n                            }\n                            // Canceladas\n                            if (invoice.is_canceled) {\n                                that.insights.by_week.datasets[2].data[indexDataSet]+= invoice.value\n                            }\n                            // Atrasadas\n                            if (!invoice.is_confirmed && !invoice.is_canceled && is_expired < -1) {\n                                that.insights.by_week.datasets[3].data[indexDataSet]+= invoice.value\n                            }\n                        }\n                    })\n                })\n\n            },\n\n            dataByStatus() {\n                let that =  this\n\n                that.countStatus()\n                that.insights.by_status.datasets[0].data = _.values(that.statusCount)\n\n            },\n\n            handleChartType(type) {\n                let that = this\n\n                // Cuida do grafico por categoria\n                if (type === 'by_category') {\n\n                    if (that.chartByCategory) that.chartByCategory.destroy()\n\n                    that.interactions.chartByCategory = !that.interactions.chartByCategory\n\n                    if (that.interactions.chartByCategory) {\n                        setTimeout(() => {\n                            that.chartByCategory = new Chart(that.$refs.chartByCategory, pie(that.insights.by_category))\n                        }, 200);\n                    }\n                }\n\n                // Cuida do grafico por semana + status\n                if (type === 'by_week') {\n\n                    if (that.chartByWeek) that.chartByWeek.destroy()\n\n                    that.interactions.chartByWeek = !that.interactions.chartByWeek\n\n                    if (that.interactions.chartByWeek) {\n                        setTimeout(() => {\n                            that.chartByWeek = new Chart(that.$refs.chartByWeek, defaultBar(that.insights.by_week))\n                        }, 200);\n                    }\n                }\n\n                // Cuida do grafico por status\n                if (type === 'by_status') {\n\n                    if (that.chartByStatus) that.chartByStatus.destroy()\n\n                    that.interactions.chartByStatus = !that.interactions.chartByStatus\n\n                    if (that.interactions.chartByStatus) {\n                        setTimeout(() => {\n                            that.chartByStatus = new Chart(that.$refs.chartByStatus, horizontalBar(that.insights.by_status))\n                        }, 200);\n                    }\n                }\n            },\n\n            // For CurrentMonth\n            getInvoices() {\n                let that = this\n\n                var data = {\n                    company_id: that.$route.params.company_id,\n                    search: '',\n                    init: moment(that.current_month).startOf('month').format('YYYY-MM-DD'),\n                    end: moment(that.current_month).endOf('month').format('YYYY-MM-DD')\n                }\n\n                that.categories = []\n                that.invoices = []\n                that.resetData()\n\n                that.$http.post(`professional/company/invoice/list`, data)\n                    .then(function (response) {\n                        that.invoices = response.data.invoices\n                        that.invoices.map((invoice) => {\n                            that.categories.push(invoice.subscription.plan.category)\n                            if (invoice.is_confirmed) {\n                                that.currentValueReceived += invoice.value\n                            }\n                        })\n                        that.dataByCategory()\n                        that.dataByWeek()\n                        that.dataByStatus()\n\n                        if (!window.cordova) {\n                            that.handleChartType('by_status')\n                            that.handleChartType('by_week')\n                            that.handleChartType('by_category')\n                        }\n\n                    })\n                    .catch(function (error) {\n                        console.log(error)\n                        that.placeholder = false;\n                    });\n            },\n\n            handlePrevMonth(){\n                this.current_month.subtract(1, 'month');\n                this.getInvoices();\n            },\n\n            handleNextMonth(){\n                this.current_month.add(1, 'month');\n                this.getInvoices();\n            },\n        }\n    }\n</script>\n\n<style scoped>\n    .row.insight-row { margin: 0 -5px; }\n    .row.insight-row .insight-col { padding: 0 5px; }\n\n    /* canvas */\n    .canvas-default {\n        max-width: 100%;\n        min-height: 0px;\n    }\n\n</style>\n\n\n\n// WEBPACK FOOTER //\n// insights.vue?2e0f88c6","exports = module.exports = require(\"../../../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".row.insight-row[data-v-831fff60]{margin:0 -5px}.row.insight-row .insight-col[data-v-831fff60]{padding:0 5px}.canvas-default[data-v-831fff60]{max-width:100%;min-height:0}\", \"\", {\"version\":3,\"sources\":[\"/Users/igortrindade/Code/goup-front/src/modules/professional/company/components/invoices/insights.vue\"],\"names\":[],\"mappings\":\"AACA,kCAAoC,aAAe,CAClD,AACD,+CAAiD,aAAe,CAC/D,AAGD,iCACI,eAAgB,AAChB,YAAgB,CACnB\",\"file\":\"insights.vue\",\"sourcesContent\":[\"\\n.row.insight-row[data-v-831fff60] { margin: 0 -5px;\\n}\\n.row.insight-row .insight-col[data-v-831fff60] { padding: 0 5px;\\n}\\n\\n/* canvas */\\n.canvas-default[data-v-831fff60] {\\n    max-width: 100%;\\n    min-height: 0px;\\n}\\n\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"id\":\"data-v-831fff60\",\"scoped\":true,\"hasInlineConfig\":false}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/modules/professional/company/components/invoices/insights.vue\n// module id = 1204\n// module chunks = 6","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"id\\\":\\\"data-v-831fff60\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./insights.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"6f8c0541\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"remove\":true}!./~/vue-style-loader!./~/css-loader?{\"minimize\":true,\"sourceMap\":true}!./~/vue-loader/lib/style-compiler?{\"id\":\"data-v-831fff60\",\"scoped\":true,\"hasInlineConfig\":false}!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/modules/professional/company/components/invoices/insights.vue\n// module id = 1302\n// module chunks = 6","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    staticClass: \"first-container\"\n  }, [_c('main-header', {\n    attrs: {\n      \"type\": 'center',\n      \"title\": 'Insights',\n      \"cursor\": false,\n      \"action\": function() {\n        return false\n      },\n      \"hasback\": true\n    }\n  }), _vm._v(\" \"), _c('div', {\n    staticClass: \"container\"\n  }, [_c('h2', {\n    staticClass: \"f-300 text-center m-b-30\"\n  }, [_vm._v(\"Faturas\")]), _vm._v(\" \"), _c('div', {\n    staticClass: \"text-center row m-t-30 insight-row\"\n  }, [_c('div', {\n    staticClass: \"col-md-4 col-xs-3 insight-col text-left\"\n  }, [_c('button', {\n    staticClass: \"btn btn-info p-5 p-l-10 p-r-10 btn-block\",\n    on: {\n      \"click\": function($event) {\n        _vm.handlePrevMonth()\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-ios-arrow-back\"\n  })])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-md-4 col-xs-6 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn btn-info p-5 p-l-10 p-r-10 btn-block\"\n  }, [_vm._v(_vm._s(_vm.current_month.format('MMMM')) + \" / \" + _vm._s(_vm.current_month.format('YYYY')))])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-md-4 col-xs-3 insight-col text-right\"\n  }, [_c('button', {\n    staticClass: \"btn btn-info p-5 p-l-10 p-r-10 btn-block\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleNextMonth()\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-ios-arrow-forward\"\n  })])])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"container m-t-30\"\n  }, [(_vm.currentValueReceived) ? _c('div', {\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-header ch-alt text-center\"\n  }, [_c('h4', {\n    staticClass: \"f-300 m-0 m-b-10\"\n  }, [_vm._v(\"Valor recebido em \" + _vm._s(_vm.current_month.format('MMMM')))]), _vm._v(\" \"), _c('span', {\n    staticClass: \"label label-success p-5 p-l-10 p-r-10 f-14\"\n  }, [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.currentValueReceived)))])])]) : _vm._e(), _vm._v(\" \"), _c('div', {\n    staticClass: \"row insight-row\"\n  }, _vm._l((_vm.invoices), function(invoice) {\n    return _c('div', {\n      staticClass: \"col-sm-2 col-xs-6 insight-col\"\n    }, [_c('div', {\n      staticClass: \"card\"\n    }, [_c('div', {\n      staticClass: \"card-header ch-alt text-center p-5\"\n    }, [_c('h4', {\n      staticClass: \"f-300 t-overflow m-t-10 m-b-10\"\n    }, [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(invoice.value)))]), _vm._v(\" \"), _c('p', [_vm._v(_vm._s(invoice.subscription.plan.category.name))]), _vm._v(\" \"), (invoice.is_confirmed) ? _c('span', {\n      staticClass: \"label label-success p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Confirmada\")]) : _vm._e(), _vm._v(\" \"), (invoice.is_canceled) ? _c('span', {\n      staticClass: \"label label-warning p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Cancelada\")]) : _vm._e(), _vm._v(\" \"), (!invoice.is_confirmed && !invoice.is_canceled && _vm.isExpired(invoice.expire_at) > -1) ? _c('span', {\n      staticClass: \"label label-default p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Aguardando\")]) : _vm._e(), _vm._v(\" \"), (!invoice.is_confirmed && !invoice.is_canceled && _vm.isExpired(invoice.expire_at) < -1) ? _c('span', {\n      staticClass: \"label label-danger p-5 p-l-10 p-r-10\"\n    }, [_vm._v(\"Atrasada\")]) : _vm._e(), _vm._v(\" \"), _c('hr'), _vm._v(\" \"), _c('small', {\n      staticClass: \"f-300\"\n    }, [_vm._v(\"vencimento em:\\n                            \" + _vm._s(invoice.expire_at) + \"\\n                        \")])])])])\n  }))]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (!_vm.invoices.length),\n      expression: \"!invoices.length\"\n    }],\n    staticClass: \"container\"\n  }, [_c('div', {\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body\"\n  }, [_c('p', {\n    staticClass: \"f-300 f-danger text-center m-t-10\"\n  }, [_vm._v(\"\\n                    Não foi possível localizar nenhuma fatura no mês de\\n                    \"), _c('strong', [_vm._v(_vm._s(_vm.current_month.format('MMMM')) + \" de \" + _vm._s(_vm.current_month.format('YYYY')))]), _vm._v(\".\\n                \")])])])]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.invoices.length),\n      expression: \"invoices.length\"\n    }],\n    staticClass: \"container\"\n  }, [_c('div', {\n    staticClass: \"row insight-row\"\n  }, [_c('div', {\n    staticClass: \"col-sm-12 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn f-18 btn-light btn-block f-300 m-b-10\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleChartType('by_status')\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-checkmark-round f-22 m-r-5\"\n  }), _vm._v(\"\\n                    Gráfico por status\\n                \")]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.interactions.chartByStatus),\n      expression: \"interactions.chartByStatus\"\n    }],\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body p-l-5 p-r-5 text-center\"\n  }, [_c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.invoices.length),\n      expression: \"invoices.length\"\n    }],\n    staticClass: \"text-center m-t-5 m-b-30\"\n  }, [_c('div', {\n    staticClass: \"row insight-row\"\n  }, [_c('div', {\n    staticClass: \"col-xs-6 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-success p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Confirmado\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.confirmed)))])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-xs-6 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-default p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Pendente\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.pending)))])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-xs-6 m-t-10 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-warning p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Cancelado\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.canceled)))])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-xs-6 m-t-10 insight-col\"\n  }, [_c('span', {\n    staticClass: \"btn btn-xs btn-block btn-danger p-5 p-l-10 p-r-10 f-12\"\n  }, [_vm._v(\"Atrasado\"), _c('br'), _vm._v(\" \"), _c('strong', [_vm._v(_vm._s(_vm._f(\"formatCurrency\")(_vm.statusCount.expired)))])])])])]), _vm._v(\" \"), _c('canvas', {\n    ref: \"chartByStatus\",\n    staticClass: \"canvas-default\"\n  })])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-sm-6 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn f-18 btn-light btn-block f-300 m-b-10\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleChartType('by_week')\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-stats-bars f-22 m-r-5\"\n  }), _vm._v(\"\\n                    Gráfico por semana\\n                \")]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.interactions.chartByWeek),\n      expression: \"interactions.chartByWeek\"\n    }],\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body text-center\"\n  }, [_c('canvas', {\n    ref: \"chartByWeek\",\n    staticClass: \"canvas-default\"\n  })])])]), _vm._v(\" \"), _c('div', {\n    staticClass: \"col-sm-6 insight-col\"\n  }, [_c('button', {\n    staticClass: \"btn f-18 btn-light btn-block f-300 m-b-10\",\n    on: {\n      \"click\": function($event) {\n        _vm.handleChartType('by_category')\n      }\n    }\n  }, [_c('i', {\n    staticClass: \"ion-ios-pie-outline f-22 m-r-5\"\n  }), _vm._v(\"\\n                    Gráfico de categorias\\n                \")]), _vm._v(\" \"), _c('div', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: (_vm.interactions.chartByCategory),\n      expression: \"interactions.chartByCategory\"\n    }],\n    staticClass: \"card\"\n  }, [_c('div', {\n    staticClass: \"card-body text-center\"\n  }, [_c('canvas', {\n    ref: \"chartByCategory\",\n    staticClass: \"canvas-default\"\n  })])])])])])], 1)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-831fff60\"}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/modules/professional/company/components/invoices/insights.vue\n// module id = 1486\n// module chunks = 6","\n/* styles */\nrequire(\"!!../../../../../../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true}!../../../../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"id\\\":\\\"data-v-831fff60\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./insights.vue\")\n\nvar Component = require(\"!../../../../../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./insights.vue\"),\n  /* template */\n  require(\"!!../../../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-831fff60\\\"}!../../../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./insights.vue\"),\n  /* scopeId */\n  \"data-v-831fff60\",\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/professional/company/components/invoices/insights.vue\n// module id = 422\n// module chunks = 6","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"moment-range\", [\"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moment-range\"] = factory(require(\"moment\"));\n\telse\n\t\troot[\"moment-range\"] = factory(root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 19);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(15)() ? Symbol : __webpack_require__(17);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar assign        = __webpack_require__(3)\n  , normalizeOpts = __webpack_require__(10)\n  , isCallable    = __webpack_require__(6)\n  , contains      = __webpack_require__(12)\n\n  , d;\n\nd = module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif ((arguments.length < 2) || (typeof dscr !== 'string')) {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (dscr == null) {\n\t\tc = w = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t\tw = contains.call(dscr, 'w');\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== 'string') {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (get == null) {\n\t\tget = undefined;\n\t} else if (!isCallable(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (set == null) {\n\t\tset = undefined;\n\t} else if (!isCallable(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (dscr == null) {\n\t\tc = true;\n\t\te = false;\n\t} else {\n\t\tc = contains.call(dscr, 'c');\n\t\te = contains.call(dscr, 'e');\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(4)()\n\t? Object.assign\n\t: __webpack_require__(5);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== 'function') return false;\n\tobj = { foo: 'raz' };\n\tassign(obj, { bar: 'dwa' }, { trzy: 'trzy' });\n\treturn (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';\n};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar keys  = __webpack_require__(7)\n  , value = __webpack_require__(11)\n\n  , max = Math.max;\n\nmodule.exports = function (dest, src/*, …srcn*/) {\n\tvar error, i, l = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry { dest[key] = src[key]; } catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < l; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Deprecated\n\n\n\nmodule.exports = function (obj) { return typeof obj === 'function'; };\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(8)()\n\t? Object.keys\n\t: __webpack_require__(9);\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys('primitive');\n\t\treturn true;\n\t} catch (e) { return false; }\n};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) {\n\treturn keys(object == null ? object : Object(object));\n};\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\nmodule.exports = function (options/*, …options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (options == null) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (value) {\n\tif (value == null) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(13)()\n\t? String.prototype.contains\n\t: __webpack_require__(14);\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar str = 'razdwatrzy';\n\nmodule.exports = function () {\n\tif (typeof str.contains !== 'function') return false;\n\treturn ((str.contains('dwa') === true) && (str.contains('foo') === false));\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar symbol;\n\tif (typeof Symbol !== 'function') return false;\n\tsymbol = Symbol('test symbol');\n\ttry { String(symbol); } catch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (x) {\n\tif (!x) return false;\n\tif (typeof x === 'symbol') return true;\n\tif (!x.constructor) return false;\n\tif (x.constructor.name !== 'Symbol') return false;\n\treturn (x[x.constructor.toStringTag] === 'Symbol');\n};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// ES2015 Symbol polyfill for environments that do not support it (or partially support it)\n\n\n\nvar d              = __webpack_require__(2)\n  , validateSymbol = __webpack_require__(18)\n\n  , create = Object.create, defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty, objPrototype = Object.prototype\n  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)\n  , isNativeSafe;\n\nif (typeof Symbol === 'function') {\n\tNativeSymbol = Symbol;\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n}\n\nvar generateName = (function () {\n\tvar created = create(null);\n\treturn function (desc) {\n\t\tvar postfix = 0, name, ie11BugWorkaround;\n\t\twhile (created[desc + (postfix || '')]) ++postfix;\n\t\tdesc += (postfix || '');\n\t\tcreated[desc] = true;\n\t\tname = '@@' + desc;\n\t\tdefineProperty(objPrototype, name, d.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t}));\n\t\treturn name;\n\t};\n}());\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = (description === undefined ? '' : String(description));\n\treturn defineProperties(symbol, {\n\t\t__description__: d('', description),\n\t\t__name__: d('', generateName(description))\n\t});\n};\ndefineProperties(SymbolPolyfill, {\n\tfor: d(function (key) {\n\t\tif (globalSymbols[key]) return globalSymbols[key];\n\t\treturn (globalSymbols[key] = SymbolPolyfill(String(key)));\n\t}),\n\tkeyFor: d(function (s) {\n\t\tvar key;\n\t\tvalidateSymbol(s);\n\t\tfor (key in globalSymbols) if (globalSymbols[key] === s) return key;\n\t}),\n\n\t// If there's native implementation of given symbol, let's fallback to it\n\t// to ensure proper interoperability with other native functions e.g. Array.from\n\thasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),\n\tisConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\tSymbolPolyfill('isConcatSpreadable')),\n\titerator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),\n\tmatch: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),\n\treplace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),\n\tsearch: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),\n\tspecies: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),\n\tsplit: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),\n\ttoPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),\n\ttoStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),\n\tunscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))\n});\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d('', function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {\n\tvar symbol = validateSymbol(this);\n\tif (typeof symbol === 'symbol') return symbol;\n\treturn symbol.toString();\n}));\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isSymbol = __webpack_require__(16);\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DateRange = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.extendMoment = extendMoment;\n\nvar _moment = __webpack_require__(1);\n\nvar _moment2 = _interopRequireDefault(_moment);\n\nvar _es6Symbol = __webpack_require__(0);\n\nvar _es6Symbol2 = _interopRequireDefault(_es6Symbol);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nvar INTERVALS = {\n  year: true,\n  quarter: true,\n  month: true,\n  week: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true\n};\n\n//-----------------------------------------------------------------------------\n// Date Ranges\n//-----------------------------------------------------------------------------\n\nvar DateRange = exports.DateRange = function () {\n  function DateRange(start, end) {\n    _classCallCheck(this, DateRange);\n\n    var s = start;\n    var e = end;\n\n    if (arguments.length === 1 || end === undefined) {\n      if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object' && start.length === 2) {\n        var _start = _slicedToArray(start, 2);\n\n        s = _start[0];\n        e = _start[1];\n      } else if (typeof start === 'string') {\n        var _start$split = start.split('/');\n\n        var _start$split2 = _slicedToArray(_start$split, 2);\n\n        s = _start$split2[0];\n        e = _start$split2[1];\n      }\n    }\n\n    this.start = s === null ? (0, _moment2.default)(-8640000000000000) : (0, _moment2.default)(s);\n    this.end = e === null ? (0, _moment2.default)(8640000000000000) : (0, _moment2.default)(e);\n  }\n\n  _createClass(DateRange, [{\n    key: 'adjacent',\n    value: function adjacent(other) {\n      var sameStartEnd = this.start.isSame(other.end);\n      var sameEndStart = this.end.isSame(other.start);\n\n      return sameStartEnd && other.start.valueOf() <= this.start.valueOf() || sameEndStart && other.end.valueOf() >= this.end.valueOf();\n    }\n  }, {\n    key: 'add',\n    value: function add(other) {\n      if (this.overlaps(other)) {\n        return new this.constructor(_moment2.default.min(this.start, other.start), _moment2.default.max(this.end, other.end));\n      }\n\n      return null;\n    }\n  }, {\n    key: 'by',\n    value: function by(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        var exclusive = options.exclusive || false;\n        var step = options.step || 1;\n        var diff = Math.abs(range.start.diff(range.end, interval)) / step;\n        var iteration = 0;\n\n        return {\n          next: function next() {\n            var current = range.start.clone().add(iteration * step, interval);\n            var done = exclusive ? !(iteration < diff) : !(iteration <= diff);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'byRange',\n    value: function byRange(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n      var step = options.step || 1;\n      var diff = this.valueOf() / interval.valueOf() / step;\n      var exclusive = options.exclusive || false;\n      var unit = Math.floor(diff);\n      var iteration = 0;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        if (unit === Infinity) {\n          return { done: true };\n        }\n\n        return {\n          next: function next() {\n            var current = (0, _moment2.default)(range.start.valueOf() + interval.valueOf() * iteration * step);\n            var done = unit === diff && exclusive ? !(iteration < unit) : !(iteration <= unit);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'center',\n    value: function center() {\n      var center = this.start.valueOf() + this.diff() / 2;\n\n      return (0, _moment2.default)(center);\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return new this.constructor(this.start, this.end);\n    }\n  }, {\n    key: 'contains',\n    value: function contains(other) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false };\n\n      var start = this.start.valueOf();\n      var end = this.end.valueOf();\n      var oStart = other.valueOf();\n      var oEnd = other.valueOf();\n\n      if (other instanceof DateRange) {\n        oStart = other.start.valueOf();\n        oEnd = other.end.valueOf();\n      }\n\n      var startInRange = start < oStart || start <= oStart && !options.exclusive;\n      var endInRange = end > oEnd || end >= oEnd && !options.exclusive;\n\n      return startInRange && endInRange;\n    }\n  }, {\n    key: 'diff',\n    value: function diff(unit, rounded) {\n      return this.end.diff(this.start, unit, rounded);\n    }\n  }, {\n    key: 'duration',\n    value: function duration(unit, rounded) {\n      return this.diff(unit, rounded);\n    }\n  }, {\n    key: 'intersect',\n    value: function intersect(other) {\n      var start = this.start.valueOf();\n      var end = this.end.valueOf();\n      var oStart = other.start.valueOf();\n      var oEnd = other.end.valueOf();\n\n      if (start <= oStart && oStart < end && end < oEnd) {\n        return new this.constructor(oStart, end);\n      } else if (oStart < start && start < oEnd && oEnd <= end) {\n        return new this.constructor(start, oEnd);\n      } else if (oStart < start && start <= end && end < oEnd) {\n        return this;\n      } else if (start <= oStart && oStart <= oEnd && oEnd <= end) {\n        return other;\n      }\n\n      return null;\n    }\n  }, {\n    key: 'isEqual',\n    value: function isEqual(other) {\n      return this.start.isSame(other.start) && this.end.isSame(other.end);\n    }\n  }, {\n    key: 'isSame',\n    value: function isSame(other) {\n      return this.isEqual(other);\n    }\n  }, {\n    key: 'overlaps',\n    value: function overlaps(other) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { adjacent: false };\n\n      var intersect = this.intersect(other) !== null;\n\n      if (options.adjacent && !intersect) {\n        return this.adjacent(other);\n      }\n\n      return intersect;\n    }\n  }, {\n    key: 'reverseBy',\n    value: function reverseBy(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        var exclusive = options.exclusive || false;\n        var step = options.step || 1;\n        var diff = Math.abs(range.start.diff(range.end, interval)) / step;\n        var iteration = 0;\n\n        return {\n          next: function next() {\n            var current = range.end.clone().subtract(iteration * step, interval);\n            var done = exclusive ? !(iteration < diff) : !(iteration <= diff);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'reverseByRange',\n    value: function reverseByRange(interval) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { exclusive: false, step: 1 };\n\n      var range = this;\n      var step = options.step || 1;\n      var diff = this.valueOf() / interval.valueOf() / step;\n      var exclusive = options.exclusive || false;\n      var unit = Math.floor(diff);\n      var iteration = 0;\n\n      return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n        if (unit === Infinity) {\n          return { done: true };\n        }\n\n        return {\n          next: function next() {\n            var current = (0, _moment2.default)(range.end.valueOf() - interval.valueOf() * iteration * step);\n            var done = unit === diff && exclusive ? !(iteration < unit) : !(iteration <= unit);\n\n            iteration++;\n\n            return {\n              done: done,\n              value: done ? undefined : current\n            };\n          }\n        };\n      });\n    }\n  }, {\n    key: 'subtract',\n    value: function subtract(other) {\n      var start = this.start.valueOf();\n      var end = this.end.valueOf();\n      var oStart = other.start.valueOf();\n      var oEnd = other.end.valueOf();\n\n      if (this.intersect(other) === null) {\n        return [this];\n      } else if (oStart <= start && start < end && end <= oEnd) {\n        return [];\n      } else if (oStart <= start && start < oEnd && oEnd < end) {\n        return [new this.constructor(oEnd, end)];\n      } else if (start < oStart && oStart < end && end <= oEnd) {\n        return [new this.constructor(start, oStart)];\n      } else if (start < oStart && oStart < oEnd && oEnd < end) {\n        return [new this.constructor(start, oStart), new this.constructor(oEnd, end)];\n      } else if (start < oStart && oStart < end && oEnd < end) {\n        return [new this.constructor(start, oStart), new this.constructor(oStart, end)];\n      }\n\n      return [];\n    }\n  }, {\n    key: 'toDate',\n    value: function toDate() {\n      return [this.start.toDate(), this.end.toDate()];\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.start.format() + '/' + this.end.format();\n    }\n  }, {\n    key: 'valueOf',\n    value: function valueOf() {\n      return this.end.valueOf() - this.start.valueOf();\n    }\n  }]);\n\n  return DateRange;\n}();\n\n//-----------------------------------------------------------------------------\n// Moment Extensions\n//-----------------------------------------------------------------------------\n\nfunction extendMoment(moment) {\n  /**\n   * Build a date range.\n   */\n  moment.range = function range(start, end) {\n    var m = this;\n\n    if (INTERVALS.hasOwnProperty(start)) {\n      return new DateRange(moment(m).startOf(start), moment(m).endOf(start));\n    }\n\n    return new DateRange(start, end);\n  };\n\n  /**\n   * Alias of static constructor.\n   */\n  moment.fn.range = moment.range;\n\n  /**\n   * Expose constructor\n   */\n  moment.range.constructor = DateRange;\n\n  /**\n   * Check if the current moment is within a given date range.\n   */\n  moment.fn.within = function (range) {\n    return range.contains(this.toDate());\n  };\n\n  return moment;\n}\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=moment-range.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/moment-range/dist/moment-range.js\n// module id = 865\n// module chunks = 0 2 3 4 5 6 8 13 15 16 21 22 23 24 27 33 37 38 39 40 42","/* MIT license */\nvar convert = require('color-convert');\nvar string = require('chartjs-color-string');\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = string.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = string.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = string.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn string.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn string.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn string.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn string.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn string.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn string.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn string.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn string.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = convert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nmodule.exports = Color;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chartjs-color/index.js\n// module id = 894\n// module chunks = 4 6 7","/**\n * @namespace Chart\n */\nvar Chart = require('./core/core.js')();\n\nrequire('./core/core.helpers')(Chart);\nrequire('./platforms/platform.js')(Chart);\nrequire('./core/core.canvasHelpers')(Chart);\nrequire('./core/core.element')(Chart);\nrequire('./core/core.plugin.js')(Chart);\nrequire('./core/core.animation')(Chart);\nrequire('./core/core.controller')(Chart);\nrequire('./core/core.datasetController')(Chart);\nrequire('./core/core.layoutService')(Chart);\nrequire('./core/core.scaleService')(Chart);\nrequire('./core/core.ticks.js')(Chart);\nrequire('./core/core.scale')(Chart);\nrequire('./core/core.interaction')(Chart);\nrequire('./core/core.tooltip')(Chart);\n\nrequire('./elements/element.arc')(Chart);\nrequire('./elements/element.line')(Chart);\nrequire('./elements/element.point')(Chart);\nrequire('./elements/element.rectangle')(Chart);\n\nrequire('./scales/scale.linearbase.js')(Chart);\nrequire('./scales/scale.category')(Chart);\nrequire('./scales/scale.linear')(Chart);\nrequire('./scales/scale.logarithmic')(Chart);\nrequire('./scales/scale.radialLinear')(Chart);\nrequire('./scales/scale.time')(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\nrequire('./controllers/controller.bar')(Chart);\nrequire('./controllers/controller.bubble')(Chart);\nrequire('./controllers/controller.doughnut')(Chart);\nrequire('./controllers/controller.line')(Chart);\nrequire('./controllers/controller.polarArea')(Chart);\nrequire('./controllers/controller.radar')(Chart);\n\nrequire('./charts/Chart.Bar')(Chart);\nrequire('./charts/Chart.Bubble')(Chart);\nrequire('./charts/Chart.Doughnut')(Chart);\nrequire('./charts/Chart.Line')(Chart);\nrequire('./charts/Chart.PolarArea')(Chart);\nrequire('./charts/Chart.Radar')(Chart);\nrequire('./charts/Chart.Scatter')(Chart);\n\n// Loading built-it plugins\nvar plugins = [];\n\nplugins.push(\n    require('./plugins/plugin.filler.js')(Chart),\n    require('./plugins/plugin.legend.js')(Chart),\n    require('./plugins/plugin.title.js')(Chart)\n);\n\nChart.plugins.register(plugins);\n\nmodule.exports = Chart;\nif (typeof window !== 'undefined') {\n\twindow.Chart = Chart;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/chart.js\n// module id = 907\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bar = function(context, config) {\n\t\tconfig.type = 'bar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/charts/Chart.Bar.js\n// module id = 908\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Bubble = function(context, config) {\n\t\tconfig.type = 'bubble';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/charts/Chart.Bubble.js\n// module id = 909\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Doughnut = function(context, config) {\n\t\tconfig.type = 'doughnut';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/charts/Chart.Doughnut.js\n// module id = 910\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Line = function(context, config) {\n\t\tconfig.type = 'line';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/charts/Chart.Line.js\n// module id = 911\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.PolarArea = function(context, config) {\n\t\tconfig.type = 'polarArea';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/charts/Chart.PolarArea.js\n// module id = 912\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tChart.Radar = function(context, config) {\n\t\tconfig.type = 'radar';\n\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/charts/Chart.Radar.js\n// module id = 913\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear', // scatter should not use a category axis\n\t\t\t\tposition: 'bottom',\n\t\t\t\tid: 'x-axis-1' // need an ID so datasets can reference the scale\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left',\n\t\t\t\tid: 'y-axis-1'\n\t\t\t}]\n\t\t},\n\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem) {\n\t\t\t\t\treturn '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Register the default config for this type\n\tChart.defaults.scatter = defaultConfig;\n\n\t// Scatter charts use line controllers\n\tChart.controllers.scatter = Chart.controllers.line;\n\n\tChart.Scatter = function(context, config) {\n\t\tconfig.type = 'scatter';\n\t\treturn new Chart(context, config);\n\t};\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/charts/Chart.Scatter.js\n// module id = 914\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.bar = {\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\n\t\t\t\t// Specific to Bar Controller\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t// grid line settings\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear'\n\t\t\t}]\n\t\t}\n\t};\n\n\tChart.controllers.bar = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Rectangle,\n\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\n\t\t\tChart.DatasetController.prototype.initialize.apply(me, arguments);\n\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar elements = me.getMeta().data;\n\t\t\tvar i, ilen;\n\n\t\t\tme._ruler = me.getRuler();\n\n\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(elements[i], i, reset);\n\t\t\t}\n\t\t},\n\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar rectangleOptions = chart.options.elements.rectangle;\n\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\n\t\t\trectangle._model = {\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: chart.data.labels[index],\n\t\t\t\tborderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n\t\t\t};\n\n\t\t\tme.updateElementGeometry(rectangle, index, reset);\n\n\t\t\trectangle.pivot();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tupdateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me.getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset? base : vpixels.base;\n\t\t\tmodel.x = horizontal? reset? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal? ipixels.center : reset? base : vpixels.head;\n\t\t\tmodel.height = horizontal? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal? undefined : ipixels.size;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScale: function() {\n\t\t\treturn this.getScaleForId(this.getValueScaleId());\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScale: function() {\n\t\t\treturn this.getScaleForId(this.getIndexScaleId());\n\t\t},\n\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn stacks.length;\n\t\t},\n\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex) {\n\t\t\treturn this.getStackCount(datasetIndex) - 1;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me.getIndexScale();\n\t\t\tvar options = scale.options;\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar fullSize = scale.isHorizontal()? scale.width : scale.height;\n\t\t\tvar tickSize = fullSize / scale.ticks.length;\n\t\t\tvar categorySize = tickSize * options.categoryPercentage;\n\t\t\tvar fullBarSize = categorySize / stackCount;\n\t\t\tvar barSize = fullBarSize * options.barPercentage;\n\n\t\t\tbarSize = Math.min(\n\t\t\t\thelpers.getValueOrDefault(options.barThickness, barSize),\n\t\t\t\thelpers.getValueOrDefault(options.maxBarThickness, Infinity));\n\n\t\t\treturn {\n\t\t\t\tstackCount: stackCount,\n\t\t\t\ttickSize: tickSize,\n\t\t\t\tcategorySize: categorySize,\n\t\t\t\tcategorySpacing: tickSize - categorySize,\n\t\t\t\tfullBarSize: fullBarSize,\n\t\t\t\tbarSize: barSize,\n\t\t\t\tbarSpacing: fullBarSize - barSize,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me.getValueScale();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = Number(datasets[datasetIndex].data[index]);\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller.getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\t\tivalue = Number(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = (head - base) / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar scale = ruler.scale;\n\t\t\tvar isCombo = me.chart.isCombo;\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex);\n\t\t\tvar base = scale.getPixelForValue(null, index, datasetIndex, isCombo);\n\t\t\tvar size = ruler.barSize;\n\n\t\t\tbase -= isCombo? ruler.tickSize / 2 : 0;\n\t\t\tbase += ruler.fullBarSize * stackIndex;\n\t\t\tbase += ruler.categorySpacing / 2;\n\t\t\tbase += ruler.barSpacing / 2;\n\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: base + size,\n\t\t\t\tcenter: base + size / 2\n\t\t\t};\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar elements = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\t\t\tvar d;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\td = dataset.data[i];\n\t\t\t\tif (d !== null && d !== undefined && !isNaN(d)) {\n\t\t\t\t\telements[i].draw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\t\t},\n\n\t\tsetHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(rectangle) {\n\t\t\tvar dataset = this.chart.data.datasets[rectangle._datasetIndex];\n\t\t\tvar index = rectangle._index;\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar model = rectangle._model;\n\t\t\tvar rectangleElementOptions = this.chart.options.elements.rectangle;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n\t\t}\n\t});\n\n\n\t// including horizontalBar in the bar file, instead of a file of its own\n\t// it extends bar (like pie extends doughnut)\n\tChart.defaults.horizontalBar = {\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'bottom'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\tposition: 'left',\n\t\t\t\ttype: 'category',\n\n\t\t\t\t// Specific to Horizontal Bar Controller\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\n\t\t\t\t// grid line settings\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}]\n\t\t},\n\t\telements: {\n\t\t\trectangle: {\n\t\t\t\tborderSkipped: 'left'\n\t\t\t}\n\t\t},\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t\t// Pick first xLabel for now\n\t\t\t\t\tvar title = '';\n\n\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\tif (tooltipItems[0].yLabel) {\n\t\t\t\t\t\t\ttitle = tooltipItems[0].yLabel;\n\t\t\t\t\t\t} else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\n\t\t\t\t\t\t\ttitle = data.labels[tooltipItems[0].index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn title;\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\treturn datasetLabel + ': ' + tooltipItem.xLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.horizontalBar = Chart.controllers.bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/controllers/controller.bar.js\n// module id = 915\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.bubble = {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\t\tposition: 'bottom',\n\t\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t},\n\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\t\t\t\tvar dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t\t\t\t\treturn datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.bubble = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar dsIndex = me.index;\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_xScale: xScale,\n\t\t\t\t_yScale: yScale,\n\t\t\t\t_datasetIndex: dsIndex,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\n\t\t\t\t\ty: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\n\t\t\t\t\t// Appearance\n\t\t\t\t\tradius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Trick to reset the styles of the point\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\n\n\t\t\tvar model = point._model;\n\t\t\tmodel.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\n\n\t\t\tpoint.pivot();\n\t\t},\n\n\t\tgetRadius: function(value) {\n\t\t\treturn value.r || this.chart.options.elements.point.radius;\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tChart.DatasetController.prototype.setHoverStyle.call(me, point);\n\n\t\t\t// Radius\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\n\n\t\t\tvar dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/controllers/controller.bubble.js\n// module id = 916\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tdefaults = Chart.defaults;\n\n\tdefaults.doughnut = {\n\t\tanimation: {\n\t\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\t\tanimateRotate: true,\n\t\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\t\tanimateScale: false\n\t\t},\n\t\taspectRatio: 1,\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t// toggle visibility of index if exists\n\t\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\n\t\t// The percentage of the chart that we cut out of the middle.\n\t\tcutoutPercentage: 50,\n\n\t\t// The rotation of the chart, where the first data arc begins.\n\t\trotation: Math.PI * -0.5,\n\n\t\t// The total circumference of the chart.\n\t\tcircumference: Math.PI * 2.0,\n\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\t\tif (helpers.isArray(dataLabel)) {\n\t\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataLabel += value;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn dataLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tdefaults.pie = helpers.clone(defaults.doughnut);\n\thelpers.extend(defaults.pie, {\n\t\tcutoutPercentage: 0\n\t});\n\n\n\tChart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ringIndex;\n\t\t},\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart,\n\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\topts = chart.options,\n\t\t\t\tarcOpts = opts.elements.arc,\n\t\t\t\tavailableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\n\t\t\t\tavailableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\n\t\t\t\tminSize = Math.min(availableWidth, availableHeight),\n\t\t\t\toffset = {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0\n\t\t\t\t},\n\t\t\t\tmeta = me.getMeta(),\n\t\t\t\tcutoutPercentage = opts.cutoutPercentage,\n\t\t\t\tcircumference = opts.circumference;\n\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\n\t\t\tchart.borderWidth = me.getMaxBorderWidth(meta.data);\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\t\tmeta.total = me.calculateTotal();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart,\n\t\t\t\tchartArea = chart.chartArea,\n\t\t\t\topts = chart.options,\n\t\t\t\tanimationOpts = opts.animation,\n\t\t\t\tcenterX = (chartArea.left + chartArea.right) / 2,\n\t\t\t\tcenterY = (chartArea.top + chartArea.bottom) / 2,\n\t\t\t\tstartAngle = opts.rotation, // non reset case handled later\n\t\t\t\tendAngle = opts.rotation, // non reset case handled later\n\t\t\t\tdataset = me.getDataset(),\n\t\t\t\tcircumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\n\t\t\t\tinnerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\n\t\t\t\touterRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\n\t\t\t\tvalueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar model = arc._model;\n\t\t\t// Resets the visual styles\n\t\t\tthis.removeHoverStyle(arc);\n\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\n\t\t\treturn total;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (value / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(elements) {\n\t\t\tvar max = 0,\n\t\t\t\tindex = this.index,\n\t\t\t\tlength = elements.length,\n\t\t\t\tborderWidth,\n\t\t\t\thoverWidth;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tborderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\n\t\t\t\thoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/controllers/controller.doughnut.js\n// module id = 917\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.line = {\n\t\tshowLines: true,\n\t\tspanGaps: false,\n\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\t\t\t\tid: 'x-axis-0'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t}\n\t};\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.getValueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: Chart.elements.Line,\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i=0, ilen=points.length; i<ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\t\t\tvar labels = me.chart.data.labels || [];\n\t\t\tvar includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar i = 0;\n\n\t\t\tChart.canvasHelpers.clipArea(chart.ctx, area);\n\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tChart.canvasHelpers.unclipArea(chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/controllers/controller.line.js\n// module id = 918\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.polarArea = {\n\n\t\tscale: {\n\t\t\ttype: 'radialLinear',\n\t\t\tangleLines: {\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\t\tgridLines: {\n\t\t\t\tcircular: true\n\t\t\t},\n\t\t\tpointLabels: {\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\t\tticks: {\n\t\t\t\tbeginAtZero: true\n\t\t\t}\n\t\t},\n\n\t\t// Boolean - Whether to animate the rotation of the chart\n\t\tanimation: {\n\t\t\tanimateRotate: true,\n\t\t\tanimateScale: true\n\t\t},\n\n\t\tstartAngle: -0.5 * Math.PI,\n\t\taspectRatio: 1,\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n\t\t\t\t\t\t\tvar stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n\t\t\t\t\t\t\tvar bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\treturn data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.polarArea = Chart.DatasetController.extend({\n\n\t\tdataElementType: Chart.elements.Arc,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar opts = chart.options;\n\t\t\tvar arcOpts = opts.elements.arc;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\t\tchart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\n\t\t\tmeta.count = me.countVisibleElements();\n\n\t\t\thelpers.each(meta.data, function(arc, index) {\n\t\t\t\tme.updateElement(arc, index, reset);\n\t\t\t});\n\t\t},\n\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n\t\t\tvar labels = chart.data.labels;\n\n\t\t\tvar circumference = me.calculateCircumference(dataset.data[index]);\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\n\t\t\t// If there is NaN data before us, we need to calculate the starting angle correctly.\n\t\t\t// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n\t\t\tvar visibleCount = 0;\n\t\t\tvar meta = me.getMeta();\n\t\t\tfor (var i = 0; i < index; ++i) {\n\t\t\t\tif (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n\t\t\t\t\t++visibleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = datasetStartAngle + (circumference * visibleCount);\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : circumference);\n\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\n\t\t\thelpers.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: getValueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply border and fill style\n\t\t\tme.removeHoverStyle(arc);\n\n\t\t\tarc.pivot();\n\t\t},\n\n\t\tremoveHoverStyle: function(arc) {\n\t\t\tChart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n\t\t},\n\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\n\t\t\thelpers.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn count;\n\t\t},\n\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar count = this.getMeta().count;\n\t\t\tif (count > 0 && !isNaN(value)) {\n\t\t\t\treturn (2 * Math.PI) / count;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/controllers/controller.polarArea.js\n// module id = 919\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.radar = {\n\t\taspectRatio: 1,\n\t\tscale: {\n\t\t\ttype: 'radialLinear'\n\t\t},\n\t\telements: {\n\t\t\tline: {\n\t\t\t\ttension: 0 // no bezier in radar\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.controllers.radar = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: Chart.elements.Line,\n\n\t\tdataElementType: Chart.elements.Point,\n\n\t\tlinkScales: helpers.noop,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data;\n\t\t\tvar custom = line.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar lineElementOptions = me.chart.options.elements.line;\n\t\t\tvar scale = me.chart.scale;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\thelpers.extend(meta.dataset, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_scale: scale,\n\t\t\t\t// Data\n\t\t\t\t_children: points,\n\t\t\t\t_loop: true,\n\t\t\t\t// Model\n\t\t\t\t_model: {\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmeta.dataset.pivot();\n\n\t\t\t// Update Points\n\t\t\thelpers.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t}, me);\n\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\t},\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointElementOptions = me.chart.options.elements.point;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\thelpers.extend(point, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tx: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\t\ty: reset ? scale.yCenter : pointPosition.y,\n\n\t\t\t\t\t// Appearance\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n\t\t\t\t\tradius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n\t\t\t\t\tpointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n\n\t\t\t\t\t// Tooltip\n\t\t\t\t\thitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpoint._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n\t\t},\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar chartArea = this.chart.chartArea;\n\t\t\tvar meta = this.getMeta();\n\n\t\t\thelpers.each(meta.data, function(point, index) {\n\t\t\t\tvar model = point._model;\n\t\t\t\tvar controlPoints = helpers.splineCurve(\n\t\t\t\t\thelpers.previousItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers.nextItem(meta.data, index, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\tmodel.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n\t\t\t\tmodel.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n\n\t\t\t\t// Now pivot the point for animation\n\t\t\t\tpoint.pivot();\n\t\t\t});\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar index = point._index;\n\t\t\tvar model = point._model;\n\t\t\tvar pointElementOptions = this.chart.options.elements.point;\n\n\t\t\tmodel.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/controllers/controller.radar.js\n// module id = 920\n// module chunks = 4 6 7","/* global window: false */\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.animation = {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t};\n\n\tChart.Animation = Chart.Element.extend({\n\t\tchart: null, // the animation associated chart instance\n\t\tcurrentStep: 0, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @param {Chart} chart - The chart to animate.\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t\t * @param {Number} duration - The animation duration in ms.\n\t\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chart, animation, duration, lazy) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar i, ilen;\n\n\t\t\tanimation.chart = chart;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchart.animating = true;\n\t\t\t}\n\n\t\t\tfor (i=0, ilen=animations.length; i < ilen; ++i) {\n\t\t\t\tif (animations[i].chart === chart) {\n\t\t\t\t\tanimations[i] = animation;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(animation);\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (animations.length === 1) {\n\t\t\t\tthis.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\tcancelAnimation: function(chart) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animation) {\n\t\t\t\treturn animation.chart === chart;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchart.animating = false;\n\t\t\t}\n\t\t},\n\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tme.advance(1 + framesToDrop);\n\n\t\t\tvar endTime = Date.now();\n\n\t\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tadvance: function(count) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar animation, chart;\n\t\t\tvar i = 0;\n\n\t\t\twhile (i < animations.length) {\n\t\t\t\tanimation = animations[i];\n\t\t\t\tchart = animation.chart;\n\n\t\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\n\t\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n\n\t\t\t\thelpers.callback(animation.render, [chart, animation], chart);\n\t\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\t\tif (animation.currentStep >= animation.numSteps) {\n\t\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\t\tchart.animating = false;\n\t\t\t\t\tanimations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation instead\n\t * @prop Chart.Animation#animationObject\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'animationObject', {\n\t\tget: function() {\n\t\t\treturn this;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\n\t * @prop Chart.Animation#chartInstance\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(Chart.Animation.prototype, 'chartInstance', {\n\t\tget: function() {\n\t\t\treturn this.chart;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.chart = value;\n\t\t}\n\t});\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.animation.js\n// module id = 921\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\t// Global Chart canvas helpers object for drawing items to canvas\n\tvar helpers = Chart.canvasHelpers = {};\n\n\thelpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\n\n\t\tif (typeof pointStyle === 'object') {\n\t\t\ttype = pointStyle.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2, pointStyle.width, pointStyle.height);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (pointStyle) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.beginPath();\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\n\t\t\tctx.moveTo(x - edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x + edgeLength / 2, y + height / 3);\n\t\t\tctx.lineTo(x, y - 2 * height / 3);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\tvar offset = radius / Math.SQRT2;\n\t\t\tvar leftX = x - offset;\n\t\t\tvar topY = y - offset;\n\t\t\tvar sideSize = Math.SQRT2 * radius;\n\t\t\tChart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'rectRot':\n\t\t\tsize = 1 / Math.SQRT2 * radius;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - size, y);\n\t\t\tctx.lineTo(x, y + size);\n\t\t\tctx.lineTo(x + size, y);\n\t\t\tctx.lineTo(x, y - size);\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t\tbreak;\n\t\tcase 'cross':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\tctx.beginPath();\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y + radius);\n\t\t\tctx.lineTo(x, y - radius);\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x - xOffset, y + yOffset);\n\t\t\tctx.lineTo(x + xOffset, y - yOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x - radius, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + radius, y);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.stroke();\n\t};\n\n\thelpers.clipArea = function(ctx, clipArea) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);\n\t\tctx.clip();\n\t};\n\n\thelpers.unclipArea = function(ctx) {\n\t\tctx.restore();\n\t};\n\n\thelpers.lineTo = function(ctx, previous, target, flip) {\n\t\tif (target.steppedLine) {\n\t\t\tif (target.steppedLine === 'after') {\n\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t} else {\n\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t}\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target.tension) {\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tctx.bezierCurveTo(\n\t\t\tflip? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\tflip? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\tflip? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\tflip? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\ttarget.x,\n\t\t\ttarget.y);\n\t};\n\n\tChart.helpers.canvas = helpers;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.canvasHelpers.js\n// module id = 922\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar plugins = Chart.plugins;\n\tvar platform = Chart.platform;\n\n\t// Create a dictionary of chart types, to allow for extension of existing types\n\tChart.types = {};\n\n\t// Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n\t// Destroy method on the chart will remove the instance of the chart from this reference.\n\tChart.instances = {};\n\n\t// Controllers available for dataset visualization eg. bar, line, slice, etc.\n\tChart.controllers = {};\n\n\t/**\n\t * Initializes the given config with global and chart default values.\n\t */\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\n\t\t// Do NOT use configMerge() for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\n\t\tconfig.options = helpers.configMerge(\n\t\t\tChart.defaults.global,\n\t\t\tChart.defaults[config.type],\n\t\t\tconfig.options || {});\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * Updates the config of the chart\n\t * @param chart {Chart} chart to update the options for\n\t */\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\n\t\t// Update Scale(s) with options\n\t\tif (newOptions.scale) {\n\t\t\tchart.scale.options = newOptions.scale;\n\t\t} else if (newOptions.scales) {\n\t\t\tnewOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {\n\t\t\t\tchart.scales[scaleOptions.id].options = scaleOptions;\n\t\t\t});\n\t\t}\n\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t}\n\n\tfunction positionIsHorizontal(position) {\n\t\treturn position === 'top' || position === 'bottom';\n\t}\n\n\thelpers.extend(Chart.prototype, /** @lends Chart */ {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tconstruct: function(item, config) {\n\t\t\tvar me = this;\n\n\t\t\tconfig = initConfig(config);\n\n\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\tvar canvas = context && context.canvas;\n\t\t\tvar height = canvas && canvas.height;\n\t\t\tvar width = canvas && canvas.width;\n\n\t\t\tme.id = helpers.uid();\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = canvas;\n\t\t\tme.config = config;\n\t\t\tme.width = width;\n\t\t\tme.height = height;\n\t\t\tme.aspectRatio = height? width / height : null;\n\t\t\tme.options = config.options;\n\t\t\tme._bufferedRender = false;\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t\t * @prop Chart#chart\n\t\t\t * @deprecated since version 2.6.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tme.chart = me;\n\t\t\tme.controller = me;  // chart.chart.controller #inception\n\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[me.id] = me;\n\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn me.config.data;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\tme.config.data = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!context || !canvas) {\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tme.initialize();\n\t\t\tme.update();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\n\t\t\t// Before init plugin notification\n\t\t\tplugins.notify(me, 'beforeInit');\n\n\t\t\thelpers.retinaScale(me);\n\n\t\t\tme.bindEvents();\n\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildScales();\n\t\t\tme.initToolTip();\n\n\t\t\t// After init plugin notification\n\t\t\tplugins.notify(me, 'afterInit');\n\n\t\t\treturn me;\n\t\t},\n\n\t\tclear: function() {\n\t\t\thelpers.clear(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tChart.animationService.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\t\t\tvar newWidth = Math.floor(helpers.getMaximumWidth(canvas));\n\t\t\tvar newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\n\n\t\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcanvas.width = me.width = newWidth;\n\t\t\tcanvas.height = me.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\n\t\t\thelpers.retinaScale(me);\n\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tplugins.notify(me, 'resize', [newSize]);\n\n\t\t\t\t// Notify of resize\n\t\t\t\tif (me.options.onResize) {\n\t\t\t\t\tme.options.onResize(me, newSize);\n\t\t\t\t}\n\n\t\t\t\tme.stop();\n\t\t\t\tme.update(me.options.responsiveAnimationDuration);\n\t\t\t}\n\t\t},\n\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\n\t\t\thelpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\n\t\t\thelpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales = {};\n\t\t\tvar items = [];\n\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({\n\t\t\t\t\toptions: options.scale,\n\t\t\t\t\tdtype: 'radialLinear',\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tdposition: 'chartArea'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\n\t\t\t\tvar scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n\t\t\t\tif (!scaleClass) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t\t}\n\n\t\t\t\tvar scale = new scaleClass({\n\t\t\t\t\tid: scaleOptions.id,\n\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\tchart: me\n\t\t\t\t});\n\n\t\t\t\tscales[scale.id] = scale;\n\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tChart.scaleService.addScalesToLayout(this);\n\t\t},\n\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar types = [];\n\t\t\tvar newControllers = [];\n\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tif (!meta.type) {\n\t\t\t\t\tmeta.type = dataset.type || me.config.type;\n\t\t\t\t}\n\n\t\t\t\ttypes.push(meta.type);\n\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t} else {\n\t\t\t\t\tvar ControllerClass = Chart.controllers[meta.type];\n\t\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\n\t\t\tif (types.length > 1) {\n\t\t\t\tfor (var i = 1; i < types.length; i++) {\n\t\t\t\t\tif (types[i] !== types[i - 1]) {\n\t\t\t\t\t\tme.isCombo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newControllers;\n\t\t},\n\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\n\t\tupdate: function(animationDuration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tupdateConfig(me);\n\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\n\t\t\tme.updateLayout();\n\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\thelpers.each(newControllers, function(controller) {\n\t\t\t\tcontroller.reset();\n\t\t\t});\n\n\t\t\tme.updateDatasets();\n\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tplugins.notify(me, 'afterUpdate');\n\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tlazy: lazy,\n\t\t\t\t\tduration: animationDuration\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(animationDuration, lazy);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tChart.layoutService.update(this, this.width, this.height);\n\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tplugins.notify(me, 'afterScaleUpdate');\n\t\t\tplugins.notify(me, 'afterLayout');\n\t\t},\n\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.updateDataset(i);\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\n\t\t/**\n\t\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDataset: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.update();\n\n\t\t\tplugins.notify(me, 'afterDatasetUpdate', [args]);\n\t\t},\n\n\t\trender: function(duration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar onComplete = function(animation) {\n\t\t\t\tplugins.notify(me, 'afterRender');\n\t\t\t\thelpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t\t};\n\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n\t\t\t\tvar animation = new Chart.Animation({\n\t\t\t\t\tnumSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\n\t\t\t\t\teasing: animationOptions.easing,\n\n\t\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers.easingEffects[animationObject.easing];\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t\t},\n\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\t\tonAnimationComplete: onComplete\n\t\t\t\t});\n\n\t\t\t\tChart.animationService.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\t\tonComplete(new Chart.Animation({numSteps: 0, chart: me}));\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tme.clear();\n\n\t\t\tif (easingValue === undefined || easingValue === null) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\n\t\t\tme.transition(easingValue);\n\n\t\t\tif (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw all the scales\n\t\t\thelpers.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\n\t\t\tif (me.scale) {\n\t\t\t\tme.scale.draw();\n\t\t\t}\n\n\t\t\tme.drawDatasets(easingValue);\n\n\t\t\t// Finally draw the tooltip\n\t\t\tme.tooltip.draw();\n\n\t\t\tplugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\ttransition: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tfor (var i=0, ilen=(me.data.datasets || []).length; i<ilen; ++i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.tooltip.transition(easingValue);\n\t\t},\n\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw datasets reversed to support proper line stacking\n\t\t\tfor (var i=(me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\n\t\t/**\n\t\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDataset: function(index, easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\n\t\t\tif (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmeta.controller.draw(easingValue);\n\n\t\t\tplugins.notify(me, 'afterDatasetDraw', [args]);\n\t\t},\n\n\t\t// Get the single element that was clicked on\n\t\t// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.single(this, e);\n\t\t},\n\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn Chart.Interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = Chart.Interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t},\n\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn Chart.Interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn meta;\n\t\t},\n\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar meta, i, ilen;\n\n\t\t\tme.stop();\n\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tmeta = me.getDatasetMeta(i);\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.destroy();\n\t\t\t\t\tmeta.controller = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers.clear(me);\n\t\t\t\tplatform.releaseContext(me.ctx);\n\t\t\t\tme.canvas = null;\n\t\t\t\tme.ctx = null;\n\t\t\t}\n\n\t\t\tplugins.notify(me, 'destroy');\n\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\n\t\ttoBase64Image: function() {\n\t\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t\t},\n\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new Chart.Tooltip({\n\t\t\t\t_chart: me,\n\t\t\t\t_chartInstance: me,            // deprecated, backward compatibility\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t\tme.tooltip.initialize();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\n\t\t\thelpers.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\n\t\t\t// Responsiveness is currently based on the use of an iframe, however this method causes\n\t\t\t// performance issues and could be troublesome when used with ad blockers. So make sure\n\t\t\t// that the user is still able to create a chart without iframe when responsive is false.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete me._listeners;\n\t\t\thelpers.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\n\t\t\tfor (i=0, ilen=elements.length; i<ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\n\t\t\tif (plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\tchanged |= tooltip && tooltip.handleEvent(e);\n\n\t\t\tplugins.notify(me, 'afterEvent', [e]);\n\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest.duration, bufferedRequest.lazy);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render(me.options.hover.animationDuration, true);\n\t\t\t}\n\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\n\t\t\treturn me;\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {Boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\n\t\t\tme.lastActive = me.lastActive || [];\n\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\n\t\t\t// On Hover hook\n\t\t\tif (hoverOptions.onHover) {\n\t\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\t\thoverOptions.onHover.call(me, e.native, me.active);\n\t\t\t}\n\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\n\t\t\tchanged = !helpers.arrayEquals(me.active, me.lastActive);\n\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * Provided for backward compatibility, use Chart instead.\n\t * @class Chart.Controller\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.Controller = Chart;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.controller.js\n// module id = 923\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\t\thelpers.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\n\t\tdelete array._chartjs;\n\t}\n\n\t// Base class for all dataset controllers (line, bar, etc)\n\tChart.DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\n\thelpers.extend(Chart.DatasetController.prototype, {\n\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\n\t\t\tif (meta.xAxisID === null) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\n\t\t\tfor (i=0, ilen=data.length; i<ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\tme._data = data;\n\t\t\t}\n\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\n\t\tupdate: helpers.noop,\n\n\t\ttransition: function(easingValue) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\telements[i].transition(easingValue);\n\t\t\t}\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.transition(easingValue);\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\telements[i].draw();\n\t\t\t}\n\t\t},\n\n\t\tremoveHoverStyle: function(element, elementOpts) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\tindex = element._index,\n\t\t\t\tcustom = element.custom || {},\n\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\tmodel = element._model;\n\n\t\t\tmodel.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n\t\t\tmodel.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n\t\t\tmodel.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n\t\t},\n\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex],\n\t\t\t\tindex = element._index,\n\t\t\t\tcustom = element.custom || {},\n\t\t\t\tvalueOrDefault = helpers.getValueAtIndexOrDefault,\n\t\t\t\tgetHoverColor = helpers.getHoverColor,\n\t\t\t\tmodel = element._model;\n\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i=0; i<count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tthis.insertElements(this.getDataset().data.length-1, arguments.length);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\n\tChart.DatasetController.extend = helpers.inherits;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.datasetController.js\n// module id = 924\n// module chunks = 4 6 7","'use strict';\n\nvar color = require('chartjs-color');\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tfunction interpolate(start, view, model, ease) {\n\t\tvar keys = Object.keys(model);\n\t\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\n\t\tfor (i=0, ilen=keys.length; i<ilen; ++i) {\n\t\t\tkey = keys[i];\n\n\t\t\ttarget = model[key];\n\n\t\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\t\tif (!view.hasOwnProperty(key)) {\n\t\t\t\tview[key] = target;\n\t\t\t}\n\n\t\t\tactual = view[key];\n\n\t\t\tif (actual === target || key[0] === '_') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!start.hasOwnProperty(key)) {\n\t\t\t\tstart[key] = actual;\n\t\t\t}\n\n\t\t\torigin = start[key];\n\n\t\t\ttype = typeof(target);\n\n\t\t\tif (type === typeof(origin)) {\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tc0 = color(origin);\n\t\t\t\t\tif (c0.valid) {\n\t\t\t\t\t\tc1 = color(target);\n\t\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (type === 'number' && isFinite(origin) && isFinite(target)) {\n\t\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tview[key] = target;\n\t\t}\n\t}\n\n\tChart.elements = {};\n\n\tChart.Element = function(configuration) {\n\t\thelpers.extend(this, configuration);\n\t\tthis.initialize.apply(this, arguments);\n\t};\n\n\thelpers.extend(Chart.Element.prototype, {\n\n\t\tinitialize: function() {\n\t\t\tthis.hidden = false;\n\t\t},\n\n\t\tpivot: function() {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\tme._view = helpers.clone(me._model);\n\t\t\t}\n\t\t\tme._start = {};\n\t\t\treturn me;\n\t\t},\n\n\t\ttransition: function(ease) {\n\t\t\tvar me = this;\n\t\t\tvar model = me._model;\n\t\t\tvar start = me._start;\n\t\t\tvar view = me._view;\n\n\t\t\t// No animation -> No Transition\n\t\t\tif (!model || ease === 1) {\n\t\t\t\tme._view = model;\n\t\t\t\tme._start = null;\n\t\t\t\treturn me;\n\t\t\t}\n\n\t\t\tif (!view) {\n\t\t\t\tview = me._view = {};\n\t\t\t}\n\n\t\t\tif (!start) {\n\t\t\t\tstart = me._start = {};\n\t\t\t}\n\n\t\t\tinterpolate(start, view, model, ease);\n\n\t\t\treturn me;\n\t\t},\n\n\t\ttooltipPosition: function() {\n\t\t\treturn {\n\t\t\t\tx: this._model.x,\n\t\t\t\ty: this._model.y\n\t\t\t};\n\t\t},\n\n\t\thasValue: function() {\n\t\t\treturn helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n\t\t}\n\t});\n\n\tChart.Element.extend = helpers.inherits;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.element.js\n// module id = 925\n// module chunks = 4 6 7","/* global window: false */\n/* global document: false */\n'use strict';\n\nvar color = require('chartjs-color');\n\nmodule.exports = function(Chart) {\n\t// Global Chart helpers object for utility methods and classes\n\tvar helpers = Chart.helpers = {};\n\n\t// -- Basic js utility methods\n\thelpers.each = function(loopable, callback, self, reverse) {\n\t\t// Check to see if null or undefined firstly.\n\t\tvar i, len;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tcallback.call(self, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typeof loopable === 'object') {\n\t\t\tvar keys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tcallback.call(self, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t};\n\thelpers.clone = function(obj) {\n\t\tvar objClone = {};\n\t\thelpers.each(obj, function(value, key) {\n\t\t\tif (helpers.isArray(value)) {\n\t\t\t\tobjClone[key] = value.slice(0);\n\t\t\t} else if (typeof value === 'object' && value !== null) {\n\t\t\t\tobjClone[key] = helpers.clone(value);\n\t\t\t} else {\n\t\t\t\tobjClone[key] = value;\n\t\t\t}\n\t\t});\n\t\treturn objClone;\n\t};\n\thelpers.extend = function(base) {\n\t\tvar setFn = function(value, key) {\n\t\t\tbase[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; i++) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn base;\n\t};\n\t// Need a special merge function to chart configs since they are now grouped\n\thelpers.configMerge = function(_base) {\n\t\tvar base = helpers.clone(_base);\n\t\thelpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\n\t\t\thelpers.each(extension, function(value, key) {\n\t\t\t\tvar baseHasProperty = base.hasOwnProperty(key);\n\t\t\t\tvar baseVal = baseHasProperty ? base[key] : {};\n\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// Scale config merging is complex. Add our own function here for that\n\t\t\t\t\tbase[key] = helpers.scaleMerge(baseVal, value);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// Used in polar area & radar charts since there is only one scale\n\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\n\t\t\t\t} else if (baseHasProperty\n\t\t\t\t\t\t&& typeof baseVal === 'object'\n\t\t\t\t\t\t&& !helpers.isArray(baseVal)\n\t\t\t\t\t\t&& baseVal !== null\n\t\t\t\t\t\t&& typeof value === 'object'\n\t\t\t\t\t\t&& !helpers.isArray(value)) {\n\t\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\t\tbase[key] = helpers.configMerge(baseVal, value);\n\t\t\t\t} else {\n\t\t\t\t\t// can just overwrite the value in this case\n\t\t\t\t\tbase[key] = value;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn base;\n\t};\n\thelpers.scaleMerge = function(_base, extension) {\n\t\tvar base = helpers.clone(_base);\n\n\t\thelpers.each(extension, function(value, key) {\n\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t// These properties are arrays of items\n\t\t\t\tif (base.hasOwnProperty(key)) {\n\t\t\t\t\thelpers.each(value, function(valueObj, index) {\n\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\tvar axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\n\t\t\t\t\t\tif (index >= base[key].length || !base[key][index].type) {\n\t\t\t\t\t\t\tbase[key].push(helpers.configMerge(axisDefaults, valueObj));\n\t\t\t\t\t\t} else if (valueObj.type && valueObj.type !== base[key][index].type) {\n\t\t\t\t\t\t\t// Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\n\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Type is the same\n\t\t\t\t\t\t\tbase[key][index] = helpers.configMerge(base[key][index], valueObj);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tbase[key] = [];\n\t\t\t\t\thelpers.each(value, function(valueObj) {\n\t\t\t\t\t\tvar axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n\t\t\t\t\t\tbase[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\n\t\t\t\t// If we are overwriting an object with an object, do a merge of the properties.\n\t\t\t\tbase[key] = helpers.configMerge(base[key], value);\n\n\t\t\t} else {\n\t\t\t\t// can just overwrite the value in this case\n\t\t\t\tbase[key] = value;\n\t\t\t}\n\t\t});\n\n\t\treturn base;\n\t};\n\thelpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tif (helpers.isArray(value)) {\n\t\t\treturn index < value.length ? value[index] : defaultValue;\n\t\t}\n\n\t\treturn value;\n\t};\n\thelpers.getValueOrDefault = function(value, defaultValue) {\n\t\treturn value === undefined ? defaultValue : value;\n\t};\n\thelpers.indexOf = Array.prototype.indexOf?\n\t\tfunction(array, item) {\n\t\t\treturn array.indexOf(item);\n\t\t}:\n\t\tfunction(array, item) {\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (array[i] === item) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.where = function(collection, filterCallback) {\n\t\tif (helpers.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers.findIndex = Array.prototype.findIndex?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (startIndex === undefined || startIndex === null) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.inherits = function(extensions) {\n\t\t// Basic javascript inheritance based on the model created in Backbone.js\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\n\t\treturn ChartElement;\n\t};\n\thelpers.noop = function() {};\n\thelpers.uid = (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}());\n\t// -- Math methods\n\thelpers.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers.sign = Math.sign?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers.log10 = Math.log10?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\treturn Math.log(x) / Math.LN10;\n\t\t};\n\thelpers.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x,\n\t\t\tdistanceFromYCenter = anglePoint.y - centrePoint.y,\n\t\t\tradialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\thelpers.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\thelpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint,\n\t\t\tcurrent = middlePoint,\n\t\t\tnext = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers.EPSILON = Number.EPSILON || 1e-14;\n\thelpers.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bézier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Easing functions adapted from Robert Penner's easing equations\n\t// http://www.robertpenner.com/easing/\n\tvar easingEffects = helpers.easingEffects = {\n\t\tlinear: function(t) {\n\t\t\treturn t;\n\t\t},\n\t\teaseInQuad: function(t) {\n\t\t\treturn t * t;\n\t\t},\n\t\teaseOutQuad: function(t) {\n\t\t\treturn -1 * t * (t - 2);\n\t\t},\n\t\teaseInOutQuad: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t;\n\t\t\t}\n\t\t\treturn -1 / 2 * ((--t) * (t - 2) - 1);\n\t\t},\n\t\teaseInCubic: function(t) {\n\t\t\treturn t * t * t;\n\t\t},\n\t\teaseOutCubic: function(t) {\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * t + 1);\n\t\t},\n\t\teaseInOutCubic: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t;\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * t + 2);\n\t\t},\n\t\teaseInQuart: function(t) {\n\t\t\treturn t * t * t * t;\n\t\t},\n\t\teaseOutQuart: function(t) {\n\t\t\treturn -1 * ((t = t / 1 - 1) * t * t * t - 1);\n\t\t},\n\t\teaseInOutQuart: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t * t;\n\t\t\t}\n\t\t\treturn -1 / 2 * ((t -= 2) * t * t * t - 2);\n\t\t},\n\t\teaseInQuint: function(t) {\n\t\t\treturn 1 * (t /= 1) * t * t * t * t;\n\t\t},\n\t\teaseOutQuint: function(t) {\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\n\t\t},\n\t\teaseInOutQuint: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * t * t * t * t * t;\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * t * t * t + 2);\n\t\t},\n\t\teaseInSine: function(t) {\n\t\t\treturn -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\n\t\t},\n\t\teaseOutSine: function(t) {\n\t\t\treturn 1 * Math.sin(t / 1 * (Math.PI / 2));\n\t\t},\n\t\teaseInOutSine: function(t) {\n\t\t\treturn -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\n\t\t},\n\t\teaseInExpo: function(t) {\n\t\t\treturn (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\n\t\t},\n\t\teaseOutExpo: function(t) {\n\t\t\treturn (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\n\t\t},\n\t\teaseInOutExpo: function(t) {\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (t === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * Math.pow(2, 10 * (t - 1));\n\t\t\t}\n\t\t\treturn 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\n\t\t},\n\t\teaseInCirc: function(t) {\n\t\t\tif (t >= 1) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\treturn -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\n\t\t},\n\t\teaseOutCirc: function(t) {\n\t\t\treturn 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\n\t\t},\n\t\teaseInOutCirc: function(t) {\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn -1 / 2 * (Math.sqrt(1 - t * t) - 1);\n\t\t\t}\n\t\t\treturn 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t\t},\n\t\teaseInElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1) === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * 0.3;\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t},\n\t\teaseOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1) === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * 0.3;\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\n\t\t},\n\t\teaseInOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 1 / 2) === 2) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 1 * (0.3 * 1.5);\n\t\t\t}\n\t\t\tif (a < Math.abs(1)) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\tif (t < 1) {\n\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\t},\n\t\teaseInBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1 * (t /= 1) * t * ((s + 1) * t - s);\n\t\t},\n\t\teaseOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\n\t\t},\n\t\teaseInOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tif ((t /= 1 / 2) < 1) {\n\t\t\t\treturn 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t\t}\n\t\t\treturn 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t\t},\n\t\teaseInBounce: function(t) {\n\t\t\treturn 1 - easingEffects.easeOutBounce(1 - t);\n\t\t},\n\t\teaseOutBounce: function(t) {\n\t\t\tif ((t /= 1) < (1 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * t * t);\n\t\t\t} else if (t < (2 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\n\t\t\t} else if (t < (2.5 / 2.75)) {\n\t\t\t\treturn 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\n\t\t\t}\n\t\t\treturn 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\n\t\t},\n\t\teaseInOutBounce: function(t) {\n\t\t\tif (t < 1 / 2) {\n\t\t\t\treturn easingEffects.easeInBounce(t * 2) * 0.5;\n\t\t\t}\n\t\t\treturn easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\n\t\t}\n\t};\n\t// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers.requestAnimFrame = (function() {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn function(callback) {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t}\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt,\n\t\t\tcanvas = evt.currentTarget || evt.srcElement,\n\t\t\tboundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\thelpers.addEvent = function(node, eventType, method) {\n\t\tif (node.addEventListener) {\n\t\t\tnode.addEventListener(eventType, method);\n\t\t} else if (node.attachEvent) {\n\t\t\tnode.attachEvent('on' + eventType, method);\n\t\t} else {\n\t\t\tnode['on' + eventType] = method;\n\t\t}\n\t};\n\thelpers.removeEvent = function(node, eventType, handler) {\n\t\tif (node.removeEventListener) {\n\t\t\tnode.removeEventListener(eventType, handler, false);\n\t\t} else if (node.detachEvent) {\n\t\t\tnode.detachEvent('on' + eventType, handler);\n\t\t} else {\n\t\t\tnode['on' + eventType] = helpers.noop;\n\t\t}\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof(styleValue) === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t// Private helper to get a constraint dimension\n\t// @param domNode : the node to check the constraint on\n\t// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n\t// @param percentageProperty : property of parent to use when calculating width as a percentage\n\t// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = domNode.parentNode;\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\thelpers.getMaximumWidth = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tvar paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n\t\tvar paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n\t\tvar w = container.clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers.getConstraintWidth(domNode);\n\t\treturn isNaN(cw)? w : Math.min(w, cw);\n\t};\n\thelpers.getMaximumHeight = function(domNode) {\n\t\tvar container = domNode.parentNode;\n\t\tvar paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n\t\tvar paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n\t\tvar h = container.clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers.getConstraintHeight(domNode);\n\t\treturn isNaN(ch)? h : Math.min(h, ch);\n\t};\n\thelpers.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers.retinaScale = function(chart) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tcanvas.style.height = height + 'px';\n\t\tcanvas.style.width = width + 'px';\n\t};\n\t// -- Canvas methods\n\thelpers.clear = function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t};\n\thelpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\thelpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t};\n\n\thelpers.color = !color?\n\t\tfunction(value) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn value;\n\t\t} :\n\t\tfunction(value) {\n\t\t\t/* global CanvasGradient */\n\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\tvalue = Chart.defaults.global.defaultColor;\n\t\t\t}\n\n\t\t\treturn color(value);\n\t\t};\n\n\thelpers.isArray = Array.isArray?\n\t\tfunction(obj) {\n\t\t\treturn Array.isArray(obj);\n\t\t} :\n\t\tfunction(obj) {\n\t\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t\t};\n\t// ! @see http://stackoverflow.com/a/14853974\n\thelpers.arrayEquals = function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen=a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\thelpers.callback = function(fn, args, thisArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\tfn.apply(thisArg, args);\n\t\t}\n\t};\n\thelpers.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern) ?\n\t\t\tcolorValue :\n\t\t\thelpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers#callback instead.\n\t * @function Chart.helpers#callCallback\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\thelpers.callCallback = helpers.callback;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.helpers.js\n// module id = 926\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Helper function to get relative position for an event\n\t * @param {Event|IEvent} event - The event to get the position for\n\t * @param {Chart} chart - The chart\n\t * @returns {Point} the event position\n\t */\n\tfunction getRelativePosition(e, chart) {\n\t\tif (e.native) {\n\t\t\treturn {\n\t\t\t\tx: e.x,\n\t\t\t\ty: e.y\n\t\t\t};\n\t\t}\n\n\t\treturn helpers.getRelativePosition(e, chart);\n\t}\n\n\t/**\n\t * Helper function to traverse all of the visible elements in the chart\n\t * @param chart {chart} the chart\n\t * @param handler {Function} the callback to execute for each visible item\n\t */\n\tfunction parseVisibleItems(chart, handler) {\n\t\tvar datasets = chart.data.datasets;\n\t\tvar meta, i, j, ilen, jlen;\n\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\t\tvar element = meta.data[j];\n\t\t\t\tif (!element._view.skip) {\n\t\t\t\t\thandler(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to get the items that intersect the event position\n\t * @param items {ChartElement[]} elements to filter\n\t * @param position {Point} the point to be nearest to\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getIntersectItems(chart, position) {\n\t\tvar elements = [];\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\n\t * @param chart {Chart} the chart to look at elements from\n\t * @param position {Point} the point to be nearest to\n\t * @param intersect {Boolean} if true, only consider items that intersect the position\n\t * @param distanceMetric {Function} Optional function to provide the distance between\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\tvar nearestItems = [];\n\n\t\tif (!distanceMetric) {\n\t\t\tdistanceMetric = helpers.distanceBetweenPoints;\n\t\t}\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar center = element.getCenterPoint();\n\t\t\tvar distance = distanceMetric(position, center);\n\n\t\t\tif (distance < minDistance) {\n\t\t\t\tnearestItems = [element];\n\t\t\t\tminDistance = distance;\n\t\t\t} else if (distance === minDistance) {\n\t\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\t\tnearestItems.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn nearestItems;\n\t}\n\n\tfunction indexMode(chart, e, options) {\n\t\tvar position = getRelativePosition(e, chart);\n\t\tvar distanceMetric = function(pt1, pt2) {\n\t\t\treturn Math.abs(pt1.x - pt2.x);\n\t\t};\n\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\tvar elements = [];\n\n\t\tif (!items.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex),\n\t\t\t\t\telement = meta.data[items[0]._index];\n\n\t\t\t\t// don't count items that are skipped (null data)\n\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * @interface IInteractionOptions\n\t */\n\t/**\n\t * If true, only consider items that intersect the point\n\t * @name IInterfaceOptions#boolean\n\t * @type Boolean\n\t */\n\n\t/**\n\t * Contains interaction related functions\n\t * @namespace Chart.Interaction\n\t */\n\tChart.Interaction = {\n\t\t// Helper function for different modes\n\t\tmodes: {\n\t\t\tsingle: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar elements = [];\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\treturn elements;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn elements.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.label\n\t\t\t * @deprecated since version 2.4.0\n\t \t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tlabel: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t\t * @function Chart.Interaction.modes.index\n\t\t\t * @since v2.4.0\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tindex: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t\t * @function Chart.Interaction.modes.dataset\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tdataset: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n\n\t\t\t\tif (items.length > 0) {\n\t\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t\t}\n\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.x-axis\n\t\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\t'x-axis': function(chart, e) {\n\t\t\t\treturn indexMode(chart, e, true);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Point mode returns all elements that hit test based on the event position\n\t\t\t * of the event\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tpoint: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\treturn getIntersectItems(chart, position);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * nearest mode returns the element closest to the point\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tnearest: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect);\n\n\t\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\t\tif (nearestItems.length > 1) {\n\t\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Return only 1 item\n\t\t\t\treturn nearestItems.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t\t * @function Chart.Interaction.modes.x\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tx: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t\t * @function Chart.Interaction.modes.y\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\ty: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.interaction.js\n// module id = 927\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function() {\n\n\t// Occupy the global variable of Chart, and create a simple base class\n\tvar Chart = function(item, config) {\n\t\tthis.construct(item, config);\n\t\treturn this;\n\t};\n\n\t// Globally expose the defaults to allow for user updating/changing\n\tChart.defaults = {\n\t\tglobal: {\n\t\t\tresponsive: true,\n\t\t\tresponsiveAnimationDuration: 0,\n\t\t\tmaintainAspectRatio: true,\n\t\t\tevents: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n\t\t\thover: {\n\t\t\t\tonHover: null,\n\t\t\t\tmode: 'nearest',\n\t\t\t\tintersect: true,\n\t\t\t\tanimationDuration: 400\n\t\t\t},\n\t\t\tonClick: null,\n\t\t\tdefaultColor: 'rgba(0,0,0,0.1)',\n\t\t\tdefaultFontColor: '#666',\n\t\t\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\t\tdefaultFontSize: 12,\n\t\t\tdefaultFontStyle: 'normal',\n\t\t\tshowLines: true,\n\n\t\t\t// Element defaults defined in element extensions\n\t\t\telements: {},\n\n\t\t\t// Legend callback string\n\t\t\tlegendCallback: function(chart) {\n\t\t\t\tvar text = [];\n\t\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\t\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t\ttext.push('</ul>');\n\n\t\t\t\treturn text.join('');\n\t\t\t}\n\t\t}\n\t};\n\n\tChart.Chart = Chart;\n\n\treturn Chart;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.js\n// module id = 928\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tfunction filterByPosition(array, position) {\n\t\treturn helpers.where(array, function(v) {\n\t\t\treturn v.position === position;\n\t\t});\n\t}\n\n\tfunction sortByWeight(array, reverse) {\n\t\tarray.forEach(function(v, i) {\n\t\t\tv._tmpIndex_ = i;\n\t\t\treturn v;\n\t\t});\n\t\tarray.sort(function(a, b) {\n\t\t\tvar v0 = reverse ? b : a;\n\t\t\tvar v1 = reverse ? a : b;\n\t\t\treturn v0.weight === v1.weight ?\n\t\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\t\tv0.weight - v1.weight;\n\t\t});\n\t\tarray.forEach(function(v) {\n\t\t\tdelete v._tmpIndex_;\n\t\t});\n\t}\n\n\t/**\n\t * @interface ILayoutItem\n\t * @prop {String} position - The position of the item in the chart layout. Possible values are\n\t * 'left', 'top', 'right', 'bottom', and 'chartArea'\n\t * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n\t * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n\t * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n\t * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n\t * @prop {Function} getPadding -  Returns an object with padding on the edges\n\t * @prop {Number} width - Width of item. Must be valid after update()\n\t * @prop {Number} height - Height of item. Must be valid after update()\n\t * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n\t */\n\n\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n\t// It is this service's responsibility of carrying out that layout.\n\tChart.layoutService = {\n\t\tdefaults: {},\n\n\t\t/**\n\t\t * Register a box to a chart.\n\t\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t\t * @param {Chart} chart - the chart to use\n\t\t * @param {ILayoutItem} item - the item to add to be layed out\n\t\t */\n\t\taddBox: function(chart, item) {\n\t\t\tif (!chart.boxes) {\n\t\t\t\tchart.boxes = [];\n\t\t\t}\n\n\t\t\t// initialize item with default values\n\t\t\titem.fullWidth = item.fullWidth || false;\n\t\t\titem.position = item.position || 'top';\n\t\t\titem.weight = item.weight || 0;\n\n\t\t\tchart.boxes.push(item);\n\t\t},\n\n\t\t/**\n\t\t * Remove a layoutItem from a chart\n\t\t * @param {Chart} chart - the chart to remove the box from\n\t\t * @param {Object} layoutItem - the item to remove from the layout\n\t\t */\n\t\tremoveBox: function(chart, layoutItem) {\n\t\t\tvar index = chart.boxes? chart.boxes.indexOf(layoutItem) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tchart.boxes.splice(index, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sets (or updates) options on the given `item`.\n\t\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t\t * @param {Object} item - the item to configure with the given options\n\t\t * @param {Object} options - the new item options.\n\t\t */\n\t\tconfigure: function(chart, item, options) {\n\t\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\t\tvar ilen = props.length;\n\t\t\tvar i = 0;\n\t\t\tvar prop;\n\n\t\t\tfor (; i<ilen; ++i) {\n\t\t\t\tprop = props[i];\n\t\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\t\titem[prop] = options[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t\t * then running a fitting algorithm\n\t\t * @param {Chart} chart - the chart\n\t\t * @param {Number} width - the width to fit into\n\t\t * @param {Number} height - the height to fit into\n\t\t */\n\t\tupdate: function(chart, width, height) {\n\t\t\tif (!chart) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar layoutOptions = chart.options.layout;\n\t\t\tvar padding = layoutOptions ? layoutOptions.padding : null;\n\n\t\t\tvar leftPadding = 0;\n\t\t\tvar rightPadding = 0;\n\t\t\tvar topPadding = 0;\n\t\t\tvar bottomPadding = 0;\n\n\t\t\tif (!isNaN(padding)) {\n\t\t\t\t// options.layout.padding is a number. assign to all\n\t\t\t\tleftPadding = padding;\n\t\t\t\trightPadding = padding;\n\t\t\t\ttopPadding = padding;\n\t\t\t\tbottomPadding = padding;\n\t\t\t} else {\n\t\t\t\tleftPadding = padding.left || 0;\n\t\t\t\trightPadding = padding.right || 0;\n\t\t\t\ttopPadding = padding.top || 0;\n\t\t\t\tbottomPadding = padding.bottom || 0;\n\t\t\t}\n\n\t\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\t\tsortByWeight(leftBoxes, true);\n\t\t\tsortByWeight(rightBoxes, false);\n\t\t\tsortByWeight(topBoxes, true);\n\t\t\tsortByWeight(bottomBoxes, false);\n\n\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t\t// Our canvas looks like the following.\n\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t\t// B1 is the bottom axis\n\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t\t// an error will be thrown.\n\t\t\t//\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  T1 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |    |    |                 T2                  |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    | C1 |                           | C2 |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    | C3 |                           | C4 |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    |                 B1                  |    |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  B2 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t//\n\t\t\t// What we do to find the best sizing, we do the following\n\t\t\t// 1. Determine the minimum size of the chart area.\n\t\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t\t// 6. Refit each axis\n\t\t\t// 7. Position each axis in the final location\n\t\t\t// 8. Tell the chart the final location of the chart area\n\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t\t// Step 1\n\t\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t\t// Step 2\n\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t\t// Step 3\n\t\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t\t// Step 4\n\t\t\tvar maxChartAreaWidth = chartWidth;\n\t\t\tvar maxChartAreaHeight = chartHeight;\n\t\t\tvar minBoxSizes = [];\n\n\t\t\tfunction getMinimumBoxSize(box) {\n\t\t\t\tvar minSize;\n\t\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t\t} else {\n\t\t\t\t\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\n\t\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t\t}\n\n\t\t\t\tminBoxSizes.push({\n\t\t\t\t\thorizontal: isHorizontal,\n\t\t\t\t\tminSize: minSize,\n\t\t\t\t\tbox: box,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\t\tvar maxHorizontalLeftPadding = 0;\n\t\t\tvar maxHorizontalRightPadding = 0;\n\t\t\tvar maxVerticalTopPadding = 0;\n\t\t\tvar maxVerticalBottomPadding = 0;\n\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\t\tif (verticalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t\t// be if the axes are drawn at their minimum sizes.\n\t\t\t// Steps 5 & 6\n\t\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\t\tvar totalRightBoxesWidth = rightPadding;\n\t\t\tvar totalTopBoxesHeight = topPadding;\n\t\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t\t// Function to fit a box\n\t\t\tfunction fitBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\t\treturn minBox.box === box;\n\t\t\t\t});\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\t// Set the Left and Right margins for the horizontal boxes\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\tfunction finalFitVerticalBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\t\treturn minSize.box === box;\n\t\t\t\t});\n\n\t\t\t\tvar scaleMargin = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t\t};\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the left layout know the final margin\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\t\ttotalLeftBoxesWidth = leftPadding;\n\t\t\ttotalRightBoxesWidth = rightPadding;\n\t\t\ttotalTopBoxesHeight = topPadding;\n\t\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\t// We may be adding some padding to account for rotated x axis labels\n\t\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t\t// without calling `fit` again\n\t\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t\t}\n\n\t\t\t// Step 7 - Position the boxes\n\t\t\tvar left = leftPadding + leftPaddingAddition;\n\t\t\tvar top = topPadding + topPaddingAddition;\n\n\t\t\tfunction placeBox(box) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\t\tbox.top = top;\n\t\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\ttop = box.bottom;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.left = left;\n\t\t\t\t\tbox.right = left + box.width;\n\t\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\tleft = box.right;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t\t// Account for chart width and height\n\t\t\tleft += maxChartAreaWidth;\n\t\t\ttop += maxChartAreaHeight;\n\n\t\t\thelpers.each(rightBoxes, placeBox);\n\t\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t\t// Step 8\n\t\t\tchart.chartArea = {\n\t\t\t\tleft: totalLeftBoxesWidth,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t\t};\n\n\t\t\t// Step 9\n\t\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\t\tbox.left = chart.chartArea.left;\n\t\t\t\tbox.top = chart.chartArea.top;\n\t\t\t\tbox.right = chart.chartArea.right;\n\t\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.layoutService.js\n// module id = 929\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.plugins = {};\n\n\t/**\n\t * The plugin service singleton\n\t * @namespace Chart.plugins\n\t * @since 2.1.0\n\t */\n\tChart.plugins = {\n\t\t/**\n\t\t * Globally registered plugins.\n\t\t * @private\n\t\t */\n\t\t_plugins: [],\n\n\t\t/**\n\t\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t\t * incremented and descriptors are regenerated during following API calls.\n\t\t * @private\n\t\t */\n\t\t_cacheId: 0,\n\n\t\t/**\n\t\t * Registers the given plugin(s) if not already registered.\n\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t */\n\t\tregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\t\tp.push(plugin);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Unregisters the given plugin(s) only if registered.\n\t\t * @param {Array|Object} plugins plugin instance(s).\n\t\t */\n\t\tunregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tvar idx = p.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tp.splice(idx, 1);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Remove all registered plugins.\n\t\t * @since 2.1.5\n\t\t */\n\t\tclear: function() {\n\t\t\tthis._plugins = [];\n\t\t\tthis._cacheId++;\n\t\t},\n\n\t\t/**\n\t\t * Returns the number of registered plugins?\n\t\t * @returns {Number}\n\t\t * @since 2.1.5\n\t\t */\n\t\tcount: function() {\n\t\t\treturn this._plugins.length;\n\t\t},\n\n\t\t/**\n\t\t * Returns all registered plugin instances.\n\t\t * @returns {Array} array of plugin objects.\n\t\t * @since 2.1.5\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn this._plugins;\n\t\t},\n\n\t\t/**\n\t\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t\t * returned value can be used, for instance, to interrupt the current action.\n\t\t * @param {Object} chart - The chart instance for which plugins should be called.\n\t\t * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t\t * @returns {Boolean} false if any of the plugins return false, else returns true.\n\t\t */\n\t\tnotify: function(chart, hook, args) {\n\t\t\tvar descriptors = this.descriptors(chart);\n\t\t\tvar ilen = descriptors.length;\n\t\t\tvar i, descriptor, plugin, params, method;\n\n\t\t\tfor (i=0; i<ilen; ++i) {\n\t\t\t\tdescriptor = descriptors[i];\n\t\t\t\tplugin = descriptor.plugin;\n\t\t\t\tmethod = plugin[hook];\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\t\tparams.push(descriptor.options);\n\t\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Returns descriptors of enabled plugins for the given chart.\n\t\t * @returns {Array} [{ plugin, options }]\n\t\t * @private\n\t\t */\n\t\tdescriptors: function(chart) {\n\t\t\tvar cache = chart._plugins || (chart._plugins = {});\n\t\t\tif (cache.id === this._cacheId) {\n\t\t\t\treturn cache.descriptors;\n\t\t\t}\n\n\t\t\tvar plugins = [];\n\t\t\tvar descriptors = [];\n\t\t\tvar config = (chart && chart.config) || {};\n\t\t\tvar defaults = Chart.defaults.global.plugins;\n\t\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar id = plugin.id;\n\t\t\t\tvar opts = options[id];\n\t\t\t\tif (opts === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (opts === true) {\n\t\t\t\t\topts = helpers.clone(defaults[id]);\n\t\t\t\t}\n\n\t\t\t\tplugins.push(plugin);\n\t\t\t\tdescriptors.push({\n\t\t\t\t\tplugin: plugin,\n\t\t\t\t\toptions: opts || {}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcache.descriptors = descriptors;\n\t\t\tcache.id = this._cacheId;\n\t\t\treturn descriptors;\n\t\t}\n\t};\n\n\t/**\n\t * Plugin extension hooks.\n\t * @interface IPlugin\n\t * @since 2.1.0\n\t */\n\t/**\n\t * @method IPlugin#beforeInit\n\t * @desc Called before initializing `chart`.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#afterInit\n\t * @desc Called after `chart` has been initialized and before the first update.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeUpdate\n\t * @desc Called before updating `chart`. If any plugin returns `false`, the update\n\t * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart update.\n\t */\n\t/**\n\t * @method IPlugin#afterUpdate\n\t * @desc Called after `chart` has been updated and before rendering. Note that this\n\t * hook will not be called if the chart update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetsUpdate\n \t * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n\t * the datasets update is cancelled until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} false to cancel the datasets update.\n\t * @since version 2.1.5\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetsUpdate\n\t * @desc Called after the `chart` datasets have been updated. Note that this hook\n\t * will not be called if the datasets update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @since version 2.1.5\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetUpdate\n \t * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n\t * returns `false`, the datasets update is cancelled until another `update` is triggered.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetUpdate\n \t * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n\t * that this hook will not be called if the datasets update has been previously cancelled.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeLayout\n\t * @desc Called before laying out `chart`. If any plugin returns `false`,\n\t * the layout update is cancelled until another `update` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart layout.\n\t */\n\t/**\n\t * @method IPlugin#afterLayout\n\t * @desc Called after the `chart` has been layed out. Note that this hook will not\n\t * be called if the layout update has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeRender\n\t * @desc Called before rendering `chart`. If any plugin returns `false`,\n\t * the rendering is cancelled until another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart rendering.\n\t */\n\t/**\n\t * @method IPlugin#afterRender\n\t * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n\t * that this hook will not be called if the rendering has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDraw\n\t * @desc Called before drawing `chart` at every animation frame specified by the given\n\t * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n\t * another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDraw\n\t * @desc Called after the `chart` has been drawn for the specific easing value. Note\n\t * that this hook will not be called if the drawing has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetsDraw\n \t * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n\t * the datasets drawing is cancelled until another `render` is triggered.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetsDraw\n\t * @desc Called after the `chart` datasets have been drawn. Note that this hook\n\t * will not be called if the datasets drawing has been previously cancelled.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeDatasetDraw\n \t * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n\t * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n\t * is cancelled until another `render` is triggered.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t * @returns {Boolean} `false` to cancel the chart datasets drawing.\n\t */\n\t/**\n\t * @method IPlugin#afterDatasetDraw\n \t * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n\t * (datasets are drawn in the reverse order). Note that this hook will not be called\n\t * if the datasets drawing has been previously cancelled.\n\t * @param {Chart} chart - The chart instance.\n\t * @param {Object} args - The call arguments.\n\t * @param {Object} args.index - The dataset index.\n\t * @param {Number} args.meta - The dataset metadata.\n\t * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#beforeEvent\n \t * @desc Called before processing the specified `event`. If any plugin returns `false`,\n\t * the event will be discarded.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {IEvent} event - The event object.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#afterEvent\n\t * @desc Called after the `event` has been consumed. Note that this hook\n\t * will not be called if the `event` has been previously discarded.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {IEvent} event - The event object.\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#resize\n\t * @desc Called after the chart as been resized.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Number} size - The new canvas display size (eq. canvas.style width & height).\n\t * @param {Object} options - The plugin options.\n\t */\n\t/**\n\t * @method IPlugin#destroy\n\t * @desc Called after the chart as been destroyed.\n\t * @param {Chart.Controller} chart - The chart instance.\n\t * @param {Object} options - The plugin options.\n\t */\n\n\t/**\n\t * Provided for backward compatibility, use Chart.plugins instead\n\t * @namespace Chart.pluginService\n\t * @deprecated since version 2.1.5\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.pluginService = Chart.plugins;\n\n\t/**\n\t * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n\t * effect, instead simply create/register plugins via plain JavaScript objects.\n\t * @interface Chart.PluginBase\n\t * @deprecated since version 2.5.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.PluginBase = Chart.Element.extend({});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.plugin.js\n// module id = 930\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.scale = {\n\t\tdisplay: true,\n\t\tposition: 'left',\n\n\t\t// grid line settings\n\t\tgridLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1,\n\t\t\tdrawBorder: true,\n\t\t\tdrawOnChartArea: true,\n\t\t\tdrawTicks: true,\n\t\t\ttickMarkLength: 10,\n\t\t\tzeroLineWidth: 1,\n\t\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\t\tzeroLineBorderDash: [],\n\t\t\tzeroLineBorderDashOffset: 0.0,\n\t\t\toffsetGridLines: false,\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0\n\t\t},\n\n\t\t// scale label\n\t\tscaleLabel: {\n\t\t\t// actual label\n\t\t\tlabelString: '',\n\n\t\t\t// display property\n\t\t\tdisplay: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tbeginAtZero: false,\n\t\t\tminRotation: 0,\n\t\t\tmaxRotation: 50,\n\t\t\tmirror: false,\n\t\t\tpadding: 0,\n\t\t\treverse: false,\n\t\t\tdisplay: true,\n\t\t\tautoSkip: true,\n\t\t\tautoSkipPadding: 0,\n\t\t\tlabelOffset: 0,\n\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\t\tcallback: Chart.Ticks.formatters.values\n\t\t}\n\t};\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\tvar size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tChart.Scale = Chart.Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks\n\t\t\tme.beforeBuildTicks();\n\t\t\tme.buildTicks();\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\t\t\tme.convertTicksToLabels();\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation;\n\t\t\t\tvar sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += scaleLabelFontSize;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += scaleLabelFontSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * tallestLabelHeightInLines);\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\n\t\t\t\t\tvar firstTick = me.ticks[0];\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\n\n\t\t\t\t\tvar lastTick = me.ticks[me.ticks.length - 1];\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n\t\t\t\t\t// by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n\t\t\t\t\t// Account for padding\n\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlargestTextWidth += me.options.ticks.padding;\n\t\t\t\t\t}\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (rawValue === null || typeof(rawValue) === 'undefined') {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (typeof(rawValue) === 'object') {\n\t\t\t\tif ((rawValue instanceof Date) || (rawValue.isValid)) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t}\n\t\t\t\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t// Used to get the value to display in the tooltip for the data at the given index\n\t\t// function getLabelForIndex(index, datasetIndex)\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t// Used for tick location, should\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (includeOffset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));\n\t\t},\n\n\t\t// Utility for getting the pixel location of a percentage of scale\n\t\tgetPixelForDecimal: function(decimal /* , includeOffset*/) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\tvar optionTicks = options.ticks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar skipRatio;\n\t\t\tvar useAutoskipper = optionTicks.autoSkip;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\t\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\n\t\t\t// Make sure we draw text in the correct color and font\n\t\t\tcontext.fillStyle = tickFontColor;\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && me.ticks.length > maxTicks) {\n\t\t\t\t\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n\t\t\t\t\t\tif (!skipRatio) {\n\t\t\t\t\t\t\tskipRatio = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tskipRatio += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!useAutoskipper) {\n\t\t\t\t\tskipRatio = false;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n\n\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t// If the callback returned a null or undefined value, do not draw this line\n\t\t\t\tif (label === undefined || label === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar isLastTick = me.ticks.length === index + 1;\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\n\t\t\t\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\tborderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\n\t\t\t\tif (isHorizontal) {\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated? 'top':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'right';\n\t\t\t\t\t\tlabelY = me.top + tl;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated? 'bottom':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'left';\n\t\t\t\t\t\tlabelY = me.bottom - tl;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n\t\t\t\t\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar tickPadding = optionTicks.padding;\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\t\t\t\t\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = tickFont.font;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tfor (var i = 0, y = 0; i < label.length; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += (tickFont.size * 1.5);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left,\n\t\t\t\t\tx2 = me.right,\n\t\t\t\t\ty1 = me.top,\n\t\t\t\t\ty2 = me.bottom;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.scale.js\n// module id = 931\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, defaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers.clone(defaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar defaults = this.defaults;\n\t\t\tif (defaults.hasOwnProperty(type)) {\n\t\t\t\tdefaults[type] = helpers.extend(defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chart) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers.each(chart.scales, function(scale) {\n\t\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\t\tscale.position = scale.options.position;\n\t\t\t\tscale.weight = scale.options.weight;\n\t\t\t\tChart.layoutService.addBox(chart, scale);\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.scaleService.js\n// module id = 932\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Namespace to hold static tick generation functions\n\t * @namespace Chart.Ticks\n\t */\n\tChart.Ticks = {\n\t\t/**\n\t\t * Namespace to hold generators for different types of ticks\n\t\t * @namespace Chart.Ticks.generators\n\t\t */\n\t\tgenerators: {\n\t\t\t/**\n\t\t\t * Interface for the options provided to the numeric tick generator\n\t\t\t * @interface INumericTickGenerationOptions\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum number of ticks to display\n\t\t\t * @name INumericTickGenerationOptions#maxTicks\n\t\t\t * @type Number\n\t\t\t */\n\t\t\t/**\n\t\t\t * The distance between each tick.\n\t\t\t * @name INumericTickGenerationOptions#stepSize\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n\t\t\t * @name INumericTickGenerationOptions#min\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n\t\t\t * @name INumericTickGenerationOptions#max\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\n\t\t\t/**\n\t\t\t * Generate a set of linear ticks\n\t\t\t * @method Chart.Ticks.generators.linear\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlinear: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t\t// for details.\n\n\t\t\t\tvar spacing;\n\t\t\t\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\t\t\t\tspacing = generationOptions.stepSize;\n\t\t\t\t} else {\n\t\t\t\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\t\t\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t\t\t\t}\n\t\t\t\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\t\t\t\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t\t\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\t\t\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t\t\t\t// If very close to our whole number, use it.\n\t\t\t\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\t\t\t\tniceMin = generationOptions.min;\n\t\t\t\t\t\tniceMax = generationOptions.max;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\t\t\t// If very close to our rounded value, use it.\n\t\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t\t}\n\n\t\t\t\t// Put the values into the ticks array\n\t\t\t\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\t\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\t\tticks.push(niceMin + (j * spacing));\n\t\t\t\t}\n\t\t\t\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\t\t\t\treturn ticks;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Generate a set of logarithmic ticks\n\t\t\t * @method Chart.Ticks.generators.logarithmic\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlogarithmic: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t// the graph\n\t\t\t\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\t\t\t\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\t\t\t\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\t\t\tvar exp;\n\t\t\t\tvar significand;\n\n\t\t\t\tif (tickVal === 0) {\n\t\t\t\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\t\t\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\t\t\t\tticks.push(tickVal);\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} else {\n\t\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tticks.push(tickVal);\n\n\t\t\t\t\t++significand;\n\t\t\t\t\tif (significand === 10) {\n\t\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t\t++exp;\n\t\t\t\t\t}\n\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\t\t\t\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\n\t\t\t\tticks.push(lastTick);\n\n\t\t\t\treturn ticks;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Namespace to hold formatters for different types of ticks\n\t\t * @namespace Chart.Ticks.formatters\n\t\t */\n\t\tformatters: {\n\t\t\t/**\n\t\t\t * Formatter for value labels\n\t\t\t * @method Chart.Ticks.formatters.values\n\t\t\t * @param value the value to display\n\t\t\t * @return {String|Array} the label to display\n\t\t\t */\n\t\t\tvalues: function(value) {\n\t\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Formatter for linear numeric ticks\n\t\t\t * @method Chart.Ticks.formatters.linear\n\t\t\t * @param tickValue {Number} the value to be formatted\n\t\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t\t * @return {String} string representation of the tickValue parameter\n\t\t\t */\n\t\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\t\tvar tickString = '';\n\n\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t} else {\n\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t}\n\n\t\t\t\treturn tickString;\n\t\t\t},\n\n\t\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\t\tif (tickValue === 0) {\n\t\t\t\t\treturn '0';\n\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\t\treturn tickValue.toExponential();\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.ticks.js\n// module id = 933\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t/**\n \t * Helper method to merge the opacity into a color\n \t */\n\tfunction mergeOpacity(colorString, opacity) {\n\t\tvar color = helpers.color(colorString);\n\t\treturn color.alpha(opacity * color.alpha()).rgbaString();\n\t}\n\n\tChart.defaults.global.tooltips = {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t// Pick first xLabel for now\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\n\t\t\t\t\tif (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tafterLabel: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers.noop,\n\t\t\tfooter: helpers.noop,\n\t\t\tafterFooter: helpers.noop\n\t\t}\n\t};\n\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\n\t\treturn base;\n\t}\n\n\t// Private helper to create a tooltip item model\n\t// @param element : the chart element (point, arc, bar) to create the tooltip item for\n\t// @return : new tooltip item\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index,\n\t\t\tdatasetIndex = element._datasetIndex;\n\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {Object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors,\n\t\t\tborderColor: tooltipOpts.borderColor,\n\t\t\tborderWidth: tooltipOpts.borderWidth\n\t\t};\n\t}\n\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize,\n\t\t\tbodyFontSize = model.bodyFontSize,\n\t\t\tfooterFontSize = model.footerFontSize;\n\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\n\t\tctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers.each(model.title, maxLineWidth);\n\n\t\t// Body width\n\t\tctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers.each(body, function(bodyItem) {\n\t\t\thelpers.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers.each(bodyItem.after, maxLineWidth);\n\t\t});\n\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\n\t\t// Footer width\n\t\tctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers.each(model.footer, maxLineWidth);\n\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chart.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\n\t\tolf = function(x) {\n\t\t\treturn x + size.width > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\n\t/**\n\t * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\n\t\tvar caretSize = vm.caretSize,\n\t\t\tcaretPadding = vm.caretPadding,\n\t\t\tcornerRadius = vm.cornerRadius,\n\t\t\txAlign = alignment.xAlign,\n\t\t\tyAlign = alignment.yAlign,\n\t\t\tpaddingAndSize = caretSize + caretPadding,\n\t\t\tradiusAndPadding = cornerRadius + caretPadding;\n\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t}\n\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\n\tChart.Tooltip = Chart.Element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t},\n\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments),\n\t\t\t\ttitle = callbacks.title.apply(me, arguments),\n\t\t\t\tafterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeTitle);\n\t\t\tlines = pushOrConcat(lines, title);\n\t\t\tlines = pushOrConcat(lines, afterTitle);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\tvar lines = this._options.callbacks.beforeBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\n\t\t\treturn bodyItems;\n\t\t},\n\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\tvar lines = this._options.callbacks.afterBody.apply(this, arguments);\n\t\t\treturn helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n\t\t},\n\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, beforeFooter);\n\t\t\tlines = pushOrConcat(lines, footer);\n\t\t\tlines = pushOrConcat(lines, afterFooter);\n\n\t\t\treturn lines;\n\t\t},\n\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\n\t\t\tvar data = me._data;\n\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\n\t\t\tvar i, len;\n\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\n\t\t\t\tvar labelColors = [];\n\t\t\t\ttooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\n\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\t});\n\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = Math.round(tooltipPosition.x);\n\t\t\t\tmodel.y = Math.round(tooltipPosition.y);\n\t\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\t\tmodel.labelColors = labelColors;\n\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\n\t\t\tme._model = model;\n\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\n\t\t\treturn me;\n\t\t},\n\t\tdrawCaret: function(tooltipPoint, size) {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\n\t\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t},\n\t\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\t\tvar x1, x2, x3;\n\t\t\tvar y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign,\n\t\t\t\tyAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x,\n\t\t\t\tptY = tooltipPoint.y;\n\t\t\tvar width = size.width,\n\t\t\t\theight = size.height;\n\n\t\t\tif (yAlign === 'center') {\n\t\t\t\ty2 = ptY + (height / 2);\n\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\t\ty3 = y2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = ptX + (width / 2);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t\t// invert drawing order\n\t\t\t\t\tvar tmp = x3;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t\t},\n\t\tdrawTitle: function(pt, vm, ctx, opacity) {\n\t\t\tvar title = vm.title;\n\n\t\t\tif (title.length) {\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tvar titleFontSize = vm.titleFontSize,\n\t\t\t\t\ttitleSpacing = vm.titleSpacing;\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdrawBody: function(pt, vm, ctx, opacity) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar body = vm.body;\n\n\t\t\tctx.textAlign = vm._bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\n\t\t\tvar textColor = mergeOpacity(vm.bodyFontColor, opacity);\n\t\t\tctx.fillStyle = textColor;\n\t\t\tctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\t\t// Before Body\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\n\t\t\t// Before body lines\n\t\t\thelpers.each(vm.beforeBody, fillLineOfText);\n\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\txLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n\n\t\t\t// Draw body lines now\n\t\t\thelpers.each(body, function(bodyItem, i) {\n\t\t\t\thelpers.each(bodyItem.before, fillLineOfText);\n\n\t\t\t\thelpers.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n\t\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n\t\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\n\t\t\t// After body lines\n\t\t\thelpers.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\tdrawFooter: function(pt, vm, ctx, opacity) {\n\t\t\tvar footer = vm.footer;\n\n\t\t\tif (footer.length) {\n\t\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\tctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n\t\t\t\tctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\t\thelpers.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n\t\t\tctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n\t\t\tctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);\n\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar x = pt.x;\n\t\t\tvar y = pt.y;\n\t\t\tvar width = tooltipSize.width;\n\t\t\tvar height = tooltipSize.height;\n\t\t\tvar radius = vm.cornerRadius;\n\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tif (yAlign === 'top') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tif (yAlign === 'bottom') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\n\t\t\tctx.fill();\n\n\t\t\tif (vm.borderWidth > 0) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t\t// Truthy/falsey value for empty tooltip\n\t\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n\t\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.x += vm.xPadding;\n\t\t\t\tpt.y += vm.yPadding;\n\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx, opacity);\n\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx, opacity);\n\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx, opacity);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {Boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\n\t\t\tme._lastActive = me._lastActive || [];\n\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers.arrayEquals(me._active, me._lastActive);\n\n\t\t\t// If tooltip didn't change, do not handle the target event\n\t\t\tif (!changed) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tme._lastActive = me._active;\n\n\t\t\tif (options.enabled || options.custom) {\n\t\t\t\tme._eventPosition = {\n\t\t\t\t\tx: e.x,\n\t\t\t\t\ty: e.y\n\t\t\t\t};\n\n\t\t\t\tvar model = me._model;\n\t\t\t\tme.update(true);\n\t\t\t\tme.pivot();\n\n\t\t\t\t// See if our tooltip position changed\n\t\t\t\tchanged |= (model.x !== me._model.x) || (model.y !== me._model.y);\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tChart.Tooltip.positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {Point} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: Math.round(x / count),\n\t\t\t\ty: Math.round(y / count)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {Point} the position of the event in canvas coordinates\n\t\t * @returns {Point} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\n\t\t\tvar nearestElement;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len;\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/core/core.tooltip.js\n// module id = 934\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tglobalOpts = Chart.defaults.global;\n\n\tglobalOpts.elements.arc = {\n\t\tbackgroundColor: globalOpts.defaultColor,\n\t\tborderColor: '#fff',\n\t\tborderWidth: 2\n\t};\n\n\tChart.elements.Arc = Chart.Element.extend({\n\t\tinLabelRange: function(mouseX) {\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm) {\n\t\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tinRange: function(chartX, chartY) {\n\t\t\tvar vm = this._view;\n\n\t\t\tif (vm) {\n\t\t\t\tvar pointRelativePosition = helpers.getAngleFromPoint(vm, {\n\t\t\t\t\t\tx: chartX,\n\t\t\t\t\t\ty: chartY\n\t\t\t\t\t}),\n\t\t\t\t\tangle = pointRelativePosition.angle,\n\t\t\t\t\tdistance = pointRelativePosition.distance;\n\n\t\t\t\t// Sanitise angle range\n\t\t\t\tvar startAngle = vm.startAngle;\n\t\t\t\tvar endAngle = vm.endAngle;\n\t\t\t\twhile (endAngle < startAngle) {\n\t\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle > endAngle) {\n\t\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle < startAngle) {\n\t\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\t// Check if within the range of the open/close angle\n\t\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle),\n\t\t\t\t\twithinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\t\treturn (betweenAngles && withinRadius);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\t\treturn {\n\t\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t\t};\n\t\t},\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\n\t\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\n\t\t\t\trangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\t\t\treturn {\n\t\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t\t};\n\t\t},\n\t\tdraw: function() {\n\n\t\t\tvar ctx = this._chart.ctx,\n\t\t\t\tvm = this._view,\n\t\t\t\tsA = vm.startAngle,\n\t\t\t\teA = vm.endAngle;\n\n\t\t\tctx.beginPath();\n\n\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\n\t\t\tctx.closePath();\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = vm.borderWidth;\n\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\n\t\t\tctx.fill();\n\t\t\tctx.lineJoin = 'bevel';\n\n\t\t\tif (vm.borderWidth) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/elements/element.arc.js\n// module id = 935\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tChart.defaults.global.elements.line = {\n\t\ttension: 0.4,\n\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\tborderWidth: 3,\n\t\tborderColor: globalDefaults.defaultColor,\n\t\tborderCapStyle: 'butt',\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0,\n\t\tborderJoinStyle: 'miter',\n\t\tcapBezierPoints: true,\n\t\tfill: true, // do we fill in the area between the line and its base axis\n\t};\n\n\tChart.elements.Line = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar vm = me._view;\n\t\t\tvar ctx = me._chart.ctx;\n\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\tvar points = me._children.slice(); // clone array\n\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\tvar lastDrawnIndex = -1;\n\t\t\tvar index, current, previous, currentVM;\n\n\t\t\t// If we are looping, adding the first point again\n\t\t\tif (me._loop && points.length) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\tctx.save();\n\n\t\t\t// Stroke Line Options\n\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t\t// IE 9 and 10 do not support line dash\n\t\t\tif (ctx.setLineDash) {\n\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t}\n\n\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t\t// Stroke Line\n\t\t\tctx.beginPath();\n\t\t\tlastDrawnIndex = -1;\n\n\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\tcurrent = points[index];\n\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\thelpers.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/elements/element.line.js\n// module id = 936\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tglobalOpts = Chart.defaults.global,\n\t\tdefaultColor = globalOpts.defaultColor;\n\n\tglobalOpts.elements.point = {\n\t\tradius: 3,\n\t\tpointStyle: 'circle',\n\t\tbackgroundColor: defaultColor,\n\t\tborderWidth: 1,\n\t\tborderColor: defaultColor,\n\t\t// Hover\n\t\thitRadius: 1,\n\t\thoverRadius: 4,\n\t\thoverBorderWidth: 1\n\t};\n\n\tfunction xRange(mouseX) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n\t}\n\n\tfunction yRange(mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n\t}\n\n\tChart.elements.Point = Chart.Element.extend({\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t\t},\n\n\t\tinLabelRange: xRange,\n\t\tinXRange: xRange,\n\t\tinYRange: yRange,\n\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t},\n\t\tgetArea: function() {\n\t\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y,\n\t\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t\t};\n\t\t},\n\t\tdraw: function(chartArea) {\n\t\t\tvar vm = this._view;\n\t\t\tvar model = this._model;\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar pointStyle = vm.pointStyle;\n\t\t\tvar radius = vm.radius;\n\t\t\tvar x = vm.x;\n\t\t\tvar y = vm.y;\n\t\t\tvar color = Chart.helpers.color;\n\t\t\tvar errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n\t\t\tvar ratio = 0;\n\n\t\t\tif (vm.skip) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\t\tctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\n\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\n\t\t\t// Cliping for Points.\n\t\t\t// going out from inner charArea?\n\t\t\tif ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {\n\t\t\t\t// Point fade out\n\t\t\t\tif (model.x < chartArea.left) {\n\t\t\t\t\tratio = (x - model.x) / (chartArea.left - model.x);\n\t\t\t\t} else if (chartArea.right*errMargin < model.x) {\n\t\t\t\t\tratio = (model.x - x) / (model.x - chartArea.right);\n\t\t\t\t} else if (model.y < chartArea.top) {\n\t\t\t\t\tratio = (y - model.y) / (chartArea.top - model.y);\n\t\t\t\t} else if (chartArea.bottom*errMargin < model.y) {\n\t\t\t\t\tratio = (model.y - y) / (model.y - chartArea.bottom);\n\t\t\t\t}\n\t\t\t\tratio = Math.round(ratio*100) / 100;\n\t\t\t\tctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n\t\t\t\tctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n\t\t\t}\n\n\t\t\tChart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/elements/element.point.js\n// module id = 937\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar globalOpts = Chart.defaults.global;\n\n\tglobalOpts.elements.rectangle = {\n\t\tbackgroundColor: globalOpts.defaultColor,\n\t\tborderWidth: 0,\n\t\tborderColor: globalOpts.defaultColor,\n\t\tborderSkipped: 'bottom'\n\t};\n\n\tfunction isVertical(bar) {\n\t\treturn bar._view.width !== undefined;\n\t}\n\n\t/**\n\t * Helper function to get the bounds of the bar regardless of the orientation\n\t * @private\n\t * @param bar {Chart.Element.Rectangle} the bar\n\t * @return {Bounds} bounds of the bar\n\t */\n\tfunction getBarBounds(bar) {\n\t\tvar vm = bar._view;\n\t\tvar x1, x2, y1, y2;\n\n\t\tif (isVertical(bar)) {\n\t\t\t// vertical\n\t\t\tvar halfWidth = vm.width / 2;\n\t\t\tx1 = vm.x - halfWidth;\n\t\t\tx2 = vm.x + halfWidth;\n\t\t\ty1 = Math.min(vm.y, vm.base);\n\t\t\ty2 = Math.max(vm.y, vm.base);\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tvar halfHeight = vm.height / 2;\n\t\t\tx1 = Math.min(vm.x, vm.base);\n\t\t\tx2 = Math.max(vm.x, vm.base);\n\t\t\ty1 = vm.y - halfHeight;\n\t\t\ty2 = vm.y + halfHeight;\n\t\t}\n\n\t\treturn {\n\t\t\tleft: x1,\n\t\t\ttop: y1,\n\t\t\tright: x2,\n\t\t\tbottom: y2\n\t\t};\n\t}\n\n\tChart.elements.Rectangle = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\t\tvar borderWidth = vm.borderWidth;\n\n\t\t\tif (!vm.horizontal) {\n\t\t\t\t// bar\n\t\t\t\tleft = vm.x - vm.width / 2;\n\t\t\t\tright = vm.x + vm.width / 2;\n\t\t\t\ttop = vm.y;\n\t\t\t\tbottom = vm.base;\n\t\t\t\tsignX = 1;\n\t\t\t\tsignY = bottom > top? 1: -1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t\t} else {\n\t\t\t\t// horizontal bar\n\t\t\t\tleft = vm.base;\n\t\t\t\tright = vm.x;\n\t\t\t\ttop = vm.y - vm.height / 2;\n\t\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\t\tsignX = right > left? 1: -1;\n\t\t\t\tsignY = 1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t\t}\n\n\t\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\t\tif (borderWidth) {\n\t\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\t\tborderWidth = borderWidth > barSize? barSize: borderWidth;\n\t\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\t\tvar borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);\n\t\t\t\tvar borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);\n\t\t\t\tvar borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);\n\t\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);\n\t\t\t\t// not become a vertical line?\n\t\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\t\ttop = borderTop;\n\t\t\t\t\tbottom = borderBottom;\n\t\t\t\t}\n\t\t\t\t// not become a horizontal line?\n\t\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\t\tleft = borderLeft;\n\t\t\t\t\tright = borderRight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = borderWidth;\n\n\t\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t\t// | 1 2 |\n\t\t\t// | 0 3 |\n\t\t\tvar corners = [\n\t\t\t\t[left, bottom],\n\t\t\t\t[left, top],\n\t\t\t\t[right, top],\n\t\t\t\t[right, bottom]\n\t\t\t];\n\n\t\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\t\tif (startCorner === -1) {\n\t\t\t\tstartCorner = 0;\n\t\t\t}\n\n\t\t\tfunction cornerAt(index) {\n\t\t\t\treturn corners[(startCorner + index) % 4];\n\t\t\t}\n\n\t\t\t// Draw rectangle from 'startCorner'\n\t\t\tvar corner = cornerAt(0);\n\t\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\t\tfor (var i = 1; i < 4; i++) {\n\t\t\t\tcorner = cornerAt(i);\n\t\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t\t}\n\n\t\t\tctx.fill();\n\t\t\tif (borderWidth) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\theight: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.base - vm.y;\n\t\t},\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar inRange = false;\n\n\t\t\tif (this._view) {\n\t\t\t\tvar bounds = getBarBounds(this);\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinLabelRange: function(mouseX, mouseY) {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar inRange = false;\n\t\t\tvar bounds = getBarBounds(me);\n\n\t\t\tif (isVertical(me)) {\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t\t} else {\n\t\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinXRange: function(mouseX) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t},\n\t\tinYRange: function(mouseY) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t},\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar x, y;\n\t\t\tif (isVertical(this)) {\n\t\t\t\tx = vm.x;\n\t\t\t\ty = (vm.y + vm.base) / 2;\n\t\t\t} else {\n\t\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\t\ty = vm.y;\n\t\t\t}\n\n\t\t\treturn {x: x, y: y};\n\t\t},\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t}\n\t});\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/elements/element.rectangle.js\n// module id = 938\n// module chunks = 4 6 7","'use strict';\n\n// Chart.Platform implementation for targeting a web browser\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\n\t// DOM event types -> Chart.js event types.\n\t// Note: only events with different types are mapped.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events\n\tvar eventTypeMap = {\n\t\t// Touch events\n\t\ttouchstart: 'mousedown',\n\t\ttouchmove: 'mousemove',\n\t\ttouchend: 'mouseup',\n\n\t\t// Pointer events\n\t\tpointerenter: 'mouseenter',\n\t\tpointerdown: 'mousedown',\n\t\tpointermove: 'mousemove',\n\t\tpointerup: 'mouseup',\n\t\tpointerleave: 'mouseout',\n\t\tpointerout: 'mouseout'\n\t};\n\n\t/**\n\t * The \"used\" size is the final value of a dimension property after all calculations have\n\t * been performed. This method uses the computed style of `element` but returns undefined\n\t * if the computed style is not expressed in pixels. That can happen in some cases where\n\t * `element` has a size relative to its parent and this last one is not yet displayed,\n\t * for example because of `display: none` on a parent node.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n\t * @returns {Number} Size in pixels or undefined if unknown.\n\t */\n\tfunction readUsedSize(element, property) {\n\t\tvar value = helpers.getStyle(element, property);\n\t\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\t\treturn matches? Number(matches[1]) : undefined;\n\t}\n\n\t/**\n\t * Initializes the canvas style and render size without modifying the canvas display size,\n\t * since responsiveness is handled by the controller.resize() method. The config is used\n\t * to determine the aspect ratio to apply in case no explicit height has been specified.\n\t */\n\tfunction initCanvas(canvas, config) {\n\t\tvar style = canvas.style;\n\n\t\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\t\tvar renderHeight = canvas.getAttribute('height');\n\t\tvar renderWidth = canvas.getAttribute('width');\n\n\t\t// Chart.js modifies some canvas values that we want to restore on destroy\n\t\tcanvas._chartjs = {\n\t\t\tinitial: {\n\t\t\t\theight: renderHeight,\n\t\t\t\twidth: renderWidth,\n\t\t\t\tstyle: {\n\t\t\t\t\tdisplay: style.display,\n\t\t\t\t\theight: style.height,\n\t\t\t\t\twidth: style.width\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Force canvas to display as block to avoid extra space caused by inline\n\t\t// elements, which would interfere with the responsive resize process.\n\t\t// https://github.com/chartjs/Chart.js/issues/2538\n\t\tstyle.display = style.display || 'block';\n\n\t\tif (renderWidth === null || renderWidth === '') {\n\t\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.width = displayWidth;\n\t\t\t}\n\t\t}\n\n\t\tif (renderHeight === null || renderHeight === '') {\n\t\t\tif (canvas.style.height === '') {\n\t\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t\t} else {\n\t\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\t\tif (displayWidth !== undefined) {\n\t\t\t\t\tcanvas.height = displayHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn canvas;\n\t}\n\n\tfunction createEvent(type, chart, x, y, nativeEvent) {\n\t\treturn {\n\t\t\ttype: type,\n\t\t\tchart: chart,\n\t\t\tnative: nativeEvent || null,\n\t\t\tx: x !== undefined? x : null,\n\t\t\ty: y !== undefined? y : null,\n\t\t};\n\t}\n\n\tfunction fromNativeEvent(event, chart) {\n\t\tvar type = eventTypeMap[event.type] || event.type;\n\t\tvar pos = helpers.getRelativePosition(event, chart);\n\t\treturn createEvent(type, chart, pos.x, pos.y, event);\n\t}\n\n\tfunction createResizer(handler) {\n\t\tvar iframe = document.createElement('iframe');\n\t\tiframe.className = 'chartjs-hidden-iframe';\n\t\tiframe.style.cssText =\n\t\t\t'display:block;'+\n\t\t\t'overflow:hidden;'+\n\t\t\t'border:0;'+\n\t\t\t'margin:0;'+\n\t\t\t'top:0;'+\n\t\t\t'left:0;'+\n\t\t\t'bottom:0;'+\n\t\t\t'right:0;'+\n\t\t\t'height:100%;'+\n\t\t\t'width:100%;'+\n\t\t\t'position:absolute;'+\n\t\t\t'pointer-events:none;'+\n\t\t\t'z-index:-1;';\n\n\t\t// Prevent the iframe to gain focus on tab.\n\t\t// https://github.com/chartjs/Chart.js/issues/3090\n\t\tiframe.tabIndex = -1;\n\n\t\t// If the iframe is re-attached to the DOM, the resize listener is removed because the\n\t\t// content is reloaded, so make sure to install the handler after the iframe is loaded.\n\t\t// https://github.com/chartjs/Chart.js/issues/3521\n\t\thelpers.addEvent(iframe, 'load', function() {\n\t\t\thelpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);\n\n\t\t\t// The iframe size might have changed while loading, which can also\n\t\t\t// happen if the size has been changed while detached from the DOM.\n\t\t\thandler();\n\t\t});\n\n\t\treturn iframe;\n\t}\n\n\tfunction addResizeListener(node, listener, chart) {\n\t\tvar stub = node._chartjs = {\n\t\t\tticking: false\n\t\t};\n\n\t\t// Throttle the callback notification until the next animation frame.\n\t\tvar notify = function() {\n\t\t\tif (!stub.ticking) {\n\t\t\t\tstub.ticking = true;\n\t\t\t\thelpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tif (stub.resizer) {\n\t\t\t\t\t\tstub.ticking = false;\n\t\t\t\t\t\treturn listener(createEvent('resize', chart));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// Let's keep track of this added iframe and thus avoid DOM query when removing it.\n\t\tstub.resizer = createResizer(notify);\n\n\t\tnode.insertBefore(stub.resizer, node.firstChild);\n\t}\n\n\tfunction removeResizeListener(node) {\n\t\tif (!node || !node._chartjs) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar resizer = node._chartjs.resizer;\n\t\tif (resizer) {\n\t\t\tresizer.parentNode.removeChild(resizer);\n\t\t\tnode._chartjs.resizer = null;\n\t\t}\n\n\t\tdelete node._chartjs;\n\t}\n\n\treturn {\n\t\tacquireContext: function(item, config) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.getElementById(item);\n\t\t\t} else if (item.length) {\n\t\t\t\t// Support for array based queries (such as jQuery)\n\t\t\t\titem = item[0];\n\t\t\t}\n\n\t\t\tif (item && item.canvas) {\n\t\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\t\titem = item.canvas;\n\t\t\t}\n\n\t\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\tvar context = item && item.getContext && item.getContext('2d');\n\n\t\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\t\tif (context && context.canvas === item) {\n\t\t\t\tinitCanvas(item, config);\n\t\t\t\treturn context;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\treleaseContext: function(context) {\n\t\t\tvar canvas = context.canvas;\n\t\t\tif (!canvas._chartjs) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar initial = canvas._chartjs.initial;\n\t\t\t['height', 'width'].forEach(function(prop) {\n\t\t\t\tvar value = initial[prop];\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t\t} else {\n\t\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(initial.style || {}, function(value, key) {\n\t\t\t\tcanvas.style[key] = value;\n\t\t\t});\n\n\t\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\t\tcanvas.width = canvas.width;\n\n\t\t\tdelete canvas._chartjs;\n\t\t},\n\n\t\taddEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\taddResizeListener(canvas.parentNode, listener, chart);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stub = listener._chartjs || (listener._chartjs = {});\n\t\t\tvar proxies = stub.proxies || (stub.proxies = {});\n\t\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t\t};\n\n\t\t\thelpers.addEvent(canvas, type, proxy);\n\t\t},\n\n\t\tremoveEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\tremoveResizeListener(canvas.parentNode, listener);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stub = listener._chartjs || {};\n\t\t\tvar proxies = stub.proxies || {};\n\t\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\t\tif (!proxy) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thelpers.removeEvent(canvas, type, proxy);\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/platforms/platform.dom.js\n// module id = 939\n// module chunks = 4 6 7","'use strict';\n\n// By default, select the browser (DOM) platform.\n// @TODO Make possible to select another platform at build time.\nvar implementation = require('./platform.dom.js');\n\nmodule.exports = function(Chart) {\n\t/**\n\t * @namespace Chart.platform\n\t * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n\t * @since 2.4.0\n\t */\n\tChart.platform = {\n\t\t/**\n\t\t * Called at chart construction time, returns a context2d instance implementing\n\t\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t\t * @param {Object} options - The chart options\n\t\t * @returns {CanvasRenderingContext2D} context2d instance\n\t\t */\n\t\tacquireContext: function() {},\n\n\t\t/**\n\t\t * Called at chart destruction time, releases any resources associated to the context\n\t\t * previously returned by the acquireContext() method.\n\t\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t\t * @returns {Boolean} true if the method succeeded, else false\n\t\t */\n\t\treleaseContext: function() {},\n\n\t\t/**\n\t\t * Registers the specified listener on the given chart.\n\t\t * @param {Chart} chart - Chart from which to listen for event\n\t\t * @param {String} type - The ({@link IEvent}) type to listen for\n\t\t * @param {Function} listener - Receives a notification (an object that implements\n\t\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t\t */\n\t\taddEventListener: function() {},\n\n\t\t/**\n\t\t * Removes the specified listener previously registered with addEventListener.\n\t\t * @param {Chart} chart -Chart from which to remove the listener\n\t\t * @param {String} type - The ({@link IEvent}) type to remove\n\t\t * @param {Function} listener - The listener function to remove from the event target.\n\t\t */\n\t\tremoveEventListener: function() {}\n\t};\n\n\t/**\n\t * @interface IPlatform\n\t * Allows abstracting platform dependencies away from the chart\n\t * @borrows Chart.platform.acquireContext as acquireContext\n\t * @borrows Chart.platform.releaseContext as releaseContext\n\t * @borrows Chart.platform.addEventListener as addEventListener\n\t * @borrows Chart.platform.removeEventListener as removeEventListener\n\t */\n\n\t/**\n\t * @interface IEvent\n\t * @prop {String} type - The event type name, possible values are:\n\t * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n\t * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n\t * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n\t * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n\t * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n\t */\n\n\tChart.helpers.extend(Chart.platform, implementation(Chart));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/platforms/platform.js\n// module id = 940\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\t/**\n\t * Plugin based on discussion from the following Chart.js issues:\n\t * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n\t * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n\t */\n\tChart.defaults.global.plugins.filler = {\n\t\tpropagate: true\n\t};\n\n\tvar defaults = Chart.defaults;\n\tvar helpers = Chart.helpers;\n\tvar mappers = {\n\t\tdataset: function(source) {\n\t\t\tvar index = source.fill;\n\t\t\tvar chart = source.chart;\n\t\t\tvar meta = chart.getDatasetMeta(index);\n\t\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\t\tvar points = (visible && meta.dataset._children) || [];\n\n\t\t\treturn !points.length? null : function(point, i) {\n\t\t\t\treturn points[i]._view || null;\n\t\t\t};\n\t\t},\n\n\t\tboundary: function(source) {\n\t\t\tvar boundary = source.boundary;\n\t\t\tvar x = boundary? boundary.x : null;\n\t\t\tvar y = boundary? boundary.y : null;\n\n\t\t\treturn function(point) {\n\t\t\t\treturn {\n\t\t\t\t\tx: x === null? point.x : x,\n\t\t\t\t\ty: y === null? point.y : y,\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\t};\n\n\t// @todo if (fill[0] === '#')\n\tfunction decodeFill(el, index, count) {\n\t\tvar model = el._model || {};\n\t\tvar fill = model.fill;\n\t\tvar target;\n\n\t\tif (fill === undefined) {\n\t\t\tfill = !!model.backgroundColor;\n\t\t}\n\n\t\tif (fill === false || fill === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fill === true) {\n\t\t\treturn 'origin';\n\t\t}\n\n\t\ttarget = parseFloat(fill, 10);\n\t\tif (isFinite(target) && Math.floor(target) === target) {\n\t\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\t\ttarget = index + target;\n\t\t\t}\n\n\t\t\tif (target === index || target < 0 || target >= count) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\tswitch (fill) {\n\t\t// compatibility\n\t\tcase 'bottom':\n\t\t\treturn 'start';\n\t\tcase 'top':\n\t\t\treturn 'end';\n\t\tcase 'zero':\n\t\t\treturn 'origin';\n\t\t// supported boundaries\n\t\tcase 'origin':\n\t\tcase 'start':\n\t\tcase 'end':\n\t\t\treturn fill;\n\t\t// invalid fill values\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction computeBoundary(source) {\n\t\tvar model = source.el._model || {};\n\t\tvar scale = source.el._scale || {};\n\t\tvar fill = source.fill;\n\t\tvar target = null;\n\t\tvar horizontal;\n\n\t\tif (isFinite(fill)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t\t// controllers might still use it (e.g. the Smith chart).\n\n\t\tif (fill === 'start') {\n\t\t\ttarget = model.scaleBottom === undefined? scale.bottom : model.scaleBottom;\n\t\t} else if (fill === 'end') {\n\t\t\ttarget = model.scaleTop === undefined? scale.top : model.scaleTop;\n\t\t} else if (model.scaleZero !== undefined) {\n\t\t\ttarget = model.scaleZero;\n\t\t} else if (scale.getBasePosition) {\n\t\t\ttarget = scale.getBasePosition();\n\t\t} else if (scale.getBasePixel) {\n\t\t\ttarget = scale.getBasePixel();\n\t\t}\n\n\t\tif (target !== undefined && target !== null) {\n\t\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\t\thorizontal = scale.isHorizontal();\n\t\t\t\treturn {\n\t\t\t\t\tx: horizontal? target : null,\n\t\t\t\t\ty: horizontal? null : target\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction resolveTarget(sources, index, propagate) {\n\t\tvar source = sources[index];\n\t\tvar fill = source.fill;\n\t\tvar visited = [index];\n\t\tvar target;\n\n\t\tif (!propagate) {\n\t\t\treturn fill;\n\t\t}\n\n\t\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\t\tif (!isFinite(fill)) {\n\t\t\t\treturn fill;\n\t\t\t}\n\n\t\t\ttarget = sources[fill];\n\t\t\tif (!target) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (target.visible) {\n\t\t\t\treturn fill;\n\t\t\t}\n\n\t\t\tvisited.push(fill);\n\t\t\tfill = target.fill;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction createMapper(source) {\n\t\tvar fill = source.fill;\n\t\tvar type = 'dataset';\n\n\t\tif (fill === false) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!isFinite(fill)) {\n\t\t\ttype = 'boundary';\n\t\t}\n\n\t\treturn mappers[type](source);\n\t}\n\n\tfunction isDrawable(point) {\n\t\treturn point && !point.skip;\n\t}\n\n\tfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\t\tvar i;\n\n\t\tif (!len0 || !len1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// building first area curve (normal)\n\t\tctx.moveTo(curve0[0].x, curve0[0].y);\n\t\tfor (i=1; i<len0; ++i) {\n\t\t\thelpers.canvas.lineTo(ctx, curve0[i-1], curve0[i]);\n\t\t}\n\n\t\t// joining the two area curves\n\t\tctx.lineTo(curve1[len1-1].x, curve1[len1-1].y);\n\n\t\t// building opposite area curve (reverse)\n\t\tfor (i=len1-1; i>0; --i) {\n\t\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i-1], true);\n\t\t}\n\t}\n\n\tfunction doFill(ctx, points, mapper, view, color, loop) {\n\t\tvar count = points.length;\n\t\tvar span = view.spanGaps;\n\t\tvar curve0 = [];\n\t\tvar curve1 = [];\n\t\tvar len0 = 0;\n\t\tvar len1 = 0;\n\t\tvar i, ilen, index, p0, p1, d0, d1;\n\n\t\tctx.beginPath();\n\n\t\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\t\tindex = i%count;\n\t\t\tp0 = points[index]._view;\n\t\t\tp1 = mapper(p0, index, view);\n\t\t\td0 = isDrawable(p0);\n\t\t\td1 = isDrawable(p1);\n\n\t\t\tif (d0 && d1) {\n\t\t\t\tlen0 = curve0.push(p0);\n\t\t\t\tlen1 = curve1.push(p1);\n\t\t\t} else if (len0 && len1) {\n\t\t\t\tif (!span) {\n\t\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\t\tlen0 = len1 = 0;\n\t\t\t\t\tcurve0 = [];\n\t\t\t\t\tcurve1 = [];\n\t\t\t\t} else {\n\t\t\t\t\tif (d0) {\n\t\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t\t}\n\t\t\t\t\tif (d1) {\n\t\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\t\tctx.closePath();\n\t\tctx.fillStyle = color;\n\t\tctx.fill();\n\t}\n\n\treturn {\n\t\tid: 'filler',\n\n\t\tafterDatasetsUpdate: function(chart, options) {\n\t\t\tvar count = (chart.data.datasets || []).length;\n\t\t\tvar propagate = options.propagate;\n\t\t\tvar sources = [];\n\t\t\tvar meta, i, el, source;\n\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tel = meta.dataset;\n\t\t\t\tsource = null;\n\n\t\t\t\tif (el && el._model && el instanceof Chart.elements.Line) {\n\t\t\t\t\tsource = {\n\t\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\t\tchart: chart,\n\t\t\t\t\t\tel: el\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tmeta.$filler = source;\n\t\t\t\tsources.push(source);\n\t\t\t}\n\n\t\t\tfor (i=0; i<count; ++i) {\n\t\t\t\tsource = sources[i];\n\t\t\t\tif (!source) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\t\tsource.boundary = computeBoundary(source);\n\t\t\t\tsource.mapper = createMapper(source);\n\t\t\t}\n\t\t},\n\n\t\tbeforeDatasetDraw: function(chart, args) {\n\t\t\tvar meta = args.meta.$filler;\n\t\t\tif (!meta) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar el = meta.el;\n\t\t\tvar view = el._view;\n\t\t\tvar points = el._children || [];\n\t\t\tvar mapper = meta.mapper;\n\t\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\t\tif (mapper && color && points.length) {\n\t\t\t\tdoFill(chart.ctx, points, mapper, view, color, el._loop);\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/plugins/plugin.filler.js\n// module id = 941\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar layout = Chart.layoutService;\n\tvar noop = helpers.noop;\n\n\tChart.defaults.global.legend = {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Helper function to get the box width based on the usePointStyle option\n\t * @param labelopts {Object} the label options on the legend\n\t * @param fontSize {Number} the label font size\n\t * @return {Number} width of the color box area\n\t */\n\tfunction getBoxWidth(labelOpts, fontSize) {\n\t\treturn labelOpts.usePointStyle ?\n\t\t\tfontSize * Math.SQRT2 :\n\t\t\tlabelOpts.boxWidth;\n\t}\n\n\tChart.Legend = Chart.Element.extend({\n\n\t\tinitialize: function(config) {\n\t\t\thelpers.extend(this, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tthis.legendHitBoxes = [];\n\n\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\tthis.doughnutMode = false;\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\t// Any function defined here is inherited by all legend types.\n\t\t// Any function can be extended by the legend type\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: function() {\n\t\t\tvar me = this;\n\t\t\tvar labelOpts = me.options.labels;\n\t\t\tvar legendItems = labelOpts.generateLabels.call(me, me.chart);\n\n\t\t\tif (labelOpts.filter) {\n\t\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (me.options.reverse) {\n\t\t\t\tlegendItems.reverse();\n\t\t\t}\n\n\t\t\tme.legendItems = legendItems;\n\t\t},\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar display = opts.display;\n\n\t\t\tvar ctx = me.ctx;\n\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t// Reset hit boxes\n\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\t\tvar minSize = me.minSize;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Increase sizes here\n\t\t\tif (display) {\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// Labels\n\n\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t});\n\n\t\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t\t} else {\n\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\n\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\n\t\t// Actually draw the legend on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\tlineDefault = globalDefault.elements.line,\n\t\t\t\tlegendWidth = me.width,\n\t\t\t\tlineWidths = me.lineWidths;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx,\n\t\t\t\t\tcursor,\n\t\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n\t\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t\t// Canvas setup\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize),\n\t\t\t\t\thitboxes = me.legendHitBoxes;\n\n\t\t\t\t// current position\n\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\tctx.save();\n\n\t\t\t\t\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\t\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\t\tvar isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.restore();\n\t\t\t\t};\n\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\t\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\n\n\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\n\t\t\t\t\t\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Horizontal\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width,\n\t\t\t\t\t\twidth = boxWidth + (fontSize / 2) + textWidth,\n\t\t\t\t\t\tx = cursor.x,\n\t\t\t\t\t\ty = cursor.y;\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t\t// Fill the actual label\n\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @return {Boolean} true if a change occured\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\t\tvar changed = false;\n\n\t\t\tif (type === 'mousemove') {\n\t\t\t\tif (!opts.onHover) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (type === 'click') {\n\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Chart event already has relative position in it\n\t\t\tvar x = e.x,\n\t\t\t\ty = e.y;\n\n\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\tvar lh = me.legendHitBoxes;\n\t\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\tfunction createNewLegendAndAttach(chart, legendOpts) {\n\t\tvar legend = new Chart.Legend({\n\t\t\tctx: chart.ctx,\n\t\t\toptions: legendOpts,\n\t\t\tchart: chart\n\t\t});\n\n\t\tlayout.configure(chart, legend, legendOpts);\n\t\tlayout.addBox(chart, legend);\n\t\tchart.legend = legend;\n\t}\n\n\treturn {\n\t\tid: 'legend',\n\n\t\tbeforeInit: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t},\n\n\t\tbeforeUpdate: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\t\t\tvar legend = chart.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tlegendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n\n\t\t\t\tif (legend) {\n\t\t\t\t\tlayout.configure(chart, legend, legendOpts);\n\t\t\t\t\tlegend.options = legendOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t\t}\n\t\t\t} else if (legend) {\n\t\t\t\tlayout.removeBox(chart, legend);\n\t\t\t\tdelete chart.legend;\n\t\t\t}\n\t\t},\n\n\t\tafterEvent: function(chart, e) {\n\t\t\tvar legend = chart.legend;\n\t\t\tif (legend) {\n\t\t\t\tlegend.handleEvent(e);\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/plugins/plugin.legend.js\n// module id = 942\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar layout = Chart.layoutService;\n\tvar noop = helpers.noop;\n\n\tChart.defaults.global.title = {\n\t\tdisplay: false,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\tweight: 2000,        // by default greater than legend (1000) to be above\n\t\tfontStyle: 'bold',\n\t\tpadding: 10,\n\n\t\t// actual title\n\t\ttext: ''\n\t};\n\n\tChart.Title = Chart.Element.extend({\n\t\tinitialize: function(config) {\n\t\t\tvar me = this;\n\t\t\thelpers.extend(me, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tme.legendHitBoxes = [];\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: noop,\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this,\n\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\topts = me.options,\n\t\t\t\tglobalDefaults = Chart.defaults.global,\n\t\t\t\tdisplay = opts.display,\n\t\t\t\tfontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\tminSize = me.minSize;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? fontSize + (opts.padding * 2) : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\tvar pos = this.options.position;\n\t\t\treturn pos === 'top' || pos === 'bottom';\n\t\t},\n\n\t\t// Actually draw the title block on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this,\n\t\t\t\tctx = me.ctx,\n\t\t\t\tvalueOrDefault = helpers.getValueOrDefault,\n\t\t\t\topts = me.options,\n\t\t\t\tglobalDefaults = Chart.defaults.global;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n\t\t\t\t\tfontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\t\tfontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\t\ttitleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\n\t\t\t\t\trotation = 0,\n\t\t\t\t\ttitleX,\n\t\t\t\t\ttitleY,\n\t\t\t\t\ttop = me.top,\n\t\t\t\t\tleft = me.left,\n\t\t\t\t\tbottom = me.bottom,\n\t\t\t\t\tright = me.right,\n\t\t\t\t\tmaxWidth;\n\n\t\t\t\tctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n\t\t\t\tctx.font = titleFont;\n\n\t\t\t\t// Horizontal\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\t\ttitleY = top + ((bottom - top) / 2); // midpoint of the height\n\t\t\t\t\tmaxWidth = right - left;\n\t\t\t\t} else {\n\t\t\t\t\ttitleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\n\t\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t\t}\n\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(titleX, titleY);\n\t\t\t\tctx.rotate(rotation);\n\t\t\t\tctx.textAlign = 'center';\n\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\tctx.fillText(opts.text, 0, 0, maxWidth);\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\t\tvar title = new Chart.Title({\n\t\t\tctx: chart.ctx,\n\t\t\toptions: titleOpts,\n\t\t\tchart: chart\n\t\t});\n\n\t\tlayout.configure(chart, title, titleOpts);\n\t\tlayout.addBox(chart, title);\n\t\tchart.titleBlock = title;\n\t}\n\n\treturn {\n\t\tid: 'title',\n\n\t\tbeforeInit: function(chart) {\n\t\t\tvar titleOpts = chart.options.title;\n\n\t\t\tif (titleOpts) {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t},\n\n\t\tbeforeUpdate: function(chart) {\n\t\t\tvar titleOpts = chart.options.title;\n\t\t\tvar titleBlock = chart.titleBlock;\n\n\t\t\tif (titleOpts) {\n\t\t\t\ttitleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);\n\n\t\t\t\tif (titleBlock) {\n\t\t\t\t\tlayout.configure(chart, titleBlock, titleOpts);\n\t\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t\t}\n\t\t\t} else if (titleBlock) {\n\t\t\t\tChart.layoutService.removeBox(chart, titleBlock);\n\t\t\t\tdelete chart.titleBlock;\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/plugins/plugin.title.js\n// module id = 943\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\n\t\t\tvar me = this;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (me.options.gridLines.offsetGridLines) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/scales/scale.category.js\n// module id = 944\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = isFinite(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t\treturn Math.round(pixel);\n\t\t\t}\n\n\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\treturn Math.round(pixel);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/scales/scale.linear.js\n// module id = 945\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tnoop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/scales/scale.linearbase.js\n// module id = 946\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tvalues[index] = 100;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\n\t\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = getValueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = getValueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = 1;\n\t\t\t\t\tme.max = 10;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n\n\t\t\tif (!me.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tticks.reverse();\n\t\t\t}\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension;\n\t\t\tvar pixel;\n\n\t\t\tvar start = me.start;\n\t\t\tvar newVal = +me.getRightValue(value);\n\t\t\tvar range;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\t\t\t\tif (newVal === 0) {\n\t\t\t\t\tpixel = me.left;\n\t\t\t\t} else {\n\t\t\t\t\tinnerDimension = me.width;\n\t\t\t\t\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Bottom - top since pixels increase downward on a screen\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tif (start === 0 && !tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === start) {\n\t\t\t\t\t\tpixel = me.bottom;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (me.end === 0 && tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === me.end) {\n\t\t\t\t\t\tpixel = me.top;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (newVal === 0) {\n\t\t\t\t\tpixel = tickOpts.reverse ? me.top : me.bottom;\n\t\t\t\t} else {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start);\n\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\tpixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\n\t\t\tvar value, innerDimension;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n\t\t\t} else {  // todo: if start === 0\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/scales/scale.logarithmic.js\n// module id = 947\n// module chunks = 4 6 7","'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tr: scale.width,\n\t\t\tl: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i;\n\t\tvar textSize;\n\t\tvar pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty+= spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra 3px out for some label spacing\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\tctx.font = plFont.font;\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.gridLines.circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t} else {\n\t\t\t\tfit(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea,\n\t\t\t\tmaxLeft = leftMovement + me.drawingArea,\n\t\t\t\tmaxTop = topMovement + me.drawingArea,\n\t\t\t\tmaxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || opts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\t\t\t\t\t\tvar yHeight = me.yCenter - yCenterOffset;\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, me.xCenter, yHeight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/scales/scale.radialLinear.js\n// module id = 948\n// module chunks = 4 6 7","/* global window: false */\n'use strict';\n\nvar moment = require('moment');\nmoment = typeof(moment) === 'function' ? moment : window.moment;\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar interval = {\n\t\tmillisecond: {\n\t\t\tsize: 1,\n\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t},\n\t\tsecond: {\n\t\t\tsize: 1000,\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t},\n\t\tminute: {\n\t\t\tsize: 60000,\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t},\n\t\thour: {\n\t\t\tsize: 3600000,\n\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t},\n\t\tday: {\n\t\t\tsize: 86400000,\n\t\t\tsteps: [1, 2, 5]\n\t\t},\n\t\tweek: {\n\t\t\tsize: 604800000,\n\t\t\tmaxStep: 4\n\t\t},\n\t\tmonth: {\n\t\t\tsize: 2.628e9,\n\t\t\tmaxStep: 3\n\t\t},\n\t\tquarter: {\n\t\t\tsize: 7.884e9,\n\t\t\tmaxStep: 4\n\t\t},\n\t\tyear: {\n\t\t\tsize: 3.154e10,\n\t\t\tmaxStep: false\n\t\t}\n\t};\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\thour: 'MMM D, hA', // Sept 4, 5PM\n\t\t\t\tday: 'll', // Sep 4 2015\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t},\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false\n\t\t}\n\t};\n\n\t/**\n\t * Helper function to parse time to a moment object\n\t * @param axis {TimeAxis} the time axis\n\t * @param label {Date|string|number|Moment} The thing to parse\n\t * @return {Moment} parsed time\n\t */\n\tfunction parseTime(axis, label) {\n\t\tvar timeOpts = axis.options.time;\n\t\tif (typeof timeOpts.parser === 'string') {\n\t\t\treturn moment(label, timeOpts.parser);\n\t\t}\n\t\tif (typeof timeOpts.parser === 'function') {\n\t\t\treturn timeOpts.parser(label);\n\t\t}\n\t\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\n\t\t\t// Date objects\n\t\t\treturn moment(label);\n\t\t}\n\t\tif (label.isValid && label.isValid()) {\n\t\t\t// Moment support\n\t\t\treturn label;\n\t\t}\n\t\tvar format = timeOpts.format;\n\t\tif (typeof format !== 'string' && format.call) {\n\t\t\t// Custom parsing (return an instance of moment)\n\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\treturn format(label);\n\t\t}\n\t\t// Moment format parsing\n\t\treturn moment(label, format);\n\t}\n\n\t/**\n\t * Figure out which is the best unit for the scale\n\t * @param minUnit {String} minimum unit to use\n\t * @param min {Number} scale minimum\n\t * @param max {Number} scale maximum\n\t * @return {String} the unit to use\n\t */\n\tfunction determineUnit(minUnit, min, max, maxTicks) {\n\t\tvar units = Object.keys(interval);\n\t\tvar unit;\n\t\tvar numUnits = units.length;\n\n\t\tfor (var i = units.indexOf(minUnit); i < numUnits; i++) {\n\t\t\tunit = units[i];\n\t\t\tvar unitDetails = interval[unit];\n\t\t\tvar steps = (unitDetails.steps && unitDetails.steps[unitDetails.steps.length - 1]) || unitDetails.maxStep;\n\t\t\tif (steps === undefined || Math.ceil((max - min) / (steps * unitDetails.size)) <= maxTicks) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn unit;\n\t}\n\n\t/**\n\t * Determines how we scale the unit\n\t * @param min {Number} the scale minimum\n\t * @param max {Number} the scale maximum\n\t * @param unit {String} the unit determined by the {@see determineUnit} method\n\t * @return {Number} the axis step size as a multiple of unit\n\t */\n\tfunction determineStepSize(min, max, unit, maxTicks) {\n\t\t// Using our unit, figoure out what we need to scale as\n\t\tvar unitDefinition = interval[unit];\n\t\tvar unitSizeInMilliSeconds = unitDefinition.size;\n\t\tvar sizeInUnits = Math.ceil((max - min) / unitSizeInMilliSeconds);\n\t\tvar multiplier = 1;\n\t\tvar range = max - min;\n\n\t\tif (unitDefinition.steps) {\n\t\t\t// Have an array of steps\n\t\t\tvar numSteps = unitDefinition.steps.length;\n\t\t\tfor (var i = 0; i < numSteps && sizeInUnits > maxTicks; i++) {\n\t\t\t\tmultiplier = unitDefinition.steps[i];\n\t\t\t\tsizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));\n\t\t\t}\n\t\t} else {\n\t\t\twhile (sizeInUnits > maxTicks && maxTicks > 0) {\n\t\t\t\t++multiplier;\n\t\t\t\tsizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));\n\t\t\t}\n\t\t}\n\n\t\treturn multiplier;\n\t}\n\n\t/**\n\t * Helper for generating axis labels.\n\t * @param options {ITimeGeneratorOptions} the options for generation\n\t * @param dataRange {IRange} the data range\n\t * @param niceRange {IRange} the pretty range to display\n\t * @return {Number[]} ticks\n\t */\n\tfunction generateTicks(options, dataRange, niceRange) {\n\t\tvar ticks = [];\n\t\tif (options.maxTicks) {\n\t\t\tvar stepSize = options.stepSize;\n\t\t\tticks.push(options.min !== undefined ? options.min : niceRange.min);\n\t\t\tvar cur = moment(niceRange.min);\n\t\t\twhile (cur.add(stepSize, options.unit).valueOf() < niceRange.max) {\n\t\t\t\tticks.push(cur.valueOf());\n\t\t\t}\n\t\t\tvar realMax = options.max || niceRange.max;\n\t\t\tif (ticks[ticks.length - 1] !== realMax) {\n\t\t\t\tticks.push(realMax);\n\t\t\t}\n\t\t}\n\t\treturn ticks;\n\t}\n\n\t/**\n\t * @function Chart.Ticks.generators.time\n\t * @param options {ITimeGeneratorOptions} the options for generation\n\t * @param dataRange {IRange} the data range\n\t * @return {Number[]} ticks\n\t */\n\tChart.Ticks.generators.time = function(options, dataRange) {\n\t\tvar niceMin;\n\t\tvar niceMax;\n\t\tvar isoWeekday = options.isoWeekday;\n\t\tif (options.unit === 'week' && isoWeekday !== false) {\n\t\t\tniceMin = moment(dataRange.min).startOf('isoWeek').isoWeekday(isoWeekday).valueOf();\n\t\t\tniceMax = moment(dataRange.max).startOf('isoWeek').isoWeekday(isoWeekday);\n\t\t\tif (dataRange.max - niceMax > 0) {\n\t\t\t\tniceMax.add(1, 'week');\n\t\t\t}\n\t\t\tniceMax = niceMax.valueOf();\n\t\t} else {\n\t\t\tniceMin = moment(dataRange.min).startOf(options.unit).valueOf();\n\t\t\tniceMax = moment(dataRange.max).startOf(options.unit);\n\t\t\tif (dataRange.max - niceMax > 0) {\n\t\t\t\tniceMax.add(1, options.unit);\n\t\t\t}\n\t\t\tniceMax = niceMax.valueOf();\n\t\t}\n\t\treturn generateTicks(options, dataRange, {\n\t\t\tmin: niceMin,\n\t\t\tmax: niceMax\n\t\t});\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar timeOpts = me.options.time;\n\n\t\t\t// We store the data range as unix millisecond timestamps so dataMin and dataMax will always be integers.\n\t\t\tvar dataMin = Number.MAX_SAFE_INTEGER;\n\t\t\tvar dataMax = Number.MIN_SAFE_INTEGER;\n\n\t\t\tvar chartData = me.chart.data;\n\t\t\tvar parsedData = {\n\t\t\t\tlabels: [],\n\t\t\t\tdatasets: []\n\t\t\t};\n\n\t\t\tvar timestamp;\n\n\t\t\thelpers.each(chartData.labels, function(label, labelIndex) {\n\t\t\t\tvar labelMoment = parseTime(me, label);\n\n\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t// We need to round the time\n\t\t\t\t\tif (timeOpts.round) {\n\t\t\t\t\t\tlabelMoment.startOf(timeOpts.round);\n\t\t\t\t\t}\n\n\t\t\t\t\ttimestamp = labelMoment.valueOf();\n\t\t\t\t\tdataMin = Math.min(timestamp, dataMin);\n\t\t\t\t\tdataMax = Math.max(timestamp, dataMax);\n\n\t\t\t\t\t// Store this value for later\n\t\t\t\t\tparsedData.labels[labelIndex] = timestamp;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(chartData.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar timestamps = [];\n\n\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null && me.chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\t// We have potential point data, so we need to parse this\n\t\t\t\t\thelpers.each(dataset.data, function(value, dataIndex) {\n\t\t\t\t\t\tvar dataMoment = parseTime(me, me.getRightValue(value));\n\n\t\t\t\t\t\tif (dataMoment.isValid()) {\n\t\t\t\t\t\t\tif (timeOpts.round) {\n\t\t\t\t\t\t\t\tdataMoment.startOf(timeOpts.round);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttimestamp = dataMoment.valueOf();\n\t\t\t\t\t\t\tdataMin = Math.min(timestamp, dataMin);\n\t\t\t\t\t\t\tdataMax = Math.max(timestamp, dataMax);\n\t\t\t\t\t\t\ttimestamps[dataIndex] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// We have no x coordinates, so use the ones from the labels\n\t\t\t\t\ttimestamps = parsedData.labels.slice();\n\t\t\t\t}\n\n\t\t\t\tparsedData.datasets[datasetIndex] = timestamps;\n\t\t\t});\n\n\t\t\tme.dataMin = dataMin;\n\t\t\tme.dataMax = dataMax;\n\t\t\tme._parsedData = parsedData;\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar timeOpts = me.options.time;\n\n\t\t\tvar minTimestamp;\n\t\t\tvar maxTimestamp;\n\t\t\tvar dataMin = me.dataMin;\n\t\t\tvar dataMax = me.dataMax;\n\n\t\t\tif (timeOpts.min) {\n\t\t\t\tvar minMoment = parseTime(me, timeOpts.min);\n\t\t\t\tif (timeOpts.round) {\n\t\t\t\t\tminMoment.round(timeOpts.round);\n\t\t\t\t}\n\t\t\t\tminTimestamp = minMoment.valueOf();\n\t\t\t}\n\n\t\t\tif (timeOpts.max) {\n\t\t\t\tmaxTimestamp = parseTime(me, timeOpts.max).valueOf();\n\t\t\t}\n\n\t\t\tvar maxTicks = me.getLabelCapacity(minTimestamp || dataMin);\n\t\t\tvar unit = timeOpts.unit || determineUnit(timeOpts.minUnit, minTimestamp || dataMin, maxTimestamp || dataMax, maxTicks);\n\t\t\tme.displayFormat = timeOpts.displayFormats[unit];\n\n\t\t\tvar stepSize = timeOpts.stepSize || determineStepSize(minTimestamp || dataMin, maxTimestamp || dataMax, unit, maxTicks);\n\t\t\tme.ticks = Chart.Ticks.generators.time({\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: minTimestamp,\n\t\t\t\tmax: maxTimestamp,\n\t\t\t\tstepSize: stepSize,\n\t\t\t\tunit: unit,\n\t\t\t\tisoWeekday: timeOpts.isoWeekday\n\t\t\t}, {\n\t\t\t\tmin: dataMin,\n\t\t\t\tmax: dataMax\n\t\t\t});\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(me.ticks);\n\t\t\tme.min = helpers.min(me.ticks);\n\t\t},\n\t\t// Get tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n\t\t\tvar value = me.chart.data.datasets[datasetIndex].data[index];\n\n\t\t\tif (value !== null && typeof value === 'object') {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\n\t\t\t// Format nicely\n\t\t\tif (me.options.time.tooltipFormat) {\n\t\t\t\tlabel = parseTime(me, label).format(me.options.time.tooltipFormat);\n\t\t\t}\n\n\t\t\treturn label;\n\t\t},\n\t\t// Function to format an individual tick mark\n\t\ttickFormatFunction: function(tick, index, ticks) {\n\t\t\tvar formattedTick = tick.format(this.displayFormat);\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\tif (callback) {\n\t\t\t\treturn callback(formattedTick, index, ticks);\n\t\t\t}\n\t\t\treturn formattedTick;\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsTimestamps = me.ticks;\n\t\t\tme.ticks = me.ticks.map(function(tick) {\n\t\t\t\treturn moment(tick);\n\t\t\t}).map(me.tickFormatFunction, me);\n\t\t},\n\t\tgetPixelForOffset: function(offset) {\n\t\t\tvar me = this;\n\t\t\tvar epochWidth = me.max - me.min;\n\t\t\tvar decimal = epochWidth ? (offset - me.min) / epochWidth : 0;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueOffset = (me.width * decimal);\n\t\t\t\treturn me.left + Math.round(valueOffset);\n\t\t\t}\n\n\t\t\tvar heightOffset = (me.height * decimal);\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar offset = null;\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\toffset = me._parsedData.datasets[datasetIndex][index];\n\t\t\t}\n\n\t\t\tif (offset === null) {\n\t\t\t\tif (!value || !value.isValid) {\n\t\t\t\t\t// not already a moment object\n\t\t\t\t\tvalue = parseTime(me, me.getRightValue(value));\n\t\t\t\t}\n\n\t\t\t\tif (value && value.isValid && value.isValid()) {\n\t\t\t\t\toffset = value.valueOf();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (offset !== null) {\n\t\t\t\treturn me.getPixelForOffset(offset);\n\t\t\t}\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForOffset(this.ticksAsTimestamps[index]);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension = me.isHorizontal() ? me.width : me.height;\n\t\t\tvar offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\n\t\t\treturn moment(me.min + (offset * (me.max - me.min)));\n\t\t},\n\t\t// Crude approximation of what the label width might be\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticks = me.options.ticks;\n\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar cosRotation = Math.cos(helpers.toRadians(ticks.maxRotation));\n\t\t\tvar sinRotation = Math.sin(helpers.toRadians(ticks.maxRotation));\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(ticks.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\n\t\t\tme.displayFormat = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n\t\t\tvar exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\t\t\tvar labelCapacity = innerWidth / tickLabelWidth;\n\t\t\treturn labelCapacity;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/src/scales/scale.time.js\n// module id = 949\n// module chunks = 4 6 7","/* MIT license */\r\nvar colorNames = require('color-name');\r\n\r\nmodule.exports = {\r\n   getRgba: getRgba,\r\n   getHsla: getHsla,\r\n   getRgb: getRgb,\r\n   getHsl: getHsl,\r\n   getHwb: getHwb,\r\n   getAlpha: getAlpha,\r\n\r\n   hexString: hexString,\r\n   rgbString: rgbString,\r\n   rgbaString: rgbaString,\r\n   percentString: percentString,\r\n   percentaString: percentaString,\r\n   hslString: hslString,\r\n   hslaString: hslaString,\r\n   hwbString: hwbString,\r\n   keyword: keyword\r\n}\r\n\r\nfunction getRgba(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var abbr =  /^#([a-fA-F0-9]{3})$/,\r\n       hex =  /^#([a-fA-F0-9]{6})$/,\r\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n       keyword = /(\\w+)/;\r\n\r\n   var rgb = [0, 0, 0],\r\n       a = 1,\r\n       match = string.match(abbr);\r\n   if (match) {\r\n      match = match[1];\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match[i] + match[i], 16);\r\n      }\r\n   }\r\n   else if (match = string.match(hex)) {\r\n      match = match[1];\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\r\n      }\r\n   }\r\n   else if (match = string.match(rgba)) {\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = parseInt(match[i + 1]);\r\n      }\r\n      a = parseFloat(match[4]);\r\n   }\r\n   else if (match = string.match(per)) {\r\n      for (var i = 0; i < rgb.length; i++) {\r\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\r\n      }\r\n      a = parseFloat(match[4]);\r\n   }\r\n   else if (match = string.match(keyword)) {\r\n      if (match[1] == \"transparent\") {\r\n         return [0, 0, 0, 0];\r\n      }\r\n      rgb = colorNames[match[1]];\r\n      if (!rgb) {\r\n         return;\r\n      }\r\n   }\r\n\r\n   for (var i = 0; i < rgb.length; i++) {\r\n      rgb[i] = scale(rgb[i], 0, 255);\r\n   }\r\n   if (!a && a != 0) {\r\n      a = 1;\r\n   }\r\n   else {\r\n      a = scale(a, 0, 1);\r\n   }\r\n   rgb[3] = a;\r\n   return rgb;\r\n}\r\n\r\nfunction getHsla(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n   var match = string.match(hsl);\r\n   if (match) {\r\n      var alpha = parseFloat(match[4]);\r\n      var h = scale(parseInt(match[1]), 0, 360),\r\n          s = scale(parseFloat(match[2]), 0, 100),\r\n          l = scale(parseFloat(match[3]), 0, 100),\r\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n      return [h, s, l, a];\r\n   }\r\n}\r\n\r\nfunction getHwb(string) {\r\n   if (!string) {\r\n      return;\r\n   }\r\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n   var match = string.match(hwb);\r\n   if (match) {\r\n    var alpha = parseFloat(match[4]);\r\n      var h = scale(parseInt(match[1]), 0, 360),\r\n          w = scale(parseFloat(match[2]), 0, 100),\r\n          b = scale(parseFloat(match[3]), 0, 100),\r\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n      return [h, w, b, a];\r\n   }\r\n}\r\n\r\nfunction getRgb(string) {\r\n   var rgba = getRgba(string);\r\n   return rgba && rgba.slice(0, 3);\r\n}\r\n\r\nfunction getHsl(string) {\r\n  var hsla = getHsla(string);\r\n  return hsla && hsla.slice(0, 3);\r\n}\r\n\r\nfunction getAlpha(string) {\r\n   var vals = getRgba(string);\r\n   if (vals) {\r\n      return vals[3];\r\n   }\r\n   else if (vals = getHsla(string)) {\r\n      return vals[3];\r\n   }\r\n   else if (vals = getHwb(string)) {\r\n      return vals[3];\r\n   }\r\n}\r\n\r\n// generators\r\nfunction hexString(rgb) {\r\n   return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\r\n              + hexDouble(rgb[2]);\r\n}\r\n\r\nfunction rgbString(rgba, alpha) {\r\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n      return rgbaString(rgba, alpha);\r\n   }\r\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\r\n}\r\n\r\nfunction rgbaString(rgba, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\r\n   }\r\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\r\n           + \", \" + alpha + \")\";\r\n}\r\n\r\nfunction percentString(rgba, alpha) {\r\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n      return percentaString(rgba, alpha);\r\n   }\r\n   var r = Math.round(rgba[0]/255 * 100),\r\n       g = Math.round(rgba[1]/255 * 100),\r\n       b = Math.round(rgba[2]/255 * 100);\r\n\r\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\r\n}\r\n\r\nfunction percentaString(rgba, alpha) {\r\n   var r = Math.round(rgba[0]/255 * 100),\r\n       g = Math.round(rgba[1]/255 * 100),\r\n       b = Math.round(rgba[2]/255 * 100);\r\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\r\n}\r\n\r\nfunction hslString(hsla, alpha) {\r\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\r\n      return hslaString(hsla, alpha);\r\n   }\r\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\r\n}\r\n\r\nfunction hslaString(hsla, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\r\n   }\r\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\r\n           + alpha + \")\";\r\n}\r\n\r\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\r\n// (hwb have alpha optional & 1 is default value)\r\nfunction hwbString(hwb, alpha) {\r\n   if (alpha === undefined) {\r\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\r\n   }\r\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\r\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\r\n}\r\n\r\nfunction keyword(rgb) {\r\n  return reverseNames[rgb.slice(0, 3)];\r\n}\r\n\r\n// helpers\r\nfunction scale(num, min, max) {\r\n   return Math.min(Math.max(min, num), max);\r\n}\r\n\r\nfunction hexDouble(num) {\r\n  var str = num.toString(16).toUpperCase();\r\n  return (str.length < 2) ? \"0\" + str : str;\r\n}\r\n\r\n\r\n//create a list of reverse color names\r\nvar reverseNames = {};\r\nfor (var name in colorNames) {\r\n   reverseNames[colorNames[name]] = name;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chartjs-color-string/color-string.js\n// module id = 950\n// module chunks = 4 6 7","/* MIT license */\n\nmodule.exports = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n}\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/color-convert/conversions.js\n// module id = 951\n// module chunks = 4 6 7","var conversions = require(\"./conversions\");\n\nvar convert = function() {\n   return new Converter();\n}\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   }\n});\n\nmodule.exports = convert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/color-convert/index.js\n// module id = 952\n// module chunks = 4 6 7","module.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/color-name/index.js\n// module id = 953\n// module chunks = 4 6 7","export function defaultBar(data) {\n    return {\n        type: 'bar',\n        data: data,\n        options: {\n            legend: {\n                display: false\n            },\n            scales: {\n                yAxes: [{\n                    ticks: {\n                        beginAtZero: true\n                    },\n\n                }],\n            }\n        }\n    }\n}\n\nexport function horizontalBar(data) {\n    return {\n        type: 'horizontalBar',\n        data: data,\n        options: {\n            legend: {\n                display: false\n            },\n            scales: {\n                xAxes: [{\n                    ticks: {\n                        beginAtZero: true\n                    },\n                    label: {\n                        display: false\n                    },\n                }],\n                yAxes: [{\n                    display: false,\n                    stacked: true,\n                }]\n            }\n\n        }\n    }\n}\n\nexport function pie(data) {\n    return {\n        type: 'pie',\n        data: data,\n        options: {\n        }\n    }\n}\n\nexport function cleanInsightsByWeek() {\n    return {\n        labels: ['Semana: 1', 'Semana: 2', 'Semana: 3', 'Semana: 4', 'Semana: 5'],\n        datasets: [\n            {\n                label: 'Confirmado',\n                data: [0, 0, 0, 0, 0],\n                backgroundColor: 'rgba(0, 163, 105, .7)',\n                borderColor: '#00A369',\n                borderWidth: 0\n            },\n            {\n                label: 'Pendente',\n                data: [0, 0, 0, 0, 0],\n                backgroundColor: 'rgba(204, 204, 204, .7)',\n                borderColor: '#CCCCCC',\n                borderWidth: 0\n            },\n            {\n                label: 'Cancelado',\n                data: [0, 0, 0, 0, 0],\n                backgroundColor: 'rgba(255, 204, 95, .7)',\n                borderColor: '#FFCC5F',\n                borderWidth: 0\n            },\n            {\n                label: 'Atrasado',\n                data: [0, 0, 0, 0, 0],\n                backgroundColor: 'rgba(225, 74, 69, .7)',\n                borderColor: '#E14A45',\n                borderWidth: 0\n            }\n        ]\n    }\n}\nexport function cleanInsightsByCategory() {\n    return {\n        labels: [],\n        datasets: [\n            {\n                label: '',\n                data: [],\n                backgroundColor: [],\n                borderColor: [],\n                borderWidth: 0\n            }\n        ]\n    }\n}\nexport function cleanInsightsByStatus() {\n    return {\n        labels: ['Confirmadas', 'Pendentes', 'canceladas', 'atrasadas'],\n        datasets: [\n            {\n                label: '',\n                data: [],\n                backgroundColor: ['rgba(0, 163, 105, .7)', 'rgba(204, 204, 204, .7)', 'rgba(255, 204, 95, .7)', 'rgba(225, 74, 69, .7)'],\n                borderColor: ['#00A369', '#CCCCCC', '#FFCC5F', '#E14A45'],\n                borderWidth: 2\n            }\n        ]\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/models/ChartOptions.js"],"sourceRoot":""}